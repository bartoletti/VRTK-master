<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp</name>
    </assembly>
    <members>
        <member name="T:FastList`1.CompareFunc">
            <summary>
            Comparison function should return -1 if left is less than right, 1 if left is greater than right, and 0 if they match.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarMeshVertex.blendWeights" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.albedoTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.albedoMultiplier" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.metallicnessTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.glossinessScale" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.normalTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.heightTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.occlusionTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.emissionTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.emissionMultiplier" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.detailMaskTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.detailAlbedoTextureID" -->
        <!-- Badly formed XML comment ignored for member "F:ovrAvatarPBSMaterialState.detailNormalTextureID" -->
        <!-- Badly formed XML comment ignored for member "M:ovrAvatarPBSMaterialState.VectorEquals(UnityEngine.Vector4,UnityEngine.Vector4)" -->
        <member name="F:Oculus.Platform.Message.MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged">
            Sent when a launch intent is received (for both cold and warm starts). The
            payload is the type of the intent. ApplicationLifecycle.GetLaunchDetails()
            should be called to get the other details.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_AssetFile_DownloadUpdate">
            Sent to indicate download progress for asset files.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_HTTP_Transfer">
            Sent to indicate that more data has been read or an error occured.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Livestreaming_StatusChange">
            Indicates that the livestreaming session has been updated. You can use this
            information to throttle your game performance or increase CPU/GPU
            performance. Use Message.GetLivestreamingStatus() to extract the updated
            livestreaming status.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Matchmaking_MatchFound">
            Indicates that a match has been found, for example after calling
            Matchmaking.Enqueue(). Use Message.GetRoom() to extract the matchmaking
            room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_ConnectionStateChange">
            Indicates that a connection has been established or there's been an error.
            Use NetworkingPeer.GetState() to get the result; as above,
            NetworkingPeer.GetID() returns the ID of the peer this message is for.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PeerConnectRequest">
            Indicates that another user is attempting to establish a P2P connection
            with us. Use NetworkingPeer.GetID() to extract the ID of the peer.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Networking_PingResult">
            Generated in response to Net.Ping(). Either contains ping time in
            microseconds or indicates that there was a timeout.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_InviteAccepted">
             Indicates that the user has accepted an invitation, for example in Oculus
             Home. Use Message.GetString() to extract the ID of the room that the user
             has been inivted to as a string. Then call ovrID_FromString() to parse it
             into an ovrID.
            
             Note that you must call Room.Join() if you want to actually join the room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_InviteReceived">
            Handle this to notify the user when they've received an invitation to join
            a room in your game. You can use this in lieu of, or in addition to,
            polling for room invitations via Notification.GetRoomInviteNotifications().
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Room_RoomUpdate">
            Indicates that the current room has been updated. Use Message.GetRoom() to
            extract the updated room.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_ConnectRequest">
            Sent when another user is attempting to establish a VoIP connection. Use
            Message.GetNetworkingPeer() to extract information about the user, and
            Voip.Accept() to accept the connection.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_StateChange">
            Sent to indicate that the state of the VoIP connection changed. Use
            Message.GetNetworkingPeer() and NetworkingPeer.GetState() to extract the
            current state.
        </member>
        <member name="F:Oculus.Platform.Message.MessageType.Notification_Voip_SystemVoipState">
             Sent to indicate that some part of the overall state of SystemVoip has
             changed. Use Message.GetSystemVoipState() and the properties of
             SystemVoipState to extract the state that triggered the notification.
            
             Note that the state may have changed further since the notification was
             generated, and that you may call the `GetSystemVoip...()` family of
             functions at any time to get the current state directly.
        </member>
        <member name="M:Oculus.Platform.Packet.ReadBytes(System.Byte[])">
            Copies all the bytes in the payload into byte[] destination.  ex:
              Package package ...
              byte[] destination = new byte[package.Size];
              package.ReadBytes(destination);
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Connected">
            Connection to the peer is established.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Timeout">
            A timeout expired while attempting to (re)establish a connection. This can
            happen if peer is unreachable or rejected the connection.
        </member>
        <member name="F:Oculus.Platform.PeerConnectionState.Closed">
            Connection to the peer is closed. A connection transitions into this state
            when it is explicitly closed by either the local or remote peer calling
            Net.Close(). It also enters this state if the remote peer no longer
            responds to our keep-alive probes.
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate(Oculus.Platform.RoomJoinPolicy,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateAndJoinPrivate2.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.CreateAndJoinPrivate2(Oculus.Platform.RoomJoinPolicy,System.UInt32,Oculus.Platform.RoomOptions)">
             Creates a new private (client controlled) room and adds the caller to it.
             This type of room is good for matches where the user wants to play with
             friends, as they're primarially discoverable by examining which rooms your
             friends are in.
             \param joinPolicy Specifies who can join the room without an invite.
             \param maxUsers The maximum number of users allowed in the room, including the creator.
             \param roomOptions Additional room configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Get(System.UInt64)">
             Allows arbitrary rooms for the application to be loaded.
             \param roomID The room to load.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrent">
             Easy loading of the room you're currently in. If you don't want live
             updates on your current room (by using subscribeToUpdates), you can use
             this to refresh the data.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetCurrentForUser(System.UInt64)">
             Allows the current room for a given user to be loaded. Remember that the
             user's privacy settings may not allow their room to be loaded. Because of
             this, it's often possible to load the users in a room, but not to take
             those users and load their room.
             \param userID ID of the user for which to load the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers">
             DEPRECATED. Use GetInvitableUsers2.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetInvitableUsers2(Oculus.Platform.RoomOptions)">
             Loads a list of users you can invite to a room. These are pulled from your
             friends list and recently met lists and filtered for relevance and
             interest. If the room cannot be joined, this list will be empty. By
             default, the invitable users returned will be for the user's current room.
            
             If your application grouping was created after September 9 2017, recently
             met users will be included by default. If your application grouping was
             created before then, you can go to edit the setting in the "Rooms and
             Matchmaking" section of Platform Services at dashboard.oculus.com
            
             Customization can be done via RoomOptions. Create this object with
             RoomOptions(). The params that could be used are:
            
             1. RoomOptions.SetRoomId()- will return the invitable users for this room
             (instead of the current room).
            
             2. RoomOptions.SetOrdering() - returns the list of users in the provided
             ordering (see UserOrdering enum).
            
             3. RoomOptions.SetRecentlyMetTimeWindow() - how long long ago should we
             include users you've recently met in the results?
            
             4. RoomOptions.SetMaxUserResults() - we will limit the number of results
             returned. By default, the number is unlimited, but the server may choose to
             limit results for performance reasons.
            
             5. RoomOptions.SetExcludeRecentlyMet() - Don't include users recently in
             rooms with this user in the result. Also, see the above comment.
            
             Example custom C++ usage:
            
               auto roomOptions = ovr_RoomOptions_Create();
               ovr_RoomOptions_SetOrdering(roomOptions, ovrUserOrdering_PresenceAlphabetical);
               ovr_RoomOptions_SetRoomId(roomOptions, roomID);
               ovr_Room_GetInvitableUsers2(roomOptions);
               ovr_RoomOptions_Destroy(roomOptions);
             \param roomOptions Additional configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.GetModeratedRooms">
             Fetches the list of moderated rooms created for the application.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.InviteUser(System.UInt64,System.String)">
             Invites a user to the specified room. They will receive a notification via
             MessageType.Notification_Room_InviteReceived if they are in your game,
             and/or they can poll for room invites using
             Notification.GetRoomInviteNotifications().
             \param roomID The ID of your current room.
             \param inviteToken A user's invite token, returned by Room.GetInvitableUsers().
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join(System.UInt64,System.Boolean)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Join2(System.UInt64,Oculus.Platform.RoomOptions)">
             Joins the target room (leaving the one you're currently in).
             \param roomID The room to join.
             \param roomOptions Additional room configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.KickUser(System.UInt64,System.UInt64,System.Int32)">
             Allows the room owner to kick a user out of the current room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param userID The user to be kicked (cannot be yourself).
             \param kickDurationSeconds Length of the ban, in seconds.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.LaunchInvitableUserFlow(System.UInt64)">
             Launch the invitable user flow to invite to the logged in user's current
             room. This is intended to be a nice shortcut for developers not wanting to
             build out their own Invite UI although it has the same rules as if you
             build it yourself.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.Leave(System.UInt64)">
             Removes you from your current room. Returns the solo room you are now in if
             it succeeds
             \param roomID The room you're currently in.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.SetDescription(System.UInt64,System.String)">
             Allows the room owner to set the description of their room.
             \param roomID The room that you currently own (check Room.GetOwner()).
             \param description The new name of the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateMembershipLockStatus(System.UInt64,Oculus.Platform.RoomMembershipLockStatus)">
             Disallow new members from being able to join the room. This will prevent
             joins from Room.Join(), invites, 'Join From Home', etc. Users that are in
             the room at the time of lockdown WILL be able to rejoin.
             \param roomID The room whose membership you want to lock or unlock.
             \param membershipLockStatus The new LockStatus for the room
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdateOwner(System.UInt64,System.UInt64)">
             Allows the room owner to transfer ownership to someone else.
             \param roomID The room that the user owns (check Room.GetOwner()).
             \param userID The new user to make an owner; the user must be in the room.
            
        </member>
        <member name="M:Oculus.Platform.Rooms.UpdatePrivateRoomJoinPolicy(System.UInt64,Oculus.Platform.RoomJoinPolicy)">
             Sets the join policy of the user's private room.
             \param roomID The room ID that the user owns (check Room.GetOwner()).
             \param newJoinPolicy The new join policy for the room.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.GetStatus">
             Return the status of the current livestreaming session if there is one.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.PauseStream">
             Pauses the livestreaming session if there is one. NOTE: this function is
             safe to call if no session is active.
            
        </member>
        <member name="M:Oculus.Platform.Livestreaming.ResumeStream">
             Resumes the livestreaming session if there is one. NOTE: this function is
             safe to call if no session is active.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Browse2.
             \param pool A BROWSE type matchmaking pool.
             \param customQueryData Optional. Custom query data.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Browse2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE
            
             See overview documentation above.
            
             Return a list of matchmaking rooms in the current pool filtered by skill
             and ping (if enabled). This also enqueues the user in the matchmaking
             queue. When the user has made a selection, call Room.Join2() on one of the
             rooms that was returned. If the user stops browsing, call
             Matchmaking.Cancel().
            
             In addition to the list of rooms, enqueue results are also returned. Call
             MatchmakingBrowseResult.GetEnqueueResult() to obtain them. See
             OVR_MatchmakingEnqueueResult.h for details.
             \param pool A BROWSE type matchmaking pool.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel(System.String,System.String)">
             DEPRECATED. Use Cancel2.
             \param pool The pool in question.
             \param requestHash Used to find your entry in a queue.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Cancel">
             Modes: QUICKMATCH, BROWSE
            
             Makes a best effort to cancel a previous Enqueue request before a match
             occurs. Typically triggered when a user gives up waiting. For BROWSE mode,
             call this when a user gives up looking through the room list or when the
             host of a room wants to stop receiving new users. If you don't cancel but
             the user goes offline, the user/room will be timed out of the queue within
             30 seconds.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom(System.String,System.UInt32,System.Boolean,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use CreateAndEnqueueRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when the room data changes, such as when users join or leave.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateAndEnqueueRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             See overview documentation above.
            
             Create a matchmaking room, join it, and enqueue it. This is the preferred
             method. But, if you do not wish to automatically enqueue the room, you can
             call CreateRoom2 instead.
            
             Visit https://developer2.oculus.com/application/[YOUR_APP_ID]/matchmaking
             to set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom(System.String,System.UInt32,System.Boolean)">
             DEPRECATED. Use CreateRoom2.
             \param pool The matchmaking pool to use, which is defined for the app.
             \param maxUsers Overrides the Max Users value, which is configured in pool settings of the Developer Dashboard.
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.CreateRoom2(System.String,Oculus.Platform.MatchmakingOptions)">
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom2. However, Oculus recommends using
             CreateAndEnqueueRoom2 instead.
            
             Modes: BROWSE, QUICKMATCH (Advanced; Can Users Create Rooms = true)
            
             Create a matchmaking room and join it, but do not enqueue the room. After
             creation, you can call EnqueueRoom. Consider using CreateAndEnqueueRoom
             instead.
            
             Visit https://developer2.oculus.com/application/[YOUR_APP_ID]/matchmaking
             to set up pools and queries
             \param pool The matchmaking pool to use, which is defined for the app.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue(System.String,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Use Enqueue2.
             \param pool The pool to enqueue in.
             \param customQueryData Optional.  See "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.Enqueue2(System.String,Oculus.Platform.MatchmakingOptions)">
             Modes: QUICKMATCH
            
             See overview documentation above.
            
             Enqueue yourself to await an available matchmaking room. The platform
             returns a MessageType.Notification_Matchmaking_MatchFound message when a
             match is found. Call Room.Join2() on the returned room. The response
             contains useful information to display to the user to set expectations for
             how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param pool The pool to enqueue in.
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom(System.UInt64,Oculus.Platform.Matchmaking.CustomQuery)">
             DEPRECATED. Please use Matchmaking.EnqueueRoom2() instead.
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param customQueryData Optional.  See the "Custom criteria" section above.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.EnqueueRoom2(System.UInt64,Oculus.Platform.MatchmakingOptions)">
             Modes: BROWSE (for Rooms only), ROOM
            
             See the overview documentation above. Enqueue yourself to await an
             available matchmaking room. MessageType.Notification_Matchmaking_MatchFound
             gets enqueued when a match is found.
            
             The response contains useful information to display to the user to set
             expectations for how long it will take to get a match.
            
             If the user stops waiting, call Matchmaking.Cancel().
             \param roomID Returned either from MessageType.Notification_Matchmaking_MatchFound or from Matchmaking.CreateRoom().
             \param matchmakingOptions Additional matchmaking configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.GetAdminSnapshot">
             Modes: QUICKMATCH, BROWSE
            
             Used to debug the state of the current matchmaking pool queue. This is not
             intended to be used in production.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.JoinRoom(System.UInt64,System.Boolean)">
             DEPRECATED. Use ovr_Room_Join2.
             \param roomID ID of a room previously returned from MessageType.Notification_Matchmaking_MatchFound or Matchmaking.Browse().
             \param subscribeToUpdates If true, sends a message with type MessageType.Notification_Room_RoomUpdate when room data changes, such as when users join or leave.
            
        </member>
        <member name="M:Oculus.Platform.Matchmaking.StartMatch(System.UInt64)">
             Modes: QUICKMATCH, BROWSE (+ Skill Pool)
            
             For pools with skill-based matching. See overview documentation above.
            
             Call after calling Room.Join2() when the players are present to begin a
             rated match for which you plan to report the results (using
             Matchmaking.ReportResultInsecure()).
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntries(System.String,System.Int32,Oculus.Platform.LeaderboardFilterType,Oculus.Platform.LeaderboardStartAt)">
             Requests a block of Leaderboard Entries.
             \param leaderboardName The name of the leaderboard whose entries to return.
             \param limit Defines the maximum number of entries to return.
             \param filter Allows you to restrict the returned values by friends.
             \param startAt Defines whether to center the query on the user or start at the top of the leaderboard.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.GetEntriesAfterRank(System.String,System.Int32,System.UInt64)">
             Requests a block of leaderboard Entries.
             \param leaderboardName The name of the leaderboard.
             \param limit The maximum number of entries to return.
             \param afterRank The position after which to start.  For example, 10 returns leaderboard results starting with the 11th user.
            
        </member>
        <member name="M:Oculus.Platform.Leaderboards.WriteEntry(System.String,System.Int64,System.Byte[],System.Boolean)">
             Writes a single entry to a leaderboard.
             \param leaderboardName The leaderboard for which to write the entry.
             \param score The score to write.
             \param extraData A 2KB custom data field that is associated with the leaderboard entry. This can be a game replay or anything that provides more detail about the entry to the viewer.
             \param forceUpdate If true, the score always updates.  This happens even if it is not the user's best score.
            
        </member>
        <member name="M:Oculus.Platform.Voip.SetSystemVoipSuppressed(System.Boolean)">
             Sets whether SystemVoip should be suppressed so that this app's Voip can
             use the mic and play incoming Voip audio.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddCount(System.String,System.UInt64)">
             Add 'count' to the achievement with the given name. This must be a COUNT
             achievement.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.AddFields(System.String,System.String)">
             Unlock fields of a BITFIELD achievement.
             \param name The name of the achievement to unlock
             \param fields A string containing either '0' or '1' characters. Every '1' will unlock the field in the corresponding position.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllDefinitions">
             Request all achievement definitions for the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetAllProgress">
             Request the progress for the user on all achievements in the app.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetDefinitionsByName(System.String[])">
             Request the achievement definitions that match the specified names.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.GetProgressByName(System.String[])">
             Request the user's progress on the specified achievements.
            
        </member>
        <member name="M:Oculus.Platform.Achievements.Unlock(System.String)">
             Unlock the achievement with the given name. This can be of any achievement
             type.
            
        </member>
        <member name="M:Oculus.Platform.Application.GetVersion">
             Requests version information, including the currently installed and latest
             available version name and version code.
            
        </member>
        <member name="M:Oculus.Platform.Application.LaunchOtherApp(System.UInt64,Oculus.Platform.ApplicationOptions)">
             Launches a different application in the user's library. If the user does
             not have that application installed, they will be taken to that app's page
             in the Oculus Store
             \param appID The ID of the app to launch
             \param deeplink_options Additional configuration for this requests. Optional.
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.Delete(System.UInt64)">
             Removes an previously installed asset file from the device by its ID.
             Returns an object containing the asset file ID and a success flag.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.Download(System.UInt64)">
             Downloads an asset file by its ID on demand. Returns an object containing
             filepath on the file system. Sends periodic
             MessageType.Notification_AssetFile_DownloadUpdate to track the downloads.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.AssetFile.DownloadCancel(System.UInt64)">
             Cancels a previously spawned download request for an asset file by its ID.
             Returns an object containing asset file ID, and the success flag.
             \param assetFileID The asset file ID
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Delete(System.String,System.String)">
             Deletes the specified save data buffer. Conflicts are handled just like
             Saves.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Load(System.String,System.String)">
             Loads the saved entry for the specified bucket and key. If a conflict
             exists with the key then an error message is returned.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadBucketMetadata(System.String)">
             Loads all the metadata for the saves in the specified bucket, including
             conflicts.
             \param bucket The name of the storage bucket.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadConflictMetadata(System.String,System.String)">
             Loads the metadata for this bucket-key combination that need to be manually
             resolved.
             \param bucket The name of the storage bucket
             \param key The key for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadHandle(System.String)">
             Loads the data specified by the storage handle.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.LoadMetadata(System.String,System.String)">
             load the metadata for the specified key
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepLocal(System.String,System.String,System.String)">
             Selects the local save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote that the local file was resolved against.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.ResolveKeepRemote(System.String,System.String,System.String)">
             Selects the remote save for manual conflict resolution.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param remoteHandle The handle of the remote.
            
        </member>
        <member name="M:Oculus.Platform.CloudStorage.Save(System.String,System.String,System.Byte[],System.Int64,System.String)">
             Note: Cloud Storage is only available for Rift apps.
            
             Send a save data buffer to the platform. CloudStorage.Save() passes a
             pointer to your data in an async call. You need to maintain the save data
             until you receive the message indicating that the save was successful.
            
             If the data is destroyed or modified prior to receiving that message the
             data will not be saved.
             \param bucket The name of the storage bucket.
             \param key The name for this saved data.
             \param data Start of the data block.
             \param counter Optional. Counter used for user data or auto-deconfliction.
             \param extraData Optional. String data that isn't used by the platform.
            
        </member>
        <member name="M:Oculus.Platform.Entitlements.IsUserEntitledToApplication">
             Returns whether the current user is entitled to the current app.
            
        </member>
        <member name="M:Oculus.Platform.IAP.ConsumePurchase(System.String)">
             Allow the consumable IAP product to be purchased again. Conceptually, this
             indicates that the item was used or consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetProductsBySKU(System.String[])">
             Retrieve a list of IAP products that can be purchased.
             \param skus The SKUs of the products to retrieve.
            
        </member>
        <member name="M:Oculus.Platform.IAP.GetViewerPurchases">
             Retrieve a list of Purchase that the Logged-In-User has made. This list
             will also contain consumable purchases that have not been consumed.
            
        </member>
        <member name="M:Oculus.Platform.IAP.LaunchCheckoutFlow(System.String)">
             Launch the checkout flow to purchase the existing product. Oculus Home
             tries handle and fix as many errors as possible. Home returns the
             appropriate error message and how to resolveit, if possible. Returns a
             purchase on success, empty purchase on cancel, and an error on error.
             \param sku IAP sku for the item the user wishes to purchase.
            
        </member>
        <member name="M:Oculus.Platform.Media.ShareToFacebook(System.String,System.String,Oculus.Platform.MediaContentType)">
             Launch the Share to Facebook modal via a deeplink to Home on Gear VR,
             allowing users to share local media files to Facebook. Accepts a
             postTextSuggestion string for the default text of the Facebook post.
             Requires a filePath string as the path to the image to be shared to
             Facebook. This image should be located in your app's internal storage
             directory. Requires a contentType indicating the type of media to be shared
             (only 'photo' is currently supported.)
             \param postTextSuggestion this text will prepopulate the facebook status text-input box within the share modal
             \param filePath path to the file to be shared to facebook
             \param contentType content type of the media to be shared
            
        </member>
        <member name="M:Oculus.Platform.Notifications.GetRoomInviteNotifications">
             Retrieve a list of all pending room invites for your application (for
             example, notifications that may have been sent before the user launched
             your game). You can also get push notifications with
             MessageType.Notification_Room_InviteReceived.
            
        </member>
        <member name="M:Oculus.Platform.Notifications.MarkAsRead(System.UInt64)">
             Mark a notification as read. This causes it to disappear from the Universal
             Menu, the Oculus App, Oculus Home, and in-app retrieval.
            
        </member>
        <member name="M:Oculus.Platform.Parties.GetCurrent">
             Load the party the current user is in.
            
        </member>
        <member name="M:Oculus.Platform.Users.Get(System.UInt64)">
             Retrieve the user with the given ID. This might fail if the ID is invalid
             or the user is blocked.
            
             NOTE: Users will have a unique ID per application.
             \param userID User ID retrieved with this application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetAccessToken">
             Return an access token for this user, suitable for making REST calls
             against graph.oculus.com.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUser">
             Retrieve the currently signed in user. This call is available offline.
            
             NOTE: This will not return the user's presence as it should always be
             'online' in your application.
            
             NOTE: Users will have a unique ID per application.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriends">
             Retrieve a list of the logged in user's friends.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserFriendsAndRooms">
             Retrieve a list of the logged in user's friends and any rooms they might be
             in.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetLoggedInUserRecentlyMetUsersAndRooms(Oculus.Platform.UserOptions)">
             Returns a list of users that the logged in user was in a room with
             recently, sorted by relevance, along with any rooms they might be in. All
             you need to do to use this method is to use our Rooms API, and we will
             track the number of times users are together, their most recent encounter,
             and the amount of time they spend together.
            
             Customization can be done via UserOptions. Create this object with
             UserOptions(). The params that could be used are:
            
             1. UserOptions.SetTimeWindow() - how recently should the users have played?
             The default is TimeWindow.ThirtyDays.
            
             2. UserOptions.SetMaxUsers() - we will limit the number of results
             returned. By default, the number is unlimited, but the server may choose to
             limit results for performance reasons.
             \param userOptions Additional configuration for this request. Optional.
            
        </member>
        <member name="M:Oculus.Platform.Users.GetOrgScopedID(System.UInt64)">
             returns an ovrID which is unique per org. allows different apps within the
             same org to identify the user.
             \param userID to load the org scoped id of
            
        </member>
        <member name="M:Oculus.Platform.Users.GetSdkAccounts">
             Returns all accounts belonging to this user. Accounts are the Oculus user
             and x-users that are linked to this user.
            
        </member>
        <!-- Badly formed XML comment ignored for member "M:Oculus.Platform.Users.GetUserProof" -->
        <member name="M:Oculus.Platform.Users.LaunchProfile(System.UInt64)">
             Launch the profile of the given user on Gear VR. The profile surfaces
             information about the user and supports relevant actions that the viewer
             may take on that user, e.g. sending a friend request.
             \param userID User ID for profile being viewed
            
        </member>
        <member name="M:Oculus.Platform.Request.RunCallbacks(System.UInt32)">
            This will run callbacks on all messages that returned from the server.
            If too many message are coming back at once, then a limit can be passed in
            as an arg to limit the number of messages to run callbacks on at a time
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Unreliable">
             Sends a message using an unreliable data channel (UDP-based). No delivery
             or ordering guarantees are provided. Sending will fail unless a connection
             to the peer is already established, either via a previous call to
             Net.SendPacket() or an explicit Net.Connect().
            
             Ideally, each message should fit into a single packet. Therefore, it is
             recommended to keep them under 1200 bytes.
        </member>
        <member name="F:Oculus.Platform.SendPolicy.Reliable">
            Messages are delivered reliably and in order. The networking layer retries
            until each message is acknowledged by the peer. Outgoing messages are
            buffered until a working connection to the peer is established.
        </member>
        <member name="F:Oculus.Platform.UserOrdering.None">
            No preference for ordering (could be in any or no order)
        </member>
        <member name="F:Oculus.Platform.UserOrdering.PresenceAlphabetical">
            Orders by online users first and then offline users. Within each group the
            users are ordered alphabetically by display name
        </member>
        <member name="M:EnableSwitch.SetActive(System.Int32)">
            <summary>
            Sets the active GameObject
            </summary>
            <returns><c>true</c>, if active was set, <c>false</c> otherwise.</returns>
            <param name="target">Target.</param>
        </member>
        <member name="M:LipSyncDemo_SetCurrentTarget.SetCurrentTarget">
            <summary>
            Sets the current target.
            </summary>
        </member>
        <member name="M:LipSyncDemo_SetCurrentTarget.LocalTouchEventCallback(OVRTouchpad.TouchEvent)">
            <summary>
            Local touch event callback.
            </summary>
            <param name="touchEvent">Touch event.</param>
        </member>
        <member name="P:OVRLipSyncDebugConsole.instance">
            <summary>
            Gets the instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Init">
            <summary>
            Init this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Log(System.String)">
            <summary>
            Log the specified message.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Log(System.String,UnityEngine.Color)">
            <summary>
            Log the specified message and color.
            </summary>
            <param name="message">Message.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:OVRLipSyncDebugConsole.Clear">
            <summary>
            Clear this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncDebugConsole.ClearTimeout(System.Single)">
            <summary>
            Calls clear after a certain time.
            </summary>
            <param name="timeToClear">Time to clear.</param>
        </member>
        <member name="M:OVRLipSyncDebugConsole.AddMessage(System.String,UnityEngine.Color)">
            <summary>
            Adds the message.
            </summary>
            <param name="message">Message.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:OVRLipSyncDebugConsole.ClearMessages">
            <summary>
            Clears the messages.
            </summary>
        </member>
        <member name="M:OVRLipSyncDebugConsole.SetClearTimeout(System.Single)">
            <summary>
            Sets the clear timeout.
            </summary>
            <param name="timeout">Timeout.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncDebugConsole.Prune" -->
        <member name="M:OVRLipSyncDebugConsole.Display">
            <summary>
            Display this instance.
            </summary>
        </member>
        <member name="M:OVRMessenger.MarkAsPermanent(System.String)">
            <summary>
            Marks a certain message as permanent.
            </summary>
            <param name="eventType">Event type.</param>
        </member>
        <member name="M:OVRMessenger.Cleanup">
            <summary>
            Cleanup this instance.
            </summary>
        </member>
        <member name="M:OVRMessenger.PrintEventTable">
            <summary>
            Prints the event table.
            </summary>
        </member>
        <member name="M:OVRMessenger.OnListenerAdding(System.String,System.Delegate)">
            <summary>
            Raises the listener adding event.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="listenerBeingAdded">Listener being added.</param>
        </member>
        <member name="M:OVRMessenger.OnListenerRemoving(System.String,System.Delegate)">
            <summary>
            Raises the listener removing event.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="listenerBeingRemoved">Listener being removed.</param>
        </member>
        <member name="M:OVRMessenger.OnListenerRemoved(System.String)">
            <summary>
            Raises the listener removed event.
            </summary>
            <param name="eventType">Event type.</param>
        </member>
        <member name="M:OVRMessenger.OnBroadcasting(System.String)">
            <summary>
            Raises the broadcasting event.
            </summary>
            <param name="eventType">Event type.</param>
        </member>
        <member name="M:OVRMessenger.CreateBroadcastSignatureException(System.String)">
            <summary>
            Creates the broadcast signature exception.
            </summary>
            <returns>The broadcast signature exception.</returns>
            <param name="eventType">Event type.</param>
        </member>
        <member name="M:OVRMessenger.AddListener(System.String,OVRCallback)">
            <summary>
            No parameters.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
        </member>
        <member name="M:OVRMessenger.AddListener``1(System.String,OVRCallback{``0})">
            <summary>
            Single parameter.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:OVRMessenger.AddListener``2(System.String,OVRCallback{``0,``1})">
            <summary>
            Two parameters.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
            <typeparam name="U">The 2nd type parameter.</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OVRMessenger.AddListener``3(System.String,OVRCallback{``0,``1,``2})" -->
        <member name="M:OVRMessenger.RemoveListener(System.String,OVRCallback)">
            <summary>
            No parameters
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
        </member>
        <member name="M:OVRMessenger.RemoveListener``1(System.String,OVRCallback{``0})">
            <summary>
            Single parameter
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:OVRMessenger.RemoveListener``2(System.String,OVRCallback{``0,``1})">
            <summary>
            Two parameters
            </summary>
            <param name="eventType">Event type.</param>
            <param name="handler">Handler.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
            <typeparam name="U">The 2nd type parameter.</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OVRMessenger.RemoveListener``3(System.String,OVRCallback{``0,``1,``2})" -->
        <member name="M:OVRMessenger.Broadcast(System.String)">
            <summary>
            Broadcast the specified eventType.
            </summary>
            <param name="eventType">Event type.</param>
        </member>
        <member name="M:OVRMessenger.Broadcast``1(System.String,``0)">
            <summary>
            Broadcast the specified eventType and arg1.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="arg1">Arg1.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:OVRMessenger.Broadcast``2(System.String,``0,``1)">
            <summary>
            Broadcast the specified eventType, arg1 and arg2.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="arg1">Arg1.</param>
            <param name="arg2">Arg2.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
            <typeparam name="U">The 2nd type parameter.</typeparam>
        </member>
        <member name="M:OVRMessenger.Broadcast``3(System.String,``0,``1,``2)">
            <summary>
            Broadcast the specified eventType, arg1, arg2 and arg3.
            </summary>
            <param name="eventType">Event type.</param>
            <param name="arg1">Arg1.</param>
            <param name="arg2">Arg2.</param>
            <param name="arg3">Arg3.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
            <typeparam name="U">The 2nd type parameter.</typeparam>
            <typeparam name="V">The 3rd type parameter.</typeparam>
        </member>
        <member name="T:MessengerHelper">
            <summary>
            Messenger helper.
            This manager will ensure that the messenger's eventTable will be cleaned up upon loading of a new level.
            </summary>
        </member>
        <member name="M:MessengerHelper.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:MessengerHelper.OnDisable">
            <summary>
            Raises the disable event.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVRLipSync" -->
        <member name="T:OVRLipSync.Flags">
            Flags
        </member>
        <member name="T:OVRLipSync.Frame">
            NOTE: Opaque typedef for lip-sync context is an unsigned int (uint)
            Current phoneme frame results
        </member>
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.Awake" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.OnDestroy" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.IsInitialized" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.CreateContext(System.UInt32@,OVRLipSync.ContextProviders)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.DestroyContext(System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.ResetContext(System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.SendSignal(System.UInt32,OVRLipSync.Signals,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.ProcessFrame(System.UInt32,System.Single[],OVRLipSync.Flags,OVRLipSync.Frame)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSync.ProcessFrameInterleaved(System.UInt32,System.Single[],OVRLipSync.Flags,OVRLipSync.Frame)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContext.Start" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContext.Update" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContext.OnAudioFilterRead(System.Single[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContext.DebugShowVisemes" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextBase.Awake" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextBase.OnDestroy" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextBase.GetCurrentPhonemeFrame" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextBase.ResetContext" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextCanned.Update" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextMorphTarget.Start" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextMorphTarget.Update" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextMorphTarget.CheckForKeys" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextMorphTarget.SetVisemeToMorphTarget(OVRLipSync.Frame)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextMorphTarget.CheckVisemeKey(UnityEngine.KeyCode,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextTextureFlip.Start" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextTextureFlip.Update" -->
        <!-- Badly formed XML comment ignored for member "M:OVRLipSyncContextTextureFlip.SetVisemeToTexture" -->
        <member name="M:OVRLipSyncMicInput.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.OnApplicationFocus(System.Boolean)">
            <summary>
            Raises the application focus event.
            </summary>
            <param name="focus">If set to <c>true</c> focus.</param>
        </member>
        <member name="M:OVRLipSyncMicInput.OnApplicationPause(System.Boolean)">
            <summary>
            Raises the application pause event.
            </summary>
            <param name="focus">If set to <c>true</c> focus.</param>
        </member>
        <member name="M:OVRLipSyncMicInput.OnGUI">
            <summary>
            Raises the GU event.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.MicDeviceGUI(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Mics the device GU.
            </summary>
            <param name="left">Left.</param>
            <param name="top">Top.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="buttonSpaceTop">Button space top.</param>
            <param name="buttonSpaceLeft">Button space left.</param>
        </member>
        <member name="M:OVRLipSyncMicInput.GetMicCaps">
            <summary>
            Gets the mic caps.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.StartMicrophone">
            <summary>
            Starts the microphone.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.StopMicrophone">
            <summary>
            Stops the microphone.
            </summary>
        </member>
        <member name="M:OVRLipSyncMicInput.GetAveragedVolume">
            <summary>
            Gets the averaged volume.
            </summary>
            <returns>The averaged volume.</returns>
        </member>
        <member name="M:ONSPReflectionZone.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:ONSPReflectionZone.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:ONSPReflectionZone.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            Raises the trigger enter event.
            </summary>
            <param name="other">Other.</param>
        </member>
        <member name="M:ONSPReflectionZone.OnTriggerExit(UnityEngine.Collider)">
            <summary>
            Raises the trigger exit event.
            </summary>
            <param name="other">Other.</param>
        </member>
        <member name="M:ONSPReflectionZone.CheckForAudioListener(UnityEngine.GameObject)">
            <summary>
            Checks for audio listener.
            </summary>
            <returns><c>true</c>, if for audio listener was checked, <c>false</c> otherwise.</returns>
            <param name="gameObject">Game object.</param>
        </member>
        <member name="M:ONSPReflectionZone.PushCurrentMixerShapshot">
            <summary>
            Pushs the current mixer snapshot onto the snapshot stack
            </summary>
        </member>
        <member name="M:ONSPReflectionZone.PopCurrentMixerSnapshot">
            <summary>
            Pops the current reflection values from reflectionsList stack.
            </summary>
        </member>
        <member name="M:ONSPReflectionZone.SetReflectionValues">
            <summary>
            Sets the reflection values. This is done when entering a zone (use zone values).
            </summary>
        </member>
        <member name="M:ONSPReflectionZone.SetReflectionValues(ReflectionSnapshot@)">
            <summary>
            Sets the reflection values. This is done when exiting a zone (use popped values).
            </summary>
            <param name="rm">Rm.</param>
        </member>
        <member name="M:ONSPAmbisonicsNative.OnEnable">
            <summary>
            OnEnable this instance.
            </summary>
        </member>
        <member name="M:ONSPAmbisonicsNative.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:ONSPAudioSource.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:ONSPAudioSource.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:ONSPAudioSource.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:ONSPAudioSource.SetParameters(UnityEngine.AudioSource@)">
            <summary>
            Sets the parameters.
            </summary>
            <param name="source">Source.</param>
        </member>
        <member name="M:ONSPAudioSource.OnDrawGizmos">
            <summary>
            
            </summary>
        </member>
        <member name="M:ONSPAudioSource.OnDestroy">
            <summary>
            
            </summary>
        </member>
        <member name="M:ONSPVersion.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:ONSPVersion.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:ONSPVersion.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:VoiceModDemo_Logic.SetCurrentTarget">
            <summary>
            Sets the current target.
            </summary>
        </member>
        <member name="M:VoiceModDemo_Logic.LocalTouchEventCallback(OVRTouchpad.TouchEvent)">
            <summary>
            Local touch event callback.
            </summary>
            <param name="touchEvent">Touch event.</param>
        </member>
        <member name="M:VoiceModDemo_Logic.UpdateModelScale">
            <summary>
            Updates the model scale.
            </summary>
        </member>
        <member name="P:OVRDebugConsole.instance">
            <summary>
            Gets the instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="M:OVRDebugConsole.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRDebugConsole.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRDebugConsole.Init">
            <summary>
            Init this instance.
            </summary>
        </member>
        <member name="M:OVRDebugConsole.Log(System.String)">
            <summary>
            Log the specified message.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:OVRDebugConsole.Log(System.String,UnityEngine.Color)">
            <summary>
            Log the specified message and color.
            </summary>
            <param name="message">Message.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:OVRDebugConsole.Clear">
            <summary>
            Clear this instance.
            </summary>
        </member>
        <member name="M:OVRDebugConsole.ClearTimeout(System.Single)">
            <summary>
            Calls clear after a certain time.
            </summary>
            <param name="timeToClear">Time to clear.</param>
        </member>
        <member name="M:OVRDebugConsole.AddMessage(System.String,UnityEngine.Color)">
            <summary>
            Adds the message.
            </summary>
            <param name="message">Message.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:OVRDebugConsole.ClearMessages">
            <summary>
            Clears the messages.
            </summary>
        </member>
        <member name="M:OVRDebugConsole.SetClearTimeout(System.Single)">
            <summary>
            Sets the clear timeout.
            </summary>
            <param name="timeout">Timeout.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OVRDebugConsole.Prune" -->
        <member name="M:OVRDebugConsole.Display">
            <summary>
            Display this instance.
            </summary>
        </member>
        <member name="M:OVRMicInput.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRMicInput.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:OVRMicInput.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRMicInput.OnApplicationFocus(System.Boolean)">
            <summary>
            Raises the application focus event.
            </summary>
            <param name="focus">If set to <c>true</c> focus.</param>
        </member>
        <member name="M:OVRMicInput.OnApplicationPause(System.Boolean)">
            <summary>
            Raises the application pause event.
            </summary>
            <param name="focus">If set to <c>true</c> focus.</param>
        </member>
        <member name="M:OVRMicInput.OnGUI">
            <summary>
            Raises the GU event.
            </summary>
        </member>
        <member name="M:OVRMicInput.MicDeviceGUI(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Mics the device GU.
            </summary>
            <param name="left">Left.</param>
            <param name="top">Top.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="buttonSpaceTop">Button space top.</param>
            <param name="buttonSpaceLeft">Button space left.</param>
        </member>
        <member name="M:OVRMicInput.GetMicCaps">
            <summary>
            Gets the mic caps.
            </summary>
        </member>
        <member name="M:OVRMicInput.StartMicrophone">
            <summary>
            Starts the microphone.
            </summary>
        </member>
        <member name="M:OVRMicInput.StopMicrophone">
            <summary>
            Stops the microphone.
            </summary>
        </member>
        <member name="M:OVRMicInput.GetAveragedVolume">
            <summary>
            Gets the averaged volume.
            </summary>
            <returns>The averaged volume.</returns>
        </member>
        <member name="T:OVRVoiceMod">
             <summary>
             OVRVoiceMod interfaces into the Oculus voice-mod engine. This component should be added
             into the scene once. 
            
             </summary>
        </member>
        <member name="T:OVRVoiceMod.ovrViceModFlag">
            Flags (unused at this time)
        </member>
        <member name="F:OVRVoiceMod.strOVRLS">
            NOTE: Opaque typedef for voice mod context is an unsigned int (uint)
        </member>
        <member name="M:OVRVoiceMod.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRVoiceMod.Start">
            <summary>
            Start this instance.
            Note: make sure to always have a Start function for classes that have editor scripts.
            </summary>
        </member>
        <member name="M:OVRVoiceMod.Update">
            <summary>
            Run processes that need to be updated in our game thread
            </summary>
        </member>
        <member name="M:OVRVoiceMod.OnDestroy">
            <summary>
            Raises the destroy event.
            </summary>
        </member>
        <member name="M:OVRVoiceMod.IsInitialized">
            <summary>
            Determines if is initialized.
            </summary>
            <returns><c>true</c> if is initialized; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:OVRVoiceMod.CreateContext(System.UInt32@)">
            <summary>
            Creates the context.
            </summary>
            <returns>The context.</returns>
            <param name="context">Context.</param>
        </member>
        <member name="M:OVRVoiceMod.DestroyContext(System.UInt32)">
            <summary>
            Destroies the context.
            </summary>
            <returns>The context.</returns>
            <param name="context">Context.</param>
        </member>
        <member name="M:OVRVoiceMod.SendParameter(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sends the parameter.
            </summary>
            <returns>The parameter.</returns>
            <param name="context">Context.</param>
            <param name="parameter">Parameter.</param>
            <param name="value">Value.</param>
        </member>
        <member name="M:OVRVoiceMod.ProcessFrame(System.UInt32,System.Single[])">
            <summary>
            Processes the frame.
            </summary>
            <returns>The frame.</returns>
            <param name="context">Context.</param>
            <param name="audioBuffer">Audio buffer.</param>
        </member>
        <member name="M:OVRVoiceMod.ProcessFrameInterleaved(System.UInt32,System.Single[])">
            <summary>
            Processes the frame interleaved.
            </summary>
            <returns>The frame interleaved.</returns>
            <param name="context">Context.</param>
            <param name="audioBuffer">Audio buffer.</param>
        </member>
        <member name="M:OVRVoiceMod.GetAverageAbsVolume(System.UInt32)">
            <summary>
            Gets the average abs volume.
            </summary>
            <returns>The average abs volume.</returns>
            <param name="context">Context.</param>
            <param name="volume">Volume.</param>
        </member>
        <member name="M:OVRVoiceModContext.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRVoiceModContext.Start">
            <summary>
            Start this instance.
            Note: make sure to always have a Start function for classes that have editor scripts.
            </summary>
        </member>
        <member name="M:OVRVoiceModContext.Update">
            <summary>
            Run processes that need to be updated in our game thread
            </summary>
        </member>
        <member name="M:OVRVoiceModContext.OnDestroy">
            <summary>
            Raises the destroy event.
            </summary>
        </member>
        <member name="M:OVRVoiceModContext.OnAudioFilterRead(System.Single[],System.Int32)">
            <summary>
            Raises the audio filter read event.
            </summary>
            <param name="data">Data.</param>
            <param name="channels">Channels.</param>
        </member>
        <member name="M:OVRVoiceModContext.SendParameter(OVRVoiceModContext.ovrVoiceModParams,System.Int32)">
            <summary>
            Sends the parameter.
            </summary>
            <returns>The parameter.</returns>
            <param name="parameter">Parameter.</param>
            <param name="value">Value.</param>
        </member>
        <member name="M:OVRVoiceModContext.SetPreset(System.Int32)">
            <summary>
            Sets the preset.
            </summary>
            <returns><c>true</c>, if preset was set, <c>false</c> otherwise.</returns>
            <param name="preset">Preset.</param>
        </member>
        <member name="M:OVRVoiceModContext.GetNumPresets">
            <summary>
            Gets the number presets.
            </summary>
            <returns>The number presets.</returns>
        </member>
        <member name="M:OVRVoiceModContext.GetPresetColor(System.Int32)">
            <summary>
            Gets the color of the preset.
            </summary>
            <returns>The preset color.</returns>
            <param name="preset">Preset.</param>
        </member>
        <member name="M:OVRVoiceModContext.GetAverageAbsVolume">
            <summary>
            Gets the average abs volume.
            </summary>
            <returns>The average abs volume.</returns>
        </member>
        <member name="T:OVRMRForegroundCameraManager">
            <summary>
            Helper internal class for foregroundCamera, don't call it outside
            </summary>
        </member>
        <member name="T:OVRBoundary">
            <summary>
            Provides access to the Oculus boundary system.
            </summary>
        </member>
        <member name="T:OVRBoundary.Node">
            <summary>
            Specifies a tracked node that can be queried through the boundary system.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.HandRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.Node.Head" -->
        <member name="T:OVRBoundary.BoundaryType">
            <summary>
            Specifies a boundary type surface.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryType.PlayArea" -->
        <member name="T:OVRBoundary.BoundaryTestResult">
            <summary>
            Provides test results of boundary system queries.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestDistance" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPoint" -->
        <!-- Badly formed XML comment ignored for member "F:OVRBoundary.BoundaryTestResult.ClosestPointNormal" -->
        <member name="T:OVRBoundary.BoundaryLookAndFeel">
            <summary>
            Specifies the boundary system parameters that can be configured. Can be overridden by the system or user.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetConfigured">
            <summary>
            Returns true if the boundary system is currently configured with valid boundary data.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestNode(OVRBoundary.Node,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a tracked node against the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.TestPoint(UnityEngine.Vector3,OVRBoundary.BoundaryType)">
            <summary>
            Returns the results of testing a 3d point against the specified boundary type.
            The test point is expected in local tracking space.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.SetLookAndFeel(OVRBoundary.BoundaryLookAndFeel)">
            <summary>
            Requests that the visual look and feel of the boundary system be changed as specified. Can be overridden by the system or user.
            </summary>
        </member>
        <member name="M:OVRBoundary.ResetLookAndFeel">
            <summary>
            Resets the visual look and feel of the boundary system to the initial system settings.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetGeometry(OVRBoundary.BoundaryType)">
            <summary>
            Returns an array of 3d points (in clockwise order) that define the specified boundary type.
            All points are returned in local tracking space shared by tracked nodes and accessible through OVRCameraRig's trackingSpace anchor.
            </summary>
        </member>
        <member name="M:OVRBoundary.GetDimensions(OVRBoundary.BoundaryType)">
            <summary>
            Returns a vector that indicates the spatial dimensions of the specified boundary type. (x = width, y = height, z = depth)
            </summary>
        </member>
        <member name="M:OVRBoundary.GetVisible">
            <summary>
            Returns true if the boundary system is currently visible.
            </summary>
        </member>
        <member name="M:OVRBoundary.SetVisible(System.Boolean)">
            <summary>
            Requests that the boundary system visibility be set to the specified value.
            The actual visibility can be overridden by the system (i.e., proximity trigger) or by the user (boundary system disabled)
            </summary>
        </member>
        <member name="T:OVRCameraRig">
            <summary>
            A head-tracked stereoscopic virtual reality camera rig.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeCamera">
            <summary>
            The left eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeCamera">
            <summary>
            The right eye camera.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackingSpace">
            <summary>
            Provides a root transform for all anchors in tracking space.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftEyeAnchor">
            <summary>
            Always coincides with the pose of the left eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.centerEyeAnchor">
            <summary>
            Always coincides with average of the left and right eye poses.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightEyeAnchor">
            <summary>
            Always coincides with the pose of the right eye.
            </summary>
        </member>
        <member name="P:OVRCameraRig.leftHandAnchor">
            <summary>
            Always coincides with the pose of the left hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.rightHandAnchor">
            <summary>
            Always coincides with the pose of the right hand.
            </summary>
        </member>
        <member name="P:OVRCameraRig.trackerAnchor">
            <summary>
            Always coincides with the pose of the sensor.
            </summary>
        </member>
        <member name="E:OVRCameraRig.UpdatedAnchors">
            <summary>
            Occurs when the eye pose anchors have been set.
            </summary>
        </member>
        <member name="F:OVRCameraRig.usePerEyeCameras">
            <summary>
            If true, separate cameras will be used for the left and right eyes.
            </summary>
        </member>
        <member name="F:OVRCameraRig.useFixedUpdateForTracking">
            <summary>
            If true, all tracked anchors are updated in FixedUpdate instead of Update to favor physics fidelity.
            \note: If the fixed update rate doesn't match the rendering framerate (OVRManager.display.appFramerate), the anchors will visibly judder.
            </summary>
        </member>
        <member name="T:OVRExtensions">
            <summary>
            Miscellaneous extension methods that any script can use.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToTrackingSpacePose(UnityEngine.Transform,UnityEngine.Camera)">
            <summary>
            Converts the given world-space transform to an OVRPose in tracking space.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToWorldSpacePose(OVRPose)">
            <summary>
            Converts the given pose from tracking-space to world-space.
            </summary>
        </member>
        <member name="M:OVRExtensions.ToHeadSpacePose(UnityEngine.Transform,UnityEngine.Camera)">
            <summary>
            Converts the given world-space transform to an OVRPose in head space.
            </summary>
        </member>
        <member name="T:OVRPose">
            <summary>
            An affine transformation built from a Unity position and orientation.
            </summary>
        </member>
        <member name="P:OVRPose.identity">
            <summary>
            A pose with no translation or rotation.
            </summary>
        </member>
        <member name="F:OVRPose.position">
            <summary>
            The position.
            </summary>
        </member>
        <member name="F:OVRPose.orientation">
            <summary>
            The orientation.
            </summary>
        </member>
        <member name="M:OVRPose.op_Multiply(OVRPose,OVRPose)">
            <summary>
            Multiplies two poses.
            </summary>
        </member>
        <member name="M:OVRPose.Inverse">
            <summary>
            Computes the inverse of the given pose.
            </summary>
        </member>
        <member name="M:OVRPose.flipZ">
            <summary>
            Converts the pose from left- to right-handed or vice-versa.
            </summary>
        </member>
        <member name="T:OVRNativeBuffer">
            <summary>
            Encapsulates an 8-byte-aligned of unmanaged memory.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.#ctor(System.Int32)">
            <summary>
            Creates a buffer of the specified size.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the <see cref="T:OVRNativeBuffer"/> is
            reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Reset(System.Int32)">
            <summary>
            Reallocates the buffer with the specified new size.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.GetCapacity">
            <summary>
            The current number of bytes in the buffer.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.GetPointer(System.Int32)">
            <summary>
            A pointer to the unmanaged memory in the buffer, starting at the given offset in bytes.
            </summary>
        </member>
        <member name="M:OVRNativeBuffer.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:OVRNativeBuffer"/> object.
            </summary>
            <remarks>Call <see cref="M:OVRNativeBuffer.Dispose"/> when you are finished using the <see cref="T:OVRNativeBuffer"/>. The <see cref="M:OVRNativeBuffer.Dispose"/>
            method leaves the <see cref="T:OVRNativeBuffer"/> in an unusable state. After calling <see cref="M:OVRNativeBuffer.Dispose"/>, you must
            release all references to the <see cref="T:OVRNativeBuffer"/> so the garbage collector can reclaim the memory that
            the <see cref="T:OVRNativeBuffer"/> was occupying.</remarks>
        </member>
        <member name="T:OVRDebugHeadController">
            <summary>
            This is a simple behavior that can be attached to a parent of the CameraRig in order
            to provide movement via the gamepad. This is useful when testing an application in
            the Unity editor without the HMD.
            To use it, create a game object in your scene and drag your CameraRig to be a child
            of the game object. Then, add the OVRDebugHeadController behavior to the game object.
            Alternatively, this behavior can be placed directly on the OVRCameraRig object, but
            that is not guaranteed to work if OVRCameraRig functionality changes in the future.
            In the parent case, the object with OVRDebugHeadController can be thougt of as a 
            platform that your camera is attached to. When the platform moves or rotates, the 
            camera moves or rotates, but the camera can still move independently while "on" the
            platform.
            In general, this behavior should be disabled when not debugging.
            </summary>
        </member>
        <member name="T:OVRDisplay">
            <summary>
            Manages an Oculus Rift head-mounted display (HMD).
            </summary>
        </member>
        <member name="T:OVRDisplay.EyeRenderDesc">
            <summary>
            Specifies the size and field-of-view for one eye texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.resolution">
            <summary>
            The horizontal and vertical size of the texture.
            </summary>
        </member>
        <member name="F:OVRDisplay.EyeRenderDesc.fov">
            <summary>
            The angle of the horizontal and vertical field of view in degrees.
            </summary>
        </member>
        <member name="T:OVRDisplay.LatencyData">
            <summary>
            Contains latency measurements for a single frame of rendering.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.render">
            <summary>
            The time it took to render both eyes in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.timeWarp">
            <summary>
            The time it took to perform TimeWarp in seconds.
            </summary>
        </member>
        <member name="F:OVRDisplay.LatencyData.postPresent">
            <summary>
            The time between the end of TimeWarp and scan-out in seconds.
            </summary>
        </member>
        <member name="M:OVRDisplay.#ctor">
            <summary>
            Creates an instance of OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="M:OVRDisplay.Update">
            <summary>
            Updates the internal state of the OVRDisplay. Called by OVRManager.
            </summary>
        </member>
        <member name="E:OVRDisplay.RecenteredPose">
            <summary>
            Occurs when the head pose is reset.
            </summary>
        </member>
        <member name="M:OVRDisplay.RecenterPose">
            <summary>
            Recenters the head pose.
            </summary>
        </member>
        <member name="P:OVRDisplay.acceleration">
            <summary>
            Gets the current linear acceleration of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularAcceleration">
            <summary>
            Gets the current angular acceleration of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.velocity">
            <summary>
            Gets the current linear velocity of the head.
            </summary>
        </member>
        <member name="P:OVRDisplay.angularVelocity">
            <summary>
            Gets the current angular velocity of the head.
            </summary>
        </member>
        <member name="M:OVRDisplay.GetEyeRenderDesc(UnityEngine.XR.XRNode)">
            <summary>
            Gets the resolution and field of view for the given eye.
            </summary>
        </member>
        <member name="P:OVRDisplay.latency">
            <summary>
            Gets the current measured latency values.
            </summary>
        </member>
        <member name="P:OVRDisplay.appFramerate">
            <summary>
            Gets application's frame rate reported by oculus plugin
            </summary>
        </member>
        <member name="P:OVRDisplay.recommendedMSAALevel">
            <summary>
            Gets the recommended MSAA level for optimal quality/performance the current device.
            </summary>
        </member>
        <member name="P:OVRDisplay.displayFrequenciesAvailable">
            <summary>
            Gets the list of available display frequencies supported by this hardware.
            </summary>
        </member>
        <member name="P:OVRDisplay.displayFrequency">
            <summary>
            Gets and sets the current display frequency.
            </summary>
        </member>
        <member name="T:OVRHaptics">
            <summary>
            Plays tactile effects on a tracked VR controller.
            </summary>
        </member>
        <member name="T:OVRHaptics.Config">
            <summary>
            Determines the target format for haptics data on a specific device.
            </summary>
        </member>
        <member name="T:OVRHaptics.OVRHapticsChannel">
            <summary>
            A track of haptics data that can be mixed or sequenced with another track.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.#ctor(System.UInt32)">
            <summary>
            Constructs a channel targeting the specified output.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Preempt(OVRHapticsClip)">
            <summary>
            Cancels any currently-playing clips and immediatly plays the specified clip instead.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clips finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Mix(OVRHapticsClip)">
            <summary>
            Adds the specified clip to play simultaneously to the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsChannel.Clear">
            <summary>
            Cancels any currently-playing clips.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Preempt(OVRHapticsClip)">
            <summary>
            Immediately plays the specified clip without waiting for any currently-playing clip to finish.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Queue(OVRHapticsClip)">
            <summary>
            Enqueues the specified clip to play after any currently-playing clip finishes.
            </summary>
        </member>
        <member name="M:OVRHaptics.OVRHapticsOutput.Mix(OVRHapticsClip)">
            <summary>
            Adds the samples from the specified clip to the ones in the currently-playing clip(s).
            </summary>
        </member>
        <member name="M:OVRHaptics.Process">
            <summary>
            The system calls this each frame to update haptics playback.
            </summary>
        </member>
        <member name="T:OVRHapticsClip">
            <summary>
            A PCM buffer of data for a haptics effect.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Count">
            <summary>
            The current number of samples in the clip.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Capacity">
            <summary>
            The maximum number of samples the clip can store.
            </summary>
        </member>
        <member name="P:OVRHapticsClip.Samples">
            <summary>
            The raw haptics data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Int32)">
            <summary>
            Creates a clip with the specified capacity.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a clip with the specified data.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(OVRHapticsClip,OVRHapticsClip)">
            <summary>
            Creates a clip by mixing the specified clips.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.#ctor(UnityEngine.AudioClip,System.Int32)">
            <summary>
            Creates a haptics clip from the specified audio clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.WriteSample(System.Byte)">
            <summary>
            Adds the specified sample to the end of the clip.
            </summary>
        </member>
        <member name="M:OVRHapticsClip.Reset">
            <summary>
            Clears the clip and resets its size to 0.
            </summary>
        </member>
        <member name="T:OVRInput">
            <summary>
            Provides a unified input system for Oculus controllers and gamepads.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Up" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Down" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Left" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Right" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Button.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Start" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Back" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RShoulder" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RThumbstickRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadUp" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadDown" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadLeft" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.DpadRight" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawButton.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.One" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Two" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Three" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Four" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Touch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.A" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.B" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.X" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Y" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RThumbRest" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.PrimaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.SecondaryThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.NearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.LThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.RThumbButtons" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawNearTouch.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.PrimaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.SecondaryHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.LHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RIndexTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.RHandTrigger" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis1D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.PrimaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.PrimaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.SecondaryThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.SecondaryTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Axis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.LThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.LTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.RThumbstick" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.RTouchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.RawAxis2D.Any" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.LTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.RTouch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touch" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Remote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Gamepad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Touchpad" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.LTrackedRemote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.RTrackedRemote" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.Active" -->
        <!-- Badly formed XML comment ignored for member "F:OVRInput.Controller.All" -->
        <member name="M:OVRInput.#cctor">
            <summary>
            Creates an instance of OVRInput.
            </summary>
        </member>
        <member name="M:OVRInput.Update">
            <summary>
            Updates the internal state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.FixedUpdate">
            <summary>
            Updates the internal physics state of OVRInput. Must be called manually if used independently from OVRManager.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerOrientationTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's orientation is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerPositionTracked(OVRInput.Controller)">
            <summary>
            Returns true if the given Controller's position is currently tracked.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return false.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerPosition(OVRInput.Controller)">
            <summary>
            Gets the position of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerVelocity(OVRInput.Controller)">
            <summary>
            Gets the linear velocity of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAcceleration(OVRInput.Controller)">
            <summary>
            Gets the linear acceleration of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Vector3.zero.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerRotation(OVRInput.Controller)">
            <summary>
            Gets the rotation of the given Controller local to its tracking space.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller)">
            <summary>
            Gets the angular velocity of the given Controller local to its tracking space in radians per second around each axis.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.GetLocalControllerAngularAcceleration(OVRInput.Controller)">
            <summary>
            Gets the angular acceleration of the given Controller local to its tracking space in radians per second per second around each axis.
            Only supported for Oculus LTouch and RTouch controllers. Non-tracked controllers will return Quaternion.identity.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual button mask with the given controller mask.
            Returns true if any masked button is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw button mask with the given controller mask.
            Returns true if any masked button is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw button mask with the given controller mask.
            Returns true if any masked button was pressed this frame on any masked controller and no masked button was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Button,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawButton,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw button mask with the given controller mask.
            Returns true if any masked button was released this frame on any masked controller and no other masked button is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was pressed this frame on any masked controller and no masked touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.Touch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw touch mask with the given controller mask.
            Returns true if any masked touch was released this frame on any masked controller and no other masked touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controller.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch is down on any masked controllers.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetDown(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current down state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was pressed this frame on any masked controller and no masked near touch was previously down last frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.NearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given virtual near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.GetUp(OVRInput.RawNearTouch,OVRInput.Controller)">
            <summary>
            Gets the current up state of the given raw near touch mask with the given controller mask.
            Returns true if any masked near touch was released this frame on any masked controller and no other masked near touch is still down this frame.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis1D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 1-dimensional axis mask on the given controller mask.
            Returns the value of the largest masked axis across all masked controllers. Values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.Axis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given virtual 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.Get(OVRInput.RawAxis2D,OVRInput.Controller)">
            <summary>
            Gets the current state of the given raw 2-dimensional axis mask on the given controller mask.
            Returns the vector of the largest masked axis across all masked controllers. Values range from -1 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.GetConnectedControllers">
            <summary>
            Returns a mask of all currently connected controller types.
            </summary>
        </member>
        <member name="M:OVRInput.IsControllerConnected(OVRInput.Controller)">
            <summary>
            Returns true if the specified controller type is currently connected.
            </summary>
        </member>
        <member name="M:OVRInput.GetActiveController">
            <summary>
            Returns the current active controller type.
            </summary>
        </member>
        <member name="M:OVRInput.SetControllerVibration(System.Single,System.Single,OVRInput.Controller)">
            <summary>
            Activates vibration with the given frequency and amplitude with the given controller mask.
            Ignored on controllers that do not support vibration. Expected values range from 0 to 1.
            </summary>
        </member>
        <member name="M:OVRInput.RecenterController(OVRInput.Controller)">
            <summary>
            Triggers a recenter to realign the specified controller's virtual pose with the user's real-world pose.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Ignored for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerWasRecentered(OVRInput.Controller)">
            <summary>
            Returns true if the specified controller was recentered this frame.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Returns false for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerRecenterCount(OVRInput.Controller)">
            <summary>
            Returns the number of times the controller has been recentered this session.
            Useful for detecting recenter events and resetting state such as arm model simulations, etc.
            Wraps around to 0 after 255.
            Only applicable to controllers that require recentering, such as the GearVR Controller.
            Returns 0 for controllers that do not require recentering.
            </summary>
        </member>
        <member name="M:OVRInput.GetControllerBatteryPercentRemaining(OVRInput.Controller)">
            <summary>
            Returns the battery percentage remaining for the specified controller. Values range from 0 to 100.
            Only applicable to controllers that report battery level, such as the GearVR Controller.
            Returns 0 for controllers that do not report battery level.
            </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.AxisGPC">
            <summary> An axis on the gamepad. </summary>
        </member>
        <member name="T:OVRInput.OVRControllerGamepadMac.ButtonGPC">
            <summary> A button on the gamepad. </summary>
        </member>
        <member name="T:OVRLayerAttribute">
            <summary>
            Dummy subtype of PropertyAttribute for custom inspector to use.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVRLint" -->
        <member name="F:OVRLint.mRecords">
            Use of ONSP reflections (Gear)
            Use of LoadLevelAsync / LoadLevelAdditiveAsync (on Gear, this kills frame rate so dramatically it's probably better to just go to black and load synchronously)
            Use of Linq in non-editor assemblies (common cause of GCs).  Minor: use of foreach.
            Use of Unity WWW (exceptionally high overhead for large file downloads, but acceptable for tiny gets).
            Declared but empty Awake/Start/Update/OnCollisionEnter/OnCollisionExit/OnCollisionStay.  Also OnCollision* star methods that declare the Collision  argument but do not reference it (omitting it short-circuits the collision contact calculation).
        </member>
        <member name="T:OVRManager">
            <summary>
            Configuration data for Oculus virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.instance">
            <summary>
            Gets the singleton instance.
            </summary>
        </member>
        <member name="P:OVRManager.display">
            <summary>
            Gets a reference to the active display.
            </summary>
        </member>
        <member name="P:OVRManager.tracker">
            <summary>
            Gets a reference to the active sensor.
            </summary>
        </member>
        <member name="P:OVRManager.boundary">
            <summary>
            Gets a reference to the active boundary system.
            </summary>
        </member>
        <member name="P:OVRManager.profile">
            <summary>
            Gets the current profile, which contains information about the user's settings and body dimensions.
            </summary>
        </member>
        <member name="E:OVRManager.HMDAcquired">
            <summary>
            Occurs when an HMD attached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDLost">
            <summary>
            Occurs when an HMD detached.
            </summary>
        </member>
        <member name="E:OVRManager.HMDMounted">
            <summary>
            Occurs when an HMD is put on the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.HMDUnmounted">
            <summary>
            Occurs when an HMD is taken off the user's head.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusAcquired">
            <summary>
            Occurs when VR Focus is acquired.
            </summary>
        </member>
        <member name="E:OVRManager.VrFocusLost">
            <summary>
            Occurs when VR Focus is lost.
            </summary>
        </member>
        <member name="E:OVRManager.InputFocusAcquired">
            <summary>
            Occurs when Input Focus is acquired.
            </summary>
        </member>
        <member name="E:OVRManager.InputFocusLost">
            <summary>
            Occurs when Input Focus is lost.
            </summary>
        </member>
        <member name="E:OVRManager.AudioOutChanged">
            <summary>
            Occurs when the active Audio Out device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.AudioInChanged">
            <summary>
            Occurs when the active Audio In device has changed and a restart is needed.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingAcquired">
            <summary>
            Occurs when the sensor gained tracking.
            </summary>
        </member>
        <member name="E:OVRManager.TrackingLost">
            <summary>
            Occurs when the sensor lost tracking.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "E:OVRManager.HSWDismissed" -->
        <member name="P:OVRManager.isHmdPresent">
            <summary>
            If true, a head-mounted display is connected and present.
            </summary>
        </member>
        <member name="P:OVRManager.audioOutId">
            <summary>
            Gets the audio output device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.audioInId">
            <summary>
            Gets the audio input device identifier.
            </summary>
            <description>
            On Windows, this is a string containing the GUID of the IMMDevice for the Windows audio endpoint to use.
            </description>
        </member>
        <member name="P:OVRManager.hasVrFocus">
            <summary>
            If true, the app has VR Focus.
            </summary>
        </member>
        <member name="P:OVRManager.hasInputFocus">
            <summary>
            If true, the app has Input Focus.
            </summary>
        </member>
        <member name="P:OVRManager.chromatic">
            <summary>
            If true, chromatic de-aberration will be applied, improving the image at the cost of texture bandwidth.
            </summary>
        </member>
        <member name="P:OVRManager.monoscopic">
            <summary>
            If true, both eyes will see the same image, rendered from the center eye pose, saving performance.
            </summary>
        </member>
        <member name="F:OVRManager.useRecommendedMSAALevel">
            <summary>
            If true, Unity will use the optimal antialiasing level for quality/performance on the current hardware.
            </summary>
        </member>
        <member name="F:OVRManager.enableAdaptiveResolution">
            <summary>
            If true, dynamic resolution will be enabled
            </summary>
        </member>
        <member name="M:OVRManager.IsAdaptiveResSupportedByEngine">
            <summary>
            Adaptive Resolution is based on Unity engine's renderViewportScale/eyeTextureResolutionScale feature 
            But renderViewportScale was broken in an array of Unity engines, this function help to filter out those broken engines
            </summary>
        </member>
        <member name="F:OVRManager.minRenderScale">
            <summary>
            Min RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = true );
            </summary>
        </member>
        <member name="F:OVRManager.maxRenderScale">
            <summary>
            Max RenderScale the app can reach under adaptive resolution mode ( enableAdaptiveResolution = true );
            </summary>
        </member>
        <member name="F:OVRManager.expandMixedRealityCapturePropertySheet">
            <summary>
            If true, the MixedRealityCapture properties will be displayed
            </summary>
        </member>
        <member name="F:OVRManager.enableMixedReality">
            <summary>
            If true, Mixed Reality mode will be enabled
            </summary>
        </member>
        <member name="F:OVRManager.compositionMethod">
            <summary>
            Composition method
            </summary>
        </member>
        <member name="F:OVRManager.extraHiddenLayers">
            <summary>
            Extra hidden layers
            </summary>
        </member>
        <member name="T:OVRManager.CameraDevice">
            <summary>
            If true, Mixed Reality mode will use direct composition from the first web camera
            </summary>
        </member>
        <member name="F:OVRManager.capturingCameraDevice">
            <summary>
            The camera device for direct composition
            </summary>
        </member>
        <member name="F:OVRManager.flipCameraFrameHorizontally">
            <summary>
            Flip the camera frame horizontally
            </summary>
        </member>
        <member name="F:OVRManager.flipCameraFrameVertically">
            <summary>
            Flip the camera frame vertically
            </summary>
        </member>
        <member name="F:OVRManager.handPoseStateLatency">
            <summary>
            Delay the touch controller pose by a short duration (0 to 0.5 second) to match the physical camera latency
            </summary>
        </member>
        <member name="F:OVRManager.sandwichCompositionRenderLatency">
            <summary>
            Delay the foreground / background image in the sandwich composition to match the physical camera latency. The maximum duration is sandwichCompositionBufferedFrames / {Game FPS}
            </summary>
        </member>
        <member name="F:OVRManager.sandwichCompositionBufferedFrames">
            <summary>
            The number of frames are buffered in the SandWich composition. The more buffered frames, the more memory it would consume.
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeyColor">
            <summary>
            Chroma Key Color
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySimilarity">
            <summary>
            Chroma Key Similarity
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySmoothRange">
            <summary>
            Chroma Key Smooth Range
            </summary>
        </member>
        <member name="F:OVRManager.chromaKeySpillRange">
            <summary>
             Chroma Key Spill Range
            </summary>
        </member>
        <member name="F:OVRManager.useDynamicLighting">
            <summary>
            Use dynamic lighting (Depth sensor required)
            </summary>
        </member>
        <member name="F:OVRManager.depthQuality">
            <summary>
            The quality level of depth image. The lighting could be more smooth and accurate with high quality depth, but it would also be more costly in performance.
            </summary>
        </member>
        <member name="F:OVRManager.dynamicLightingSmoothFactor">
            <summary>
            Smooth factor in dynamic lighting. Larger is smoother
            </summary>
        </member>
        <member name="F:OVRManager.dynamicLightingDepthVariationClampingValue">
            <summary>
            The maximum depth variation across the edges. Make it smaller to smooth the lighting on the edges.
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenType">
            <summary>
            Set the current type of the virtual green screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenTopY">
            <summary>
            Top Y of virtual screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenBottomY">
            <summary>
            Bottom Y of virtual screen
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenApplyDepthCulling">
            <summary>
            When using a depth camera (e.g. ZED), whether to use the depth in virtual green screen culling.
            </summary>
        </member>
        <member name="F:OVRManager.virtualGreenScreenDepthTolerance">
            <summary>
            The tolerance value (in meter) when using the virtual green screen with a depth camera. Make it bigger if the foreground objects got culled incorrectly.
            </summary>
        </member>
        <member name="P:OVRManager.vsyncCount">
            <summary>
            The number of expected display frames per rendered frame.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryLevel" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryTemperature" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.batteryStatus" -->
        <!-- Badly formed XML comment ignored for member "P:OVRManager.volumeLevel" -->
        <member name="P:OVRManager.cpuLevel">
            <summary>
            Gets or sets the current CPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.gpuLevel">
            <summary>
            Gets or sets the current GPU performance level (0-2). Lower performance levels save more power.
            </summary>
        </member>
        <member name="P:OVRManager.isPowerSavingActive">
            <summary>
            If true, the CPU and GPU are currently throttled to save power and/or reduce the temperature.
            </summary>
        </member>
        <member name="P:OVRManager.eyeTextureFormat">
            <summary>
            Gets or sets the eye texture format.
            </summary>
        </member>
        <member name="P:OVRManager.tiledMultiResSupported">
            <summary>
            Gets if tiled-based multi-resolution technique is supported
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.tiledMultiResLevel">
            <summary>
            Gets or sets the tiled-based multi-resolution level
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.gpuUtilSupported">
            <summary>
            Gets if the GPU Utility is supported
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.gpuUtilLevel">
            <summary>
            Gets the GPU Utilised Level (0.0 - 1.0)
            This feature is only supported on QCOMM-based Android devices
            </summary>
        </member>
        <member name="P:OVRManager.trackingOriginType">
            <summary>
            Defines the current tracking origin type.
            </summary>
        </member>
        <member name="F:OVRManager.usePositionTracking">
            <summary>
            If true, head tracking will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.useRotationTracking">
            <summary>
            If true, head tracking will affect the rotation of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.useIPDInPositionTracking">
            <summary>
            If true, the distance between the user's eyes will affect the position of each OVRCameraRig's cameras.
            </summary>
        </member>
        <member name="F:OVRManager.resetTrackerOnLoad">
            <summary>
            If true, each scene load will cause the head pose to reset.
            </summary>
        </member>
        <member name="F:OVRManager.AllowRecenter">
            <summary>
            If true, the Reset View in the universal menu will cause the pose to be reset. This should generally be 
            enabled for applications with a stationary position in the virtual world and will allow the View Reset 
            command to place the person back to a predefined location (such as a cockpit seat). 
            Set this to false if you have a locomotion system because resetting the view would effectively teleport 
            the player to potentially invalid locations.
            </summary>
        </member>
        <member name="P:OVRManager.isSupportedPlatform">
            <summary>
            True if the current platform supports virtual reality.
            </summary>
        </member>
        <member name="P:OVRManager.isUserPresent">
            <summary>
            True if the user is currently wearing the display.
            </summary>
        </member>
        <member name="M:OVRManager.ReturnToLauncher">
            <summary>
            Leaves the application/game and returns to the launcher/dashboard
            </summary>
        </member>
        <member name="T:OVRMixedReality">
            <summary>
            Manages mix-reality elements
            </summary>
        </member>
        <member name="F:OVRMixedReality.chromaKeyColor">
            <summary>
            Configurable parameters
            </summary>
        </member>
        <member name="F:OVRMixedReality.useFakeExternalCamera">
            <summary>
            For Debugging purpose, we can use preset parameters to fake a camera when external camera is not available
            </summary>
        </member>
        <member name="F:OVRMixedReality.currentComposition">
            <summary>
            Composition object
            </summary>
        </member>
        <member name="M:OVRMixedReality.Update(UnityEngine.GameObject,UnityEngine.Camera,OVRManager.CompositionMethod,System.Boolean,OVRManager.CameraDevice,OVRManager.DepthQuality)">
            <summary>
            Updates the internal state of the Mixed Reality Camera. Called by OVRManager.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:OVROverlay" -->
        <member name="T:OVROverlay.OverlayShape">
            <summary>
            Determines the on-screen appearance of a layer.
            </summary>
        </member>
        <member name="T:OVROverlay.OverlayType">
            <summary>
            Whether the layer appears behind or infront of other content in the scene.
            </summary>
        </member>
        <member name="F:OVROverlay.currentOverlayType">
            <summary>
            Specify overlay's type
            </summary>
        </member>
        <member name="F:OVROverlay.isDynamic">
            <summary>
            If true, the texture's content is copied to the compositor each frame.
            </summary>
        </member>
        <member name="F:OVROverlay.isProtectedContent">
            <summary>
            If true, the layer would be used to present protected content (e.g. HDCP). The flag is effective only on PC.
            </summary>
        </member>
        <member name="F:OVROverlay.currentOverlayShape">
            <summary>
            Specify overlay's shape
            </summary>
        </member>
        <member name="F:OVROverlay.textures">
            <summary>
            The left- and right-eye Textures to show in the layer.
            \note If you need to change the texture on a per-frame basis, please use OverrideOverlayTextureInfo(..) to avoid caching issues.
            </summary>
        </member>
        <member name="M:OVROverlay.OverrideOverlayTextureInfo(UnityEngine.Texture,System.IntPtr,UnityEngine.XR.XRNode)">
            <summary>
            Use this function to set texture and texNativePtr when app is running 
            GetNativeTexturePtr is a slow behavior, the value should be pre-cached 
            </summary>
        </member>
        <member name="T:OVRPlatformMenu">
            <summary>
            Shows the Oculus plaform UI.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.inputCode">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="F:OVRPlatformMenu.OnShortPress">
            <summary>
            Callback to handle short press. Returns true if ConfirmQuit menu should be shown.
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Awake">
            <summary>
            Instantiate the cursor timer
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.ShowConfirmQuitMenu">
            <summary>
            Show the confirm quit menu
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.RetreatOneLevel">
            <summary>
            Sample handler for short press which retreats to the previous scene that used OVRPlatformMenu.
            </summary>
        </member>
        <member name="M:OVRPlatformMenu.Update">
            <summary>
            Tests for long-press and activates global platform menu when detected.
            as per the Unity integration doc, the back button responds to "mouse 1" button down/up/etc
            </summary>
        </member>
        <member name="F:OVRPlugin.Result.Success">
            Success
        </member>
        <member name="F:OVRPlugin.Result.Failure">
            Failure
        </member>
        <member name="T:OVRProfile">
            <summary>
            (Deprecated) Contains information about the user's preferences and body dimensions.
            </summary>
        </member>
        <member name="T:OVRTracker">
            <summary>
            An infrared camera that tracks the position of a head-mounted display.
            </summary>
        </member>
        <member name="T:OVRTracker.Frustum">
            <summary>
            The (symmetric) visible area in front of the sensor.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.nearZ">
            <summary>
            The sensor's minimum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.farZ">
            <summary>
            The sensor's maximum supported distance to the HMD.
            </summary>
        </member>
        <member name="F:OVRTracker.Frustum.fov">
            <summary>
            The sensor's horizontal and vertical fields of view in degrees.
            </summary>
        </member>
        <member name="P:OVRTracker.isPresent">
            <summary>
            If true, a sensor is attached to the system.
            </summary>
        </member>
        <member name="P:OVRTracker.isPositionTracked">
            <summary>
            If true, the sensor is actively tracking the HMD's position. Otherwise the HMD may be temporarily occluded, the system may not support position tracking, etc.
            </summary>
        </member>
        <member name="P:OVRTracker.isEnabled">
            <summary>
            If this is true and a sensor is available, the system will use position tracking when isPositionTracked is also true.
            </summary>
        </member>
        <member name="P:OVRTracker.count">
            <summary>
            Returns the number of sensors currently connected to the system.
            </summary>
        </member>
        <member name="M:OVRTracker.GetFrustum(System.Int32)">
            <summary>
            Gets the sensor's viewing frustum.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPose(System.Int32)">
            <summary>
            Gets the sensor's pose, relative to the head's pose at the time of the last pose recentering.
            </summary>
        </member>
        <member name="M:OVRTracker.GetPoseValid(System.Int32)">
            <summary>
            If true, the pose of the sensor is valid and is ready to be queried.
            </summary>
        </member>
        <member name="T:OVRChromaticAberration">
            <summary>
            Allows you to toggle chromatic aberration correction with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRChromaticAberration.toggleButton">
            <summary>
            The button that will toggle chromatic aberration correction.
            </summary>
        </member>
        <member name="T:OVRCubemapCapture">
            <summary>
            Helper script for capture cubemap and save it into PNG or JPG file
            </summary>
            <description>
            How it works:
            1) This script can be attached to a existing game object, you can also use prefab Assets\OVR\Prefabs\OVRCubemapCaptureProbe
            There are 2 ways to trigger a capture if you attached this script to a game object.  
            	* Automatic capturing: if [autoTriggerAfterLaunch] is true, a automatic capturing will be triggered after [autoTriggerDelay] seconds.
            	* Keyboard trigger: press key [triggeredByKey], a capturing will be triggered.
            2) If you like to trigger the screen capture in your code logic, just call static function [OVRCubemapCapture.TriggerCubemapCapture] with proper input arguments. 
            </description>
        </member>
        <member name="F:OVRCubemapCapture.autoTriggerAfterLaunch">
            <summary>
            Enable the automatic screenshot trigger, which will capture a cubemap after autoTriggerDelay (seconds)
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.triggeredByKey">
            <summary>
            Trigger cubemap screenshot if user pressed key triggeredByKey
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.pathName">
            <summary>
            The complete file path for saving the cubemap screenshot, including the filename and extension
            if pathName is blank, screenshots will be saved into %USERPROFILE%\Documents\OVR_ScreenShot360
            </summary>
        </member>
        <member name="F:OVRCubemapCapture.cubemapSize">
            <summary>
            The cube face resolution
            </summary>
        </member>
        <member name="M:OVRCubemapCapture.TriggerCubemapCapture(UnityEngine.Vector3,System.Int32,System.String)">
            <summary>
            Generate unity cubemap at specific location and save into JPG/PNG
            </summary>
            <description>
            Default save folder: your app's persistentDataPath 
            Default file name: using current time OVR_hh_mm_ss.png 
            Note1: this will take a few seconds to finish
            Note2: if you only want to specify path not filename, please end [pathName] with "/" 
            </description>
        </member>
        <member name="M:OVRCubemapCapture.SaveCubemapCapture(UnityEngine.Cubemap,System.String)">
            <summary>
            Save unity cubemap into NPOT 6x1 cubemap/texture atlas in the following format PX NX PY NY PZ NZ
            </summary>
            <description>
            Supported format: PNG/JPG
            Default file name: using current time OVR_hh_mm_ss.png 
            </description>
        </member>
        <member name="T:OVRDebugInfo">
            <summary>
            Shows debug information on a heads-up display.
            </summary>
        </member>
        <member name="F:OVRDebugInfo.updateInterval">
            <summary>
            Variables for FPS
            </summary>
        </member>
        <member name="F:OVRDebugInfo.initUIComponent">
            <summary>
            Managing for UI initialization
            </summary>
        </member>
        <member name="F:OVRDebugInfo.offsetY">
            <summary>
            UIs Y offset
            </summary>
        </member>
        <member name="F:OVRDebugInfo.riftPresentTimeout">
            <summary>
            Managing for rift detection UI
            </summary>
        </member>
        <member name="F:OVRDebugInfo.showVRVars">
            <summary>
            Turn on / off VR variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Awake">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:OVRDebugInfo.Update">
            <summary>
            Updating VR variables and managing UI present
            </summary>
        </member>
        <member name="M:OVRDebugInfo.OnDestroy">
            <summary>
            Initialize isInited value on OnDestroy
            </summary>
        </member>
        <member name="M:OVRDebugInfo.InitUIComponents">
            <summary>
            Initialize UI GameObjects
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateVariable">
            <summary>
            Update VR Variables
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateStrings">
            <summary>
            Update Strings
            </summary>
        </member>
        <member name="M:OVRDebugInfo.RiftPresentGUI(UnityEngine.GameObject)">
            <summary>
            It's for rift present GUI
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateDeviceDetection">
            <summary>
            Updates the device detection.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.VariableObjectManager(UnityEngine.GameObject,System.String,System.Single,System.String,System.Int32)">
            <summary>
            Object Manager for Variables
            </summary>
            <returns> gameobject for each Variable </returns>
        </member>
        <member name="M:OVRDebugInfo.ComponentComposition(UnityEngine.GameObject)">
            <summary>
            Component composition
            </summary>
            <returns> Composed gameobject. </returns>
        </member>
        <member name="M:OVRDebugInfo.UpdateIPD">
            <summary>
            Updates the IPD.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeHeightOffset">
            <summary>
            Updates the eye height offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateEyeDepthOffset">
            <summary>
            Updates the eye depth offset.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFOV">
            <summary>
            Updates the FOV.
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateResolutionEyeTexture">
            <summary>
            Updates resolution of eye texture
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateLatencyValues">
            <summary>
            Updates latency values
            </summary>
        </member>
        <member name="M:OVRDebugInfo.UpdateFPS">
            <summary>
            Updates the FPS.
            </summary>
        </member>
        <member name="T:OVRGazePointer">
            <summary>
            UI pointer driven by gaze input.
            </summary>
        </member>
        <member name="F:OVRGazePointer.rayTransform">
            <summary>
            The gaze ray.
            </summary>
        </member>
        <member name="P:OVRGazePointer.hidden">
            <summary>
            Is gaze pointer current visible
            </summary>
        </member>
        <member name="P:OVRGazePointer.currentScale">
            <summary>
            Current scale applied to pointer
            </summary>
        </member>
        <member name="F:OVRGazePointer.depth">
            <summary>
            Current depth of pointer from camera
            </summary>
        </member>
        <member name="F:OVRGazePointer.positionSetsThisFrame">
            <summary>
            How many times position has been set this frame. Used to detect when there are no position sets in a frame.
            </summary>
        </member>
        <member name="F:OVRGazePointer.lastPosition">
            <summary>
            Position last frame.
            </summary>
        </member>
        <member name="F:OVRGazePointer.lastShowRequestTime">
            <summary>
            Last time code requested the pointer be shown. Usually when pointer passes over interactive elements.
            </summary>
        </member>
        <member name="F:OVRGazePointer.lastHideRequestTime">
            <summary>
            Last time pointer was requested to be hidden. Usually mouse pointer activity.
            </summary>
        </member>
        <member name="P:OVRGazePointer.visibilityStrength">
            <summary>
            Used to determine alpha level of gaze cursor. Could also be used to determine cursor size, for example, as the cursor fades out.
            </summary>
        </member>
        <member name="M:OVRGazePointer.SetPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Set position and orientation of pointer
            </summary>
            <param name="pos"></param>
            <param name="normal"></param>
        </member>
        <member name="M:OVRGazePointer.SetPosition(UnityEngine.Vector3)">
            <summary>
            SetPosition overload without normal. Just makes cursor face user
            </summary>
            <param name="pos"></param>
        </member>
        <member name="M:OVRGazePointer.RequestHide">
            <summary>
            Request the pointer be hidden
            </summary>
        </member>
        <member name="M:OVRGazePointer.RequestShow">
            <summary>
            Request the pointer be shown. Hide requests take priority
            </summary>
        </member>
        <member name="T:OVRGrabbable">
            <summary>
            An object that can be grabbed and thrown by OVRGrabber.
            </summary>
        </member>
        <member name="P:OVRGrabbable.allowOffhandGrab">
            <summary>
            If true, the object can currently be grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.isGrabbed">
            <summary>
            If true, the object is currently grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapPosition">
            <summary>
            If true, the object's position will snap to match snapOffset when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapOrientation">
            <summary>
            If true, the object's orientation will snap to match snapOffset when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.snapOffset">
            <summary>
            An offset relative to the OVRGrabber where this object can snap when grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedBy">
            <summary>
            Returns the OVRGrabber currently grabbing this object.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedTransform">
            <summary>
            The transform at which this object was grabbed.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabbedRigidbody">
            <summary>
            The Rigidbody of the collider that was used to grab this object.
            </summary>
        </member>
        <member name="P:OVRGrabbable.grabPoints">
            <summary>
            The contact point(s) where the object was grabbed.
            </summary>
        </member>
        <member name="M:OVRGrabbable.GrabBegin(OVRGrabber,UnityEngine.Collider)">
            <summary>
            Notifies the object that it has been grabbed.
            </summary>
        </member>
        <member name="M:OVRGrabbable.GrabEnd(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Notifies the object that it has been released.
            </summary>
        </member>
        <member name="T:OVRGrabber">
            <summary>
            Allows grabbing and throwing of objects with the OVRGrabbable component on them.
            </summary>
        </member>
        <member name="P:OVRGrabber.grabbedObject">
            <summary>
            The currently grabbed object.
            </summary>
        </member>
        <member name="T:OVRGridCube">
            <summary>
            Diagnostic display with a regular grid of cubes for visual testing of
            tracking and distortion.
            </summary>
        </member>
        <member name="F:OVRGridCube.GridKey">
            <summary>
            The key that toggles the grid of cubes.
            </summary>
        </member>
        <member name="M:OVRGridCube.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRGridCube.SetOVRCameraController(OVRCameraRig@)">
            <summary>
            Sets the OVR camera controller.
            </summary>
            <param name="cameraController">Camera controller.</param>
        </member>
        <member name="M:OVRGridCube.CubeGridSwitchColor(System.Boolean)">
            <summary>
            Switch the Cube grid color.
            </summary>
            <param name="CubeSwitchColor">If set to <c>true</c> cube switch color.</param>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRInputModule">
            <summary>
            VR extension of PointerInputModule which supports gaze and controller pointing.
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_VerticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_SubmitButton">
            <summary>
            Name of the submit button.
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRInputModule.m_CancelButton">
            <summary>
            Name of the submit button.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRInputModule.horizontalAxis">
            <summary>
            Name of the horizontal axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRInputModule.verticalAxis">
            <summary>
            Name of the vertical axis for movement (if axis events are used).
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.SendSubmitEventToSelectedObject">
            <summary>
            Process submit keys.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.SendMoveEventToSelectedObject">
            <summary>
            Process keyboard events.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessMousePress(UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData)">
            <summary>
            Process the current mouse press.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessMouseEvent(UnityEngine.EventSystems.PointerInputModule.MouseState)">
            <summary>
            Process all mouse events. This is the same as the StandaloneInputModule version except that
            it takes MouseState as a parameter, allowing it to be used for both Gaze and Mouse 
            pointerss.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.Process">
            <summary>
            Process this InputModule. Same as the StandaloneInputModule version, except that it calls
            ProcessMouseEvent twice, once for gaze pointers, and once for mouse pointers.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.UseMouse(System.Boolean,System.Boolean,UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Decide if mouse events need to be processed this frame. Same as StandloneInputModule except
            that the IsPointerMoving method from this class is used, instead of the method on PointerEventData
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.CopyFromTo(UnityEngine.EventSystems.OVRPointerEventData,UnityEngine.EventSystems.OVRPointerEventData)">
            <summary>
            Convenience function for cloning PointerEventData
            </summary>
            <param name="from">Copy this value</param>
            <param name="to">to this object</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.CopyFromTo(UnityEngine.EventSystems.PointerEventData,UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Convenience function for cloning PointerEventData
            </summary>
            <param name="from">Copy this value</param>
            <param name="to">to this object</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ClearSelection">
            <summary>
            Clear pointer state for both types of pointer
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetRectTransformNormal(UnityEngine.RectTransform)">
            <summary>
            For RectTransform, calculate it's normal in world space
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetGazePointerData">
            <summary>
            State for a pointer controlled by a world space ray. E.g. gaze pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetCanvasPointerData">
            <summary>
            Get state for pointer which is a pointer moving in world space across the surface of a world space canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ShouldStartDrag(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            New version of ShouldStartDrag implemented first in PointerInputModule. This version differs in that
            for ray based pointers it makes a decision about whether a drag should start based on the angular change
            the pointer has made so far, as seen from the camera. This also works when the world space ray is 
            translated rather than rotated, since the beginning and end of the movement are considered as angle from
            the same point.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.IsPointerMoving(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            The purpose of this function is to allow us to switch between using the standard IsPointerMoving
            method for mouse driven pointers, but to always return true when it's a ray based pointer. 
            All real-world ray-based input devices are always moving so for simplicity we just return true
            for them. 
            
            If PointerEventData.IsPointerMoving was virtual we could just override that in
            OVRRayPointerEventData.
            </summary>
            <param name="pointerEvent"></param>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.ProcessDrag(UnityEngine.EventSystems.PointerEventData)">
            <summary>
            Exactly the same as the code from PointerInputModule, except that we call our own
            IsPointerMoving.
            
            This would also not be necessary if PointerEventData.IsPointerMoving was virtual
            </summary>
            <param name="pointerEvent"></param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetGazeButtonState">
            <summary>
            Get state of button corresponding to gaze pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRInputModule.GetExtraScrollDelta">
            <summary>
            Get extra scroll delta from gamepad
            </summary>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRPhysicsRaycaster">
            <summary>
            Simple event system using physics raycasts. Very closely based on UnityEngine.EventSystems.PhysicsRaycaster
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRPhysicsRaycaster.kNoEventMaskSet">
            <summary>
            Const to use for clarity when no event mask is set
            </summary>
        </member>
        <member name="F:UnityEngine.EventSystems.OVRPhysicsRaycaster.m_EventMask">
            <summary>
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.depth">
            <summary>
            Depth used to determine the order of event processing.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.finalEventMask">
            <summary>
            Event mask used to determine which objects will receive events.
            </summary>
        </member>
        <member name="P:UnityEngine.EventSystems.OVRPhysicsRaycaster.eventMask">
            <summary>
            Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
            </summary>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.Raycast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Perform a raycast using the worldSpaceRay in eventData.
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.Spherecast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult},System.Single)">
            <summary>
             Perform a Spherecast using the worldSpaceRay in eventData.
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
            <param name="radius">Radius of the sphere</param>
        </member>
        <member name="M:UnityEngine.EventSystems.OVRPhysicsRaycaster.GetScreenPos(UnityEngine.Vector3)">
            <summary>
            Get screen position of this world position as seen by the event camera of this OVRPhysicsRaycaster
            </summary>
            <param name="worldPosition"></param>
            <returns></returns>
        </member>
        <member name="T:UnityEngine.EventSystems.OVRPointerEventData">
            <summary>
            Extension of Unity's PointerEventData to support ray based pointing and also touchpad swiping
            </summary>
        </member>
        <member name="T:UnityEngine.EventSystems.PointerEventDataExtension">
            <summary>
            Static helpers for OVRPointerEventData.
            </summary>
        </member>
        <member name="T:OVRModeParms">
            <summary>
            Logs when the application enters power save mode and allows you to a low-power CPU/GPU level with a button press.
            </summary>
        </member>
        <member name="F:OVRModeParms.resetButton">
            <summary>
            The gamepad button that will switch the application to CPU level 0 and GPU level 1.
            </summary>
        </member>
        <member name="M:OVRModeParms.Start">
            <summary>
            Invoke power state mode test.
            </summary>
        </member>
        <member name="M:OVRModeParms.Update">
            <summary>
            Change default vr mode parms dynamically.
            </summary>
        </member>
        <member name="M:OVRModeParms.TestPowerStateMode">
            <summary>
            Check current power state mode.
            </summary>
        </member>
        <member name="T:OVRMonoscopic">
            <summary>
            Allows you to toggle monoscopic rendering with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRMonoscopic.toggleButton">
            <summary>
            The gamepad button that will toggle monoscopic rendering.
            </summary>
        </member>
        <member name="M:OVRMonoscopic.Update">
            <summary>
            Check input and toggle monoscopic rendering mode if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <member name="T:OVRPlayerController">
            <summary>
            Controls the player's movement in virtual reality.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Acceleration">
            <summary>
            The rate acceleration during movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Damping">
            <summary>
            The rate of damping on movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.BackAndSideDampen">
            <summary>
            The rate of additional damping when moving sideways or backwards.
            </summary>
        </member>
        <member name="F:OVRPlayerController.JumpForce">
            <summary>
            The force applied to the character when jumping.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationAmount">
            <summary>
            The rate of rotation when using a gamepad.
            </summary>
        </member>
        <member name="F:OVRPlayerController.RotationRatchet">
            <summary>
            The rate of rotation when using the keyboard.
            </summary>
        </member>
        <member name="F:OVRPlayerController.SnapRotation">
            <summary>
            The player will rotate in fixed steps if Snap Rotation is enabled.
            </summary>
        </member>
        <member name="F:OVRPlayerController.FixedSpeedSteps">
            <summary>
            How many fixed speeds to use with linear movement? 0=linear control
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdResetsY">
            <summary>
            If true, reset the initial yaw of the player controller when the Hmd pose is recentered.
            </summary>
        </member>
        <member name="F:OVRPlayerController.HmdRotatesY">
            <summary>
            If true, tracking data from a child OVRCameraRig will update the direction of movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.GravityModifier">
            <summary>
            Modifies the strength of gravity.
            </summary>
        </member>
        <member name="F:OVRPlayerController.useProfileData">
            <summary>
            If true, each OVRPlayerController will use the player's physical height.
            </summary>
        </member>
        <member name="F:OVRPlayerController.CameraHeight">
            <summary>
            The CameraHeight is the actual height of the HMD and can be used to adjust the height of the character controller, which will affect the
            ability of the character to move into areas with a low ceiling.
            </summary>
        </member>
        <member name="E:OVRPlayerController.TransformUpdated">
            <summary>
            This event is raised after the character controller is moved. This is used by the OVRAvatarLocomotion script to keep the avatar transform synchronized
            with the OVRPlayerController.
            </summary>
        </member>
        <member name="F:OVRPlayerController.Teleported">
            <summary>
            This bool is set to true whenever the player controller has been teleported. It is reset after every frame. Some systems, such as 
            CharacterCameraConstraint, test this boolean in order to disable logic that moves the character controller immediately 
            following the teleport.
            </summary>
        </member>
        <member name="E:OVRPlayerController.CameraUpdated">
            <summary>
            This event is raised immediately after the camera transform has been updated, but before movement is updated.
            </summary>
        </member>
        <member name="E:OVRPlayerController.PreCharacterMove">
            <summary>
            This event is raised right before the character controller is actually moved in order to provide other systems the opportunity to 
            move the character controller in response to things other than user input, such as movement of the HMD. See CharacterCameraConstraint.cs
            for an example of this.
            </summary>
        </member>
        <member name="F:OVRPlayerController.EnableLinearMovement">
            <summary>
            When true, user input will be applied to linear movement. Set this to false whenever the player controller needs to ignore input for
            linear movement.
            </summary>
        </member>
        <member name="F:OVRPlayerController.EnableRotation">
            <summary>
            When true, user input will be applied to rotation. Set this to false whenever the player controller needs to ignore input for rotation.
            </summary>
        </member>
        <member name="M:OVRPlayerController.UpdateTransform(OVRCameraRig)">
            <summary>
            Invoked by OVRCameraRig's UpdatedAnchors callback. Allows the Hmd rotation to update the facing direction of the player.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Jump">
            <summary>
            Jump! Must be enabled manually.
            </summary>
        </member>
        <member name="M:OVRPlayerController.Stop">
            <summary>
            Stop this instance.
            </summary>
        </member>
        <member name="M:OVRPlayerController.GetMoveScaleMultiplier(System.Single@)">
            <summary>
            Gets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetMoveScaleMultiplier(System.Single)">
            <summary>
            Sets the move scale multiplier.
            </summary>
            <param name="moveScaleMultiplier">Move scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetRotationScaleMultiplier(System.Single@)">
            <summary>
            Gets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.SetRotationScaleMultiplier(System.Single)">
            <summary>
            Sets the rotation scale multiplier.
            </summary>
            <param name="rotationScaleMultiplier">Rotation scale multiplier.</param>
        </member>
        <member name="M:OVRPlayerController.GetSkipMouseRotation(System.Boolean@)">
            <summary>
            Gets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">Allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.SetSkipMouseRotation(System.Boolean)">
            <summary>
            Sets the allow mouse rotation.
            </summary>
            <param name="skipMouseRotation">If set to <c>true</c> allow mouse rotation.</param>
        </member>
        <member name="M:OVRPlayerController.GetHaltUpdateMovement(System.Boolean@)">
            <summary>
            Gets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">Halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.SetHaltUpdateMovement(System.Boolean)">
            <summary>
            Sets the halt update movement.
            </summary>
            <param name="haltUpdateMovement">If set to <c>true</c> halt update movement.</param>
        </member>
        <member name="M:OVRPlayerController.ResetOrientation">
            <summary>
            Resets the player look rotation when the device orientation is reset.
            </summary>
        </member>
        <member name="T:OVRProgressIndicator">
            <summary>
            Visualizes progress for operations such as loading.
            </summary>
        </member>
        <member name="T:OVRRaycaster">
            <summary>
            Extension of GraphicRaycaster to support ray casting with world space rays instead of just screen-space
            pointer positions
            </summary>
        </member>
        <member name="F:OVRRaycaster.m_RaycastResults">
            <summary>
            For the given ray, find graphics on this canvas which it intersects and are not blocked by other
            world objects
            </summary>
        </member>
        <member name="M:OVRRaycaster.Raycast(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Performs a raycast using eventData.worldSpaceRay
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="M:OVRRaycaster.RaycastPointer(UnityEngine.EventSystems.PointerEventData,System.Collections.Generic.List{UnityEngine.EventSystems.RaycastResult})">
            <summary>
            Performs a raycast using the pointer object attached to this OVRRaycaster 
            </summary>
            <param name="eventData"></param>
            <param name="resultAppendList"></param>
        </member>
        <member name="F:OVRRaycaster.s_SortedGraphics">
            <summary>
            Perform a raycast into the screen and collect all graphics underneath it.
            </summary>
        </member>
        <member name="M:OVRRaycaster.GetScreenPosition(UnityEngine.EventSystems.RaycastResult)">
            <summary>
            Get screen position of worldPosition contained in this RaycastResult
            </summary>
            <param name="worldPosition"></param>
            <returns></returns>
        </member>
        <member name="M:OVRRaycaster.RayIntersectsRectTransform(UnityEngine.RectTransform,UnityEngine.Ray,UnityEngine.Vector3@)">
            <summary>
            Detects whether a ray intersects a RectTransform and if it does also 
            returns the world position of the intersection.
            </summary>
            <param name="rectTransform"></param>
            <param name="ray"></param>
            <param name="worldPos"></param>
            <returns></returns>
        </member>
        <member name="M:OVRRaycaster.IsFocussed">
            <summary>
            Is this the currently focussed Raycaster according to the InputModule
            </summary>
            <returns></returns>
        </member>
        <member name="T:OVRResetOrientation">
            <summary>
            Allows you to reset VR input tracking with a gamepad button press.
            </summary>
        </member>
        <member name="F:OVRResetOrientation.resetButton">
            <summary>
            The gamepad button that will reset VR input tracking.
            </summary>
        </member>
        <member name="M:OVRResetOrientation.Update">
            <summary>
            Check input and reset orientation if necessary
            See the input mapping setup in the Unity Integration guide
            </summary>
        </member>
        <member name="T:OVRSceneSampleController">
            <summary>
            Sample that allows you to play with various VR settings. 
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.quitKey">
            <summary>
            The key that quits the application.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.fadeInTexture">
            <summary>
            An optional texture that appears before the menu fades in.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.speedRotationIncrement">
            <summary>
            Controls how quickly the player's speed and rotation change based on input.
            </summary>
        </member>
        <member name="F:OVRSceneSampleController.layerName">
            <summary>
            We can set the layer to be anything we want to, this allows
            a specific camera to render it.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Awake">
            <summary>
            Awake this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Start">
            <summary>
            Start this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.Update">
            <summary>
            Update this instance.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateVisionMode">
            <summary>
            Updates the vision mode.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateSpeedAndRotationScaleMultiplier">
            <summary>
            Updates the speed and rotation scale multiplier.
            </summary>
        </member>
        <member name="M:OVRSceneSampleController.UpdateRecenterPose">
            <summary>
            Recenter pose
            </summary>
        </member>
        <member name="T:OVRScreenFade">
            <summary>
            Fades the screen from black after a new scene is loaded. Fade can also be controlled mid-scene using SetUIFade and SetFadeLevel
            </summary>
        </member>
        <member name="F:OVRScreenFade.renderQueue">
            <summary>
            The render queue used by the fade mesh. Reduce this if you need to render on top of it.
            </summary>
        </member>
        <member name="M:OVRScreenFade.FadeOut">
            <summary>
            Start a fade out
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnLevelFinishedLoading(System.Int32)">
            <summary>
            Starts a fade in when a new level is loaded
            </summary>
        </member>
        <member name="M:OVRScreenFade.Start">
            <summary>
            Automatically starts a fade in
            </summary>
        </member>
        <member name="M:OVRScreenFade.OnDestroy">
            <summary>
            Cleans up the fade material
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetUIFade(System.Single)">
            <summary>
            Set the UI fade level - fade due to UI in foreground
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetFadeLevel(System.Single)">
            <summary>
            Override current fade level
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:OVRScreenFade.Fade(System.Single,System.Single)">
            <summary>
            Fades alpha from 1.0 to 0.0
            </summary>
        </member>
        <member name="M:OVRScreenFade.SetMaterialAlpha">
            <summary>
            Update material alpha. UI fade and the current fade due to fade in/out animations (or explicit control)
            both affect the fade. (The max is taken) 
            </summary>
        </member>
        <member name="T:OVRTrackedRemote">
            <summary>
            Simple helper script that conditionally enables rendering of a controller if it is connected.
            </summary>
        </member>
        <member name="F:OVRTrackedRemote.m_modelGearVrController">
            <summary>
            The root GameObject that represents the GearVr Controller model.
            </summary>
        </member>
        <member name="F:OVRTrackedRemote.m_modelOculusGoController">
            <summary>
            The root GameObject that represents the Oculus Go Controller model.
            </summary>
        </member>
        <member name="F:OVRTrackedRemote.m_controller">
            <summary>
            The controller that determines whether or not to enable rendering of the controller model.
            </summary>
        </member>
        <member name="T:OVRWaitCursor">
            <summary>
            Rotates this GameObject at a given speed.
            </summary>
        </member>
        <member name="M:OVRWaitCursor.Update">
            <summary>
            Auto rotates the attached cursor.
            </summary>
        </member>
        <member name="T:VRTK.Examples.PanelMenu.PanelMenuDemoFlyingSaucer">
            <summary>
            Demo component for Panel Menu example scene.
            </summary>
            <example>
            See the demo scene for a complete example: [ 040_Controls_Panel_Menu ]
            </example>
        </member>
        <member name="T:VRTK.Examples.PanelMenu.PanelMenuDemoSphere">
            <summary>
            Demo component for Panel Menu example scene.
            </summary>
            <example>
            See the demo scene for a complete example: [ 038_Controls_Panel_Menu ]
            </example>
        </member>
        <member name="T:VRTK.Examples.PanelMenu.PanelMenuUIGrid">
            <summary>
            Demo GridLayoutGroup component that subscribes to PanelMenuItemController events.
            </summary>
            <example>
            See the demo scene for a complete example: [ 040_Controls_Panel_Menu ] 
            </example>
        </member>
        <member name="T:VRTK.Examples.PanelMenu.PanelMenuUISlider">
            <summary>
             Demo component for example scene.
            </summary>
            <example>
            See the demo scene for a complete example: [ 040_Controls_Panel_Menu ] 
            </example>
        </member>
        <member name="T:VRTK.AxisOverrides.ApplyOverrideType">
            <summary>
            Determine when to apply the override.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.Never">
            <summary>
            Never apply the override.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.Always">
            <summary>
            Always apply the override.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.DigitalState">
            <summary>
            Only apply the override when the state is set to digital.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.AxisState">
            <summary>
            Only apply the override when the state is set to axis.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.SenseAxisState">
            <summary>
            Only apply the override when the state is set to sense axis.
            </summary>
        </member>
        <member name="F:VRTK.AxisOverrides.ApplyOverrideType.AxisAndSenseAxisState">
            <summary>
            Only apply the override when the state is set to axis or sense axis.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_AvatarHandController">
            <summary>
            Provides a custom controller hand model with psuedo finger functionality.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/AvatarHands/BasicHands/VRTK_BasicHand` prefab as a child of either the left or right script alias.
             * If the prefab is being used in the left hand then check the `Mirror Model` parameter.
             * By default, the avatar hand controller will detect which controller is connected and represent it accordingly.
             * Optionally, use SDKTransformModify scripts to adjust the hand orientation based on different controller types.
            </remarks>
            <example>
            `032_Controller_CustomControllerModel` uses the `VRTK_BasicHand` prefab to display custom avatar hands for the left and right controller.
            </example>
        </member>
        <member name="T:VRTK.VRTK_ConsoleViewer">
             <summary>
             Adds an in-scene representation of the Unity console on a world space canvas.
             </summary>
             <remarks>
             **Prefab Usage:**
              * Place the `VRTK/Prefabs/ConsoleViewerCanvas/ConsoleViewerCanvas` prefab into the scene hierarchy.
            
               > It is also possible to interact with the `ConsoleViewerCanvas` with a `VRTK_UIPointer`.
             </remarks>
        </member>
        <member name="M:VRTK.VRTK_ConsoleViewer.SetCollapse(System.Boolean)">
            <summary>
            The SetCollapse method determines whether the console will collapse same message output into the same line. A state of `true` will collapse messages and `false` will print the same message for each line.
            </summary>
            <param name="state">The state of whether to collapse the output messages, true will collapse and false will not collapse.</param>
        </member>
        <member name="M:VRTK.VRTK_ConsoleViewer.ClearLog">
            <summary>
            The ClearLog method clears the current log view of all messages
            </summary>
        </member>
        <member name="T:VRTK.ControllerRigidbodyActivatorEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The object that touching the activator.</param>
        </member>
        <member name="T:VRTK.ControllerRigidbodyActivatorEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ControllerRigidbodyActivatorEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_ControllerRigidbodyActivator">
             <summary>
             Provides a simple trigger collider volume that when a controller enters will enable the rigidbody on the controller.
             </summary>
             <remarks>
             **Prefab Usage:**
              * Place the `VRTK/Prefabs/ControllerRigidbodyActivator/ControllerRigidbodyActivator` prefab in the scene at the location where the controller rigidbody should be automatically activated.
              * The prefab contains a default sphere collider to determine ths collision, this collider component can be customised in the inspector or can be replaced with another collider component (set to `Is Trigger`).
            
               > If the prefab is placed as a child of the target Interactable Object then the collider volume on the prefab will trigger collisions on the Interactable Object.
             </remarks>
        </member>
        <member name="E:VRTK.VRTK_ControllerRigidbodyActivator.ControllerRigidbodyOn">
            <summary>
            Emitted when the controller rigidbody is turned on.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerRigidbodyActivator.ControllerRigidbodyOff">
            <summary>
            Emitted when the controller rigidbody is turned off.
            </summary>
        </member>
        <member name="T:VRTK.ControllerTooltipsEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="element">The tooltip element being affected.</param>
        </member>
        <member name="T:VRTK.ControllerTooltipsEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ControllerTooltipsEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_ControllerTooltips">
             <summary>
             Adds a collection of Object Tooltips to the Controller providing information to what the controller buttons may do.
             </summary>
             <remarks>
             **Prefab Usage:**
              * Place the `VRTK/Prefabs/ControllerTooltips/ControllerTooltips` prefab as a child of the relevant controller script alias GameObject in the scene hierarchy.
              * If no `Button Transform Settings` are provided in the inspector at Edit time then the button transforms will attempt to be set to the transforms of the current SDK default controller model.
              * If one of the `Button Text Settings` text options are not provided, then the tooltip for that specific button will be hidden.
            
               > There are a number of parameters that can be set on the Prefab which are provided by the `VRTK_ControllerTooltips` script which is applied to the prefab.
             </remarks>
             <example>
             `VRTK/Examples/029_Controller_Tooltips` displays two cubes that have an object tooltip added to them along with tooltips that have been added to the controllers.
             </example>
        </member>
        <member name="E:VRTK.VRTK_ControllerTooltips.ControllerTooltipOn">
            <summary>
            Emitted when the controller tooltip is turned on.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerTooltips.ControllerTooltipOff">
            <summary>
            Emitted when the controller tooltip is turned off.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerTooltips.ResetTooltip">
            <summary>
            The Reset method reinitalises the tooltips on all of the controller elements.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerTooltips.UpdateText(VRTK.VRTK_ControllerTooltips.TooltipButtons,System.String)">
            <summary>
            The UpdateText method allows the tooltip text on a specific controller element to be updated at runtime.
            </summary>
            <param name="element">The specific controller element to change the tooltip text on.</param>
            <param name="newText">A string containing the text to update the tooltip to display.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerTooltips.ToggleTips(System.Boolean,VRTK.VRTK_ControllerTooltips.TooltipButtons)">
            <summary>
            The ToggleTips method will display the controller tooltips if the state is `true` and will hide the controller tooltips if the state is `false`. An optional `element` can be passed to target a specific controller tooltip to toggle otherwise all tooltips are toggled.
            </summary>
            <param name="state">The state of whether to display or hide the controller tooltips, true will display and false will hide.</param>
            <param name="element">The specific element to hide the tooltip on, if it is `TooltipButtons.None` then it will hide all tooltips. Optional parameter defaults to `TooltipButtons.None`</param>
        </member>
        <member name="T:VRTK.VRTK_DesktopCamera">
            <summary>
            Allows rendering a separate camera that is shown on the desktop only, without changing what's seen in VR headsets.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/DesktopCamera/DesktopCamera` prefab in the scene.
            </remarks>
        </member>
        <member name="T:VRTK.DestinationPointEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
        </member>
        <member name="T:VRTK.VRTK_DestinationPoint">
            <summary>
            Allows for a specific scene marker or specific area within the scene that can be teleported to.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/DestinationPoint/DestinationPoint` prefab at the desired location within the scene.
             * Uncheck the `Enable Teleport` checkbox to lock the destination point and prevent teleporting to it.
             * Uncheck the `Snap To Point` checkbox to provide a destination area rather than a specific point to teleport to.
            </remarks>
            <example>
            `044_CameraRig_RestrictedTeleportZones` uses the `VRTK_DestinationPoint` prefab to set up a collection of pre-defined teleport locations.
            </example>
        </member>
        <member name="T:VRTK.VRTK_DestinationPoint.RotationTypes">
            <summary>
            Allowed snap to rotation types.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DestinationPoint.RotationTypes.NoRotation">
            <summary>
            No rotation information will be emitted in the destination set payload.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DestinationPoint.RotationTypes.RotateWithNoHeadsetOffset">
            <summary>
            The destination point's rotation will be emitted without taking into consideration the current headset rotation.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DestinationPoint.RotationTypes.RotateWithHeadsetOffset">
            <summary>
            The destination point's rotation will be emitted and will take into consideration the current headset rotation.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationPoint.DestinationPointEnabled">
            <summary>
            Emitted when the destination point is enabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationPoint.DestinationPointDisabled">
            <summary>
            Emitted when the destination point is disabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationPoint.DestinationPointLocked">
            <summary>
            Emitted when the destination point is locked.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationPoint.DestinationPointUnlocked">
            <summary>
            Emitted when the destination point is unlocked.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationPoint.DestinationPointReset">
            <summary>
            Emitted when the destination point is reset.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_DestinationPoint.ResetDestinationPoint">
            <summary>
            The ResetDestinationPoint resets the destination point back to the default state.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_FramesPerSecondViewer">
             <summary>
             Provides a frames per second text element to the HMD view. To use the prefab it must be placed into the scene then the headset camera needs attaching to the canvas:
             </summary>
             <remarks>
             **Prefab Usage:**
              * Place the `VRTK/Prefabs/FramesPerSecondCanvas/FramesPerSecondCanvas` prefab in the scene hierarchy.
            
               > This script is largely based on the script at: http://talesfromtherift.com/vr-fps-counter/ So all credit to Peter Koch for his work. Twitter: @peterept
             </remarks>
             <example>
             `VRTK/Examples/018_CameraRig_FramesPerSecondCounter` displays the frames per second in the centre of the headset view. Pressing the trigger generates a new sphere and pressing the touchpad generates ten new spheres. Eventually when lots of spheres are present the FPS will drop and demonstrate the prefab.
             </example>
        </member>
        <member name="T:VRTK.ObjectTooltipEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="newText">The optional new text that is given to the tooltip.</param>
        </member>
        <member name="T:VRTK.ObjectTooltipEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ObjectTooltipEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_ObjectTooltip">
            <summary>
            Adds a World Space Canvas that can be used to provide additional information about an object by providing a piece of text with a line drawn to a destination point.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/ObjectTooltip/ObjectTooltip` prefab into the scene hierarchy, preferably as a child of the GameObject it is associated with.
             * Set the `Draw Line To` option to the Transform component of the GameObject the Tooltip will be assoicated with.
            </remarks>
            <example>
            `VRTK/Examples/029_Controller_Tooltips` displays two cubes that have an object tooltip added to them along with tooltips that have been added to the controllers.
            </example>
        </member>
        <member name="E:VRTK.VRTK_ObjectTooltip.ObjectTooltipReset">
            <summary>
            Emitted when the object tooltip is reset.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ObjectTooltip.ObjectTooltipTextUpdated">
            <summary>
            Emitted when the object tooltip text is updated.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ObjectTooltip.ResetTooltip">
            <summary>
            The ResetTooltip method resets the tooltip back to its initial state.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ObjectTooltip.UpdateText(System.String)">
            <summary>
            The UpdateText method allows the tooltip text to be updated at runtime.
            </summary>
            <param name="newText">A string containing the text to update the tooltip to display.</param>
        </member>
        <member name="T:VRTK.VRTK_PanelMenuController">
            <summary>
            Adds a top-level controller to handle the display of up to four child PanelMenuItemController items which are displayed as a canvas UI panel.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/PanelMenu/PanelMenu` prefab as a child of the `VRTK_InteractableObject` the panel menu is for.
             * Optionally remove the panel control menu item child GameObjects if they are not required, e.g. `PanelTopControls`.
             * Set the panel menu item controllers on the `VRTK_PanelMenuController` script to determine which panel control menu items are available.
             * The available panel control menu items can be activated by pressing the corresponding direction on the touchpad.
            </remarks>
            <example>
            `040_Controls_Panel_Menu` contains three basic interactive object examples of the PanelMenu in use.
            </example>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuController.ToggleMenu">
            <summary>
            The ToggleMenu method is used to show or hide the menu.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuController.ShowMenu">
            <summary>
            The ShowMenu method is used to show the menu.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuController.HideMenu(System.Boolean)">
            <summary>
            The HideMenu method is used to hide the menu.
            </summary>
            <param name="force">If true then the menu is always hidden.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuController.HideMenuImmediate">
            <summary>
            The HideMenuImmediate method is used to immediately hide the menu.
            </summary>
        </member>
        <member name="T:VRTK.PanelMenuItemControllerEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactableObject">The GameObject for the interactable object the PanelMenu is attached to.</param>
        </member>
        <member name="T:VRTK.PanelMenuItemControllerEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.PanelMenuItemControllerEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_PanelMenuItemController">
            <summary>
            Intercepts the controller events sent from a `VRTK_PanelMenuController` and passes them onto additional custom event subscriber scripts, which then carry out the required custom UI actions.
            </summary>
            <remarks>
              > This script is not directly part of a prefab but is a helper associated to the `PanelMenu` prefab.
              
            * Place the `VRTK/Prefabs/PanelMenu/VRTK_PanelMenuItemController` script on the child GameObject of any Panel Item Container which is contained within the `PanelMenuController` prefab within the scene.
            * Pick up the VRTK_InteractableObject show/hide the panel menu by pressing the touchpad top/bottom/left/right you can open/close the child UI panel that has been assigned via the Unity Editor panel.
            </remarks>
            <example>
            `040_Controls_Panel_Menu` contains three basic interactive object examples of the PanelMenu in use.
            </example>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemShowing">
            <summary>
            Emitted when the panel menu item is showing.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemHiding">
            <summary>
            Emitted when the panel menu item is hiding.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemSwipeLeft">
            <summary>
            Emitted when the panel menu item is open and the user swipes left on the controller touchpad.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemSwipeRight">
            <summary>
            Emitted when the panel menu item is open and the user swipes right on the controller touchpad.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemSwipeTop">
            <summary>
            Emitted when the panel menu item is open and the user swipes top on the controller touchpad.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemSwipeBottom">
            <summary>
            Emitted when the panel menu item is open and the user swipes bottom on the controller touchpad.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PanelMenuItemController.PanelMenuItemTriggerPressed">
            <summary>
            Emitted when the panel menu item is open and the user presses the trigger of the controller holding the interactable object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.SetPanelMenuItemEvent(UnityEngine.GameObject)">
            <summary>
            The SetPanelMenuItemEvent is used to build up the event payload.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
            <returns>The payload for the event.</returns>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.Show(UnityEngine.GameObject)">
            <summary>
            The Show method is used to show the menu.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.Hide(UnityEngine.GameObject)">
            <summary>
            The Hide method is used to show the menu.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.SwipeLeft(UnityEngine.GameObject)">
            <summary>
            The SwipeLeft method is used when the control is swiped left.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.SwipeRight(UnityEngine.GameObject)">
            <summary>
            The SwipeRight method is used when the control is swiped right.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.SwipeTop(UnityEngine.GameObject)">
            <summary>
            The SwipeTop method is used when the control is swiped up.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.SwipeBottom(UnityEngine.GameObject)">
            <summary>
            The SwipeBottom method is used when the control is swiped down.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="M:VRTK.VRTK_PanelMenuItemController.TriggerPressed(UnityEngine.GameObject)">
            <summary>
            The TriggerPressed method is used when the control action button is pressed.
            </summary>
            <param name="interactableObject">The object the menu is attached to.</param>
        </member>
        <member name="T:VRTK.PointerDirectionIndicatorEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
        </member>
        <member name="T:VRTK.VRTK_PointerDirectionIndicator">
             <summary>
             Adds a Pointer Direction Indicator to a pointer renderer and determines a given world rotation that can be used by a Destiantion Marker.
             </summary>
             <remarks>
             **Prefab Usage:**
              * Place the `VRTK/Prefabs/PointerDirectionIndicator/PointerDirectionIndicator` prefab into the scene hierarchy.
              * Attach the `PointerDirectionIndicator` scene GameObejct to the `Direction Indicator` inspector parameter on a `VRTK_BasePointerRenderer` component.
            
               > This can be useful for rotating the play area upon teleporting to face the user in a new direction without expecting them to physically turn in the play space.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_PointerDirectionIndicator.VisibilityState">
            <summary>
            States of Direction Indicator Visibility.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PointerDirectionIndicator.VisibilityState.OnWhenPointerActive">
            <summary>
            Only shows the direction indicator when the pointer is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PointerDirectionIndicator.VisibilityState.AlwaysOnWithPointerCursor">
            <summary>
            Only shows the direction indicator when the pointer cursor is visible or if the cursor is hidden and the pointer is active.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PointerDirectionIndicator.PointerDirectionIndicatorPositionSet">
            <summary>
            Emitted when the object tooltip is reset.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PointerDirectionIndicator.Initialize(VRTK.VRTK_ControllerEvents)">
            <summary>
            The Initialize method is used to set up the direction indicator.
            </summary>
            <param name="events">The Controller Events script that is used to control the direction indicator's rotation.</param>
        </member>
        <member name="M:VRTK.VRTK_PointerDirectionIndicator.SetPosition(System.Boolean,UnityEngine.Vector3)">
            <summary>
            The SetPosition method is used to set the world position of the direction indicator.
            </summary>
            <param name="active">Determines if the direction indicator GameObject should be active or not.</param>
            <param name="position">The position to set the direction indicator to.</param>
        </member>
        <member name="M:VRTK.VRTK_PointerDirectionIndicator.GetRotation">
            <summary>
            The GetRotation method returns the current reported rotation of the direction indicator.
            </summary>
            <returns>The reported rotation of the direction indicator.</returns>
        </member>
        <member name="M:VRTK.VRTK_PointerDirectionIndicator.SetMaterialColor(UnityEngine.Color,System.Boolean)">
            <summary>
            The SetMaterialColor method sets the current material colour on the direction indicator.
            </summary>
            <param name="color">The colour to update the direction indicatormaterial to.</param>
            <param name="validity">Determines if the colour being set is based from a valid location or invalid location.</param>
        </member>
        <member name="M:VRTK.VRTK_PointerDirectionIndicator.GetControllerEvents">
            <summary>
            The GetControllerEvents method returns the associated Controller Events script with the Pointer Direction Indicator script.
            </summary>
            <returns>The associated Controller Events script.</returns>
        </member>
        <member name="T:VRTK.VRTK_IndependentRadialMenuController">
            <summary>
            Allows the RadialMenu to be anchored to any object, not just a controller.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/RadialMenu/RadialMenu` prefab as a child of the GameObject to associate the Radial Menu with.
             * Position and scale the menu by adjusting the transform of the `RadialMenu` empty.
             * Replace `VRTK_RadialMenuController` with `VRTK_IndependentRadialMenuController` that is located on the `RadialMenu/RadialMenuUI/Panel` GameObject.
             * Ensure the parent object has the `VRTK_InteractableObject` script.
             * Verify that `Is Usable` and `Hold Button to Use` are both checked on the `VRTK_InteractableObject`.
             * Attach `VRTK_InteractTouch` and `VRTK_InteractUse` scripts to the objects that will activate the Radial Menu (e.g. the Controllers).
            </remarks>
            <example>
            `VRTK/Examples/030_Controls_RadialTouchpadMenu` displays a radial menu for each controller. The left controller uses the `Hide On Release` variable, so it will only be visible if the left touchpad is being touched. It also uses the `Execute On Unclick` variable to delay execution until the touchpad button is unclicked. The example scene also contains a demonstration of anchoring the RadialMenu to an interactable cube instead of a controller.
            </example>
        </member>
        <member name="M:VRTK.VRTK_IndependentRadialMenuController.UpdateEventsManager">
            <summary>
            The UpdateEventsManager method is used to update the events within the menu controller.
            </summary>
        </member>
        <member name="M:VRTK.TouchAngleDeflection.#ctor(System.Single,System.Single)">
            <summary>
            Constructs an object to hold the angle and deflection of the user's touch on the touchpad
            </summary>
            <param name="angle">The angle of the touch on the radial menu.</param>
            <param name="deflection">Deflection of the touch, where 0 is the centre and 1 is the edge.</param>
        </member>
        <member name="T:VRTK.VRTK_RadialMenu">
            <summary>
            Provides a UI element into the world space that can be dropped into a Controller GameObject and used to create and use Radial Menus from the touchpad.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/RadialMenu/RadialMenu` prefab as a child of a Controller script alias GameObject.
            </remarks>
            <example>
            `VRTK/Examples/030_Controls_RadialTouchpadMenu` displays a radial menu for each controller. The left controller uses the `Hide On Release` variable, so it will only be visible if the left touchpad is being touched. It also uses the `Execute On Unclick` variable to delay execution until the touchpad button is unclicked. The example scene also contains a demonstration of anchoring the RadialMenu to an interactable cube instead of a controller.
            </example>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.HoverButton(System.Single)">
            <summary>
            The HoverButton method is used to set the button hover at a given angle.
            </summary>
            <param name="angle">The angle on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.HoverButton(VRTK.TouchAngleDeflection)">
            <summary>
            The HoverButton method is used to set the button hover at a given angle and deflection.
            </summary>
            <param name="givenTouchAngleDeflection">The angle and deflection on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.ClickButton(System.Single)">
            <summary>
            The ClickButton method is used to set the button click at a given angle.
            </summary>
            <param name="angle">The angle on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.ClickButton(VRTK.TouchAngleDeflection)">
            <summary>
            The ClickButton method is used to set the button click at a given angle and deflection.
            </summary>
            <param name="givenTouchAngleDeflection">The angle and deflection on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.UnClickButton(System.Single)">
            <summary>
            The UnClickButton method is used to set the button unclick at a given angle.
            </summary>
            <param name="angle">The angle on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.UnClickButton(VRTK.TouchAngleDeflection)">
            <summary>
            The UnClickButton method is used to set the button unclick at a given angle and deflection.
            </summary>
            <param name="givenTouchAngleDeflection">The angle and deflection on the radial menu.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.ToggleMenu">
            <summary>
            The ToggleMenu method is used to show or hide the radial menu.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.StopTouching">
            <summary>
            The StopTouching method is used to stop touching the menu.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.ShowMenu">
            <summary>
            The ShowMenu method is used to show the menu.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.GetButton(System.Int32)">
            <summary>
            The GetButton method is used to get a button from the menu.
            </summary>
            <param name="id">The id of the button to retrieve.</param>
            <returns>The found radial menu button.</returns>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.HideMenu(System.Boolean)">
            <summary>
            The HideMenu method is used to hide the menu.
            </summary>
            <param name="force">If true then the menu is always hidden.</param>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.RegenerateButtons">
            <summary>
            The RegenerateButtons method creates all the button arcs and populates them with desired icons.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_RadialMenu.AddButton(VRTK.VRTK_RadialMenu.RadialMenuButton)">
            <summary>
            The AddButton method is used to add a new button to the menu.
            </summary>
            <param name="newButton">The button to add.</param>
        </member>
        <member name="T:VRTK.VRTK_SDKSetupSwitcher">
            <summary>
            Provides a GUI overlay to allow switching the loaded VRTK_SDKSetup of the the current VRTK_SDKManager.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/SDKSetupSwitcher/SDKSetupSwitcher` prefab into the scene hierarchy.
            </remarks>
        </member>
        <member name="T:VRTK.SnapDropZoneEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="snappedObject">The interactable object that is dealing with the snap drop zone.</param>
        </member>
        <member name="T:VRTK.SnapDropZoneEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.SnapDropZoneEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_SnapDropZone">
            <summary>
            Provides a predefined zone where a valid interactable object can be dropped and upon dropping it snaps to the set snap drop zone transform position, rotation and scale.
            </summary>
            <remarks>
            **Prefab Usage:**
             * Place the `VRTK/Prefabs/SnapDropZone/SnapDropZone` prefab into the scene hierarchy.
             * Provide the SnapDropZone with an optional `Highlight Object Prefab` to generate an object outline in the scene that determines the final position, rotation and scale of the snapped object.
             * If no `VRTK_BaseHighlighter` derivative is applied to the SnapDropZone then the default MaterialColorSwap Highlighter will be used.
             * The collision zone that activates the SnapDropZone is a `Sphere Collider` by default but can be amended or replaced on the SnapDropZone GameObject.
             * If the `Use Joint` Snap Type is selected then a custom Joint component is required to be added to the `SnapDropZone` Game Object and upon release the interactable object's rigidbody will be linked to this joint as the `Connected Body`.
            </remarks>
            <example>
            `VRTK/Examples/041_Controller_ObjectSnappingToDropZones` uses the `VRTK_SnapDropZone` prefab to set up pre-determined snap zones for a range of objects and demonstrates how only objects of certain types can be snapped into certain areas.
            </example>
        </member>
        <member name="T:VRTK.VRTK_SnapDropZone.SnapTypes">
            <summary>
            The types of snap on release available.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SnapDropZone.SnapTypes.UseKinematic">
            <summary>
            Will set the interactable object rigidbody to `isKinematic = true`.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SnapDropZone.SnapTypes.UseJoint">
            <summary>
            Will attach the interactable object's rigidbody to the provided joint as it's `Connected Body`.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SnapDropZone.SnapTypes.UseParenting">
            <summary>
            Will set the SnapDropZone as the interactable object's parent and set it's rigidbody to `isKinematic = true`.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_SnapDropZone.ObjectEnteredSnapDropZone">
            <summary>
            Emitted when a valid interactable object enters the snap drop zone trigger collider.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_SnapDropZone.ObjectExitedSnapDropZone">
            <summary>
            Emitted when a valid interactable object exists the snap drop zone trigger collider.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_SnapDropZone.ObjectSnappedToDropZone">
            <summary>
            Emitted when an interactable object is successfully snapped into a drop zone.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_SnapDropZone.ObjectUnsnappedFromDropZone">
            <summary>
            Emitted when an interactable object is removed from a snapped drop zone.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.InitaliseHighlightObject(System.Boolean)">
            <summary>
            The InitaliseHighlightObject method sets up the highlight object based on the given Highlight Object Prefab.
            </summary>
            <param name="removeOldObject">If this is set to true then it attempts to delete the old highlight object if it exists. Defaults to `false`</param>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.ForceSnap(UnityEngine.GameObject)">
            <summary>
            the ForceSnap method attempts to automatically attach a valid GameObject to the snap drop zone.
            </summary>
            <param name="objectToSnap">The GameObject to attempt to snap.</param>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.ForceSnap(VRTK.VRTK_InteractableObject)">
            <summary>
            the ForceSnap method attempts to automatically attach a valid Interactable Object to the snap drop zone.
            </summary>
            <param name="objectToSnap">The Interactable Object to attempt to snap.</param>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.ForceUnsnap">
            <summary>
            The ForceUnsnap method attempts to automatically remove the current snapped game object from the snap drop zone.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.ValidSnappableObjectIsHovering">
            <summary>
            The ValidSnappableObjectIsHovering method determines if any valid objects are currently hovering in the snap drop zone area.
            </summary>
            <returns>Returns true if a valid object is currently in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.IsObjectHovering(UnityEngine.GameObject)">
            <summary>
            The IsObjectHovering method determines if the given GameObject is currently howvering (but not snapped) in the snap drop zone area.
            </summary>
            <param name="checkObject">The GameObject to check to see if it's hovering in the snap drop zone area.</param>
            <returns>Returns true if the given GameObject is hovering (but not snapped) in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.IsInteractableObjectHovering(VRTK.VRTK_InteractableObject)">
            <summary>
            The IsInteractableObjectHovering method determines if the given Interactable Object script is currently howvering (but not snapped) in the snap drop zone area.
            </summary>
            <param name="checkObject">The Interactable Object script to check to see if it's hovering in the snap drop zone area.</param>
            <returns>Returns true if the given Interactable Object script is hovering (but not snapped) in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.GetHoveringObjects">
            <summary>
            The GetHoveringObjects method returns a List of valid GameObjects that are currently hovering (but not snapped) in the snap drop zone area.
            </summary>
            <returns>The List of valid GameObjects that are hovering (but not snapped) in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.GetHoveringInteractableObjects">
            <summary>
            The GetHoveringInteractableObjects method returns a List of valid Interactable Object scripts that are currently hovering (but not snapped) in the snap drop zone area.
            </summary>
            <returns>The List of valid Interactable Object scripts that are hovering (but not snapped) in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.GetCurrentSnappedObject">
            <summary>
            The GetCurrentSnappedObejct method returns the GameObject that is currently snapped in the snap drop zone area.
            </summary>
            <returns>The GameObject that is currently snapped in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.GetCurrentSnappedInteractableObject">
            <summary>
            The GetCurrentSnappedInteractableObject method returns the Interactable Object script that is currently snapped in the snap drop zone area.
            </summary>
            <returns>The Interactable Object script that is currently snapped in the snap drop zone area.</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.Clone(UnityEngine.Vector3)">
            <summary>
            The Clone method returns the GameObject of the cloned snap drop zone
            </summary>
            <param name="position">Position of the cloned GameObject</param>
            <returns>The GameObject of the clone</returns>
        </member>
        <member name="M:VRTK.VRTK_SnapDropZone.Clone">
            <summary>
            The Clone method returns the GameObject of the cloned snap drop zone
            </summary>
            <returns>The GameObject of the clone</returns>
        </member>
        <member name="T:VRTK.VRTK_ContentHandler">
            <summary>
            Manages objects defined as content. When taking out an object from a drawer and closing the drawer this object would otherwise disappear even if outside the drawer.
            </summary>
            <remarks>
            The script will use the boundaries of the control to determine if it is in or out and re-parent the object as necessary. It can be put onto individual objects or the parent of multiple objects. Using the latter way all interactable objects under that parent will become managed by the script.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` has a drawer with a collection of items that adhere to this concept.
            </example>
        </member>
        <member name="T:VRTK.Button3DEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.Control3DEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_Button">
            <summary>
            Attaching the script to a game object will allow the user to interact with it as if it were a push button. The direction into which the button should be pushable can be freely set and auto-detection is supported. Since this is physics-based there needs to be empty space in the push direction so that the button can move.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody and ConstantForce components automatically in case they do not exist yet.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` shows a collection of pressable buttons that are interacted with by activating the rigidbody on the controller by pressing the grab button without grabbing an object.
            </example>
        </member>
        <member name="T:VRTK.VRTK_Button.ButtonDirection">
            <summary>
            3D Control Button Directions
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.autodetect">
            <summary>
            Attempt to auto detect the axis.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.x">
            <summary>
            The world x direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.y">
            <summary>
            The world y direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.z">
            <summary>
            The world z direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.negX">
            <summary>
            The world negative x direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.negY">
            <summary>
            The world negative y direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Button.ButtonDirection.negZ">
            <summary>
            The world negative z direction.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Button.Pushed">
            <summary>
            Emitted when the 3D Button has reached its activation distance.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Button.Released">
            <summary>
            Emitted when the 3D Button's position has become less than activation distance after being pressed.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Chest">
            <summary>
            Transforms a game object into a chest with a lid. The direction can be auto-detected with very high reliability or set manually.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody, Interactable and HingeJoint components automatically in case they do not exist yet. It will expect three distinct game objects: a body, a lid and a handle. These should be independent and not children of each other.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` shows a chest that can be open and closed, it also displays the current opening angle of the chest.
            </example>
        </member>
        <member name="T:VRTK.Control3DEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="value">The current value being reported by the control.</param>
            <param name="normalizedValue">The normalized value being reported by the control.</param>
        </member>
        <member name="T:VRTK.Control3DEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.Control3DEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_Control">
            <summary>
            All 3D controls extend the `VRTK_Control` abstract class which provides a default set of methods and events that all of the subsequent controls expose.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Control.ControlValueRange">
            <summary>
            The ControlValueRange struct provides a way for each inherited control to support value normalization.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Control.Direction">
            <summary>
            3D Control Directions
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Control.Direction.autodetect">
            <summary>
            Attempt to auto detect the axis.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Control.Direction.x">
            <summary>
            The world x direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Control.Direction.y">
            <summary>
            The world y direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Control.Direction.z">
            <summary>
            The world z direction.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Control.ValueChanged">
            <summary>
            Emitted when the 3D Control value has changed.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_Control.GetValue">
            <summary>
            The GetValue method returns the current value/position/setting of the control depending on the control that is extending this abstract class.
            </summary>
            <returns>The current value of the control.</returns>
        </member>
        <member name="M:VRTK.VRTK_Control.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current value mapped onto a range between 0 and 100.
            </summary>
            <returns>The current normalized value of the control.</returns>
        </member>
        <member name="M:VRTK.VRTK_Control.SetContent(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetContent method sets the given game object as the content of the control. This will then disable and optionally hide the content when a control is obscuring its view to prevent interacting with content within a control.
            </summary>
            <param name="content">The content to be considered within the control.</param>
            <param name="hideContent">When true the content will be hidden in addition to being non-interactable in case the control is fully closed.</param>
        </member>
        <member name="M:VRTK.VRTK_Control.GetContent">
            <summary>
            The GetContent method returns the current game object of the control's content.
            </summary>
            <returns>The currently stored content for the control.</returns>
        </member>
        <member name="T:VRTK.VRTK_Door">
             <summary>
             Transforms a game object into a door with an optional handle attached to an optional frame. The direction can be freely set and also very reliably auto-detected.
             </summary>
             <remarks>
             There are situations when it can be very hard to automatically calculate the correct axis and anchor values for the hinge joint. If this situation is encountered then simply add the hinge joint manually and set these two values. All the rest will still be handled by the script.
            
             The script will instantiate the required Rigidbodies, Interactable and HingeJoint components automatically in case they do not exist yet. Gizmos will indicate the direction.
             </remarks>
             <example>
             `VRTK/Examples/025_Controls_Overview` shows a selection of door types, from a normal door and trapdoor, to a door with a cat-flap in the middle.
             </example>
        </member>
        <member name="T:VRTK.VRTK_Drawer">
             <summary>
             Transforms a game object into a drawer. The direction can be freely set and also auto-detected with very high reliability.
             </summary>
             <remarks>
             The script will instantiate the required Rigidbody, Interactable and Joint components automatically in case they do not exist yet. There are situations when it can be very hard to automatically calculate the correct axis for the joint. If this situation is encountered simply add the configurable joint manually and set the axis. All the rest will still be handled by the script.
            
             It will expect two distinct game objects: a body and a handle. These should be independent and not children of each other. The distance to which the drawer can be pulled out will automatically set depending on the length of it. If no body is specified the current object is assumed to be the body.
            
             It is possible to supply a third game object which is the root of the contents inside the drawer. When this is specified the VRTK_InteractableObject components will be automatically deactivated in case the drawer is closed or not yet far enough open. This eliminates the issue that a user could grab an object inside a drawer although it is closed.
             </remarks>
             <example>
             `VRTK/Examples/025_Controls_Overview` shows a drawer with contents that can be opened and closed freely and the contents can be removed from the drawer.
             </example>
        </member>
        <member name="T:VRTK.VRTK_Knob">
            <summary>
            Attaching the script to a game object will allow the user to interact with it as if it were a radial knob. The direction can be freely set.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody and Interactable components automatically in case they do not exist yet.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` has a couple of rotator knobs that can be rotated by grabbing with the controller and then rotating the controller in the desired direction.
            </example>
        </member>
        <member name="T:VRTK.VRTK_Knob.KnobDirection">
            <summary>
            The direction of the knob.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Knob.KnobDirection.x">
            <summary>
            The world x direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Knob.KnobDirection.y">
            <summary>
            The world y direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Knob.KnobDirection.z">
            <summary>
            The world z direction.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Lever">
            <summary>
            Attaching the script to a game object will allow the user to interact with it as if it were a lever. The direction can be freely set.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody, Interactable and HingeJoint components automatically in case they do not exist yet. The joint is very tricky to setup automatically though and will only work in straight forward cases. If there are any issues, then create the HingeJoint component manually and configure it as needed.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` has a couple of levers that can be grabbed and moved. One lever is horizontal and the other is vertical.
            </example>
        </member>
        <member name="T:VRTK.VRTK_Lever.LeverDirection">
            <summary>
            The direction of the lever.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Lever.LeverDirection.x">
            <summary>
            The world x direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Lever.LeverDirection.y">
            <summary>
            The world y direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Lever.LeverDirection.z">
            <summary>
            The world z direction.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Slider">
            <summary>
            Attaching the script to a game object will allow the user to interact with it as if it were a horizontal or vertical slider. The direction can be freely set and auto-detection is supported.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody and Interactable components automatically in case they do not exist yet.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` has a selection of sliders at various angles with different step values to demonstrate their usage.
            </example>
        </member>
        <member name="T:VRTK.VRTK_SpringLever">
            <summary>
            This script extends VRTK_Lever to add spring force toward whichever end of the lever's range it is closest to.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody, Interactable and HingeJoint components automatically in case they do not exist yet. The joint is very tricky to setup automatically though and will only work in straight forward cases. If there are any issues, then create the HingeJoint component manually and configure it as needed.
            </remarks>
        </member>
        <member name="M:VRTK.VRTK_SpringLever.InitRequiredComponents">
            <summary>
            Override the original InitRequiredComponents() to add
            handling of spring forces on the hingeJoint
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SpringLever.HandleUpdate">
            <summary>
            Adjust spring force during HandleUpdate()
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SpringLever.ApplySpringForce">
            <summary>
            Check which direction the lever needs to be pushed in and
            switch spring direction as necessary
            </summary>
        </member>
        <member name="T:VRTK.VRTK_Wheel">
            <summary>
            Attaching the script to a game object will allow the user to interact with it as if it were a spinnable wheel.
            </summary>
            <remarks>
            The script will instantiate the required Rigidbody and Interactable components automatically in case they do not exist yet.
            </remarks>
            <example>
            `VRTK/Examples/025_Controls_Overview` has a collection of wheels that can be rotated by grabbing with the controller and then rotating the controller in the desired direction.
            </example>
        </member>
        <member name="T:VRTK.VRTK_Wheel.GrabTypes">
            <summary>
            The grab attach mechanic to use.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Wheel.GrabTypes.TrackObject">
            <summary>
            Utilise the track object grab mechanic.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Wheel.GrabTypes.RotatorTrack">
            <summary>
            Utilise the rotator track grab mechanic.
            </summary>
        </member>
        <member name="T:VRTK.Highlighters.VRTK_BaseHighlighter">
            <summary>
            Provides a base that all highlighters can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides highlight functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.Initialise(System.Nullable{UnityEngine.Color},UnityEngine.GameObject,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The Initalise method is used to set up the state of the highlighter.
            </summary>
            <param name="color">An optional colour may be passed through at point of initialisation in case the highlighter requires it.</param>
            <param name="affectObject">An optional GameObject to specify which object to apply the highlighting to.</param>
            <param name="options">An optional dictionary of highlighter specific options that may be differ with highlighter implementations.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.ResetHighlighter">
            <summary>
            The ResetHighlighter method is used to reset the highlighter if anything on the object has changed. It should be called by any scripts changing object materials or colours.
            </summary>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.Highlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Highlight method is used to initiate the highlighting logic to apply to an object.
            </summary>
            <param name="color">An optional colour to highlight the game object to. The highlight colour may already have been set in the `Initialise` method so may not be required here.</param>
            <param name="duration">An optional duration of how long before the highlight has occured. It can be used by highlighters to fade the colour if possible.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.Unhighlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Unhighlight method is used to initiate the logic that returns an object back to it's original appearance.
            </summary>
            <param name="color">An optional colour that could be used during the unhighlight phase. Usually will be left as null.</param>
            <param name="duration">An optional duration of how long before the unhighlight has occured.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.GetOption``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            The GetOption method is used to return a value from the options array if the given key exists.
            </summary>
            <typeparam name="T">The system type that is expected to be returned.</typeparam>
            <param name="options">The dictionary of options to check in.</param>
            <param name="key">The identifier key to look for.</param>
            <returns>The value in the options at the given key returned in the provided system type.</returns>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.UsesClonedObject">
            <summary>
            The UsesClonedObject method is used to return whether the current highlighter creates a cloned object to do the highlighting with.
            </summary>
            <returns>Returns `true` if the highlighter creates a cloned object to apply the highlighter on, returns `false` if no additional object is created.</returns>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_BaseHighlighter.GetActiveHighlighter(UnityEngine.GameObject)">
            <summary>
            The GetActiveHighlighter method checks the given GameObject for a valid and active highlighter.
            </summary>
            <param name="obj">The GameObject to check for a highlighter on.</param>
            <returns>A valid and active highlighter.</returns>
        </member>
        <member name="T:VRTK.Highlighters.VRTK_MaterialColorSwapHighlighter">
             <summary>
             Swaps the texture colour on the Renderers material for the given highlight colour.
             </summary>
             <remarks>
               > Due to the way the object material is interacted with, changing the material colour will break Draw Call Batching in Unity whilst the object is highlighted. The Draw Call Batching will resume on the original material when the item is no longer highlighted.
            
             **Script Usage:**
              * Place the `VRTK_MaterialColorSwapHighlighter` script on either:
                * The GameObject of the Interactable Object to highlight.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Object Highlighter` parameter to denote use of the highlighter.
              * Ensure the `Active` parameter is checked.
             </remarks>
             <example>
             `VRTK/Examples/005_Controller_BasicObjectGrabbing` demonstrates the solid highlighting on the green cube, red cube and flying saucer when the controller touches it.
            
             `VRTK/Examples/035_Controller_OpacityAndHighlighting` demonstrates the solid highlighting if the right controller collides with the green box or if any of the buttons are pressed.
             </example>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialColorSwapHighlighter.Initialise(System.Nullable{UnityEngine.Color},UnityEngine.GameObject,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The Initialise method sets up the highlighter for use.
            </summary>
            <param name="color">Not used.</param>
            <param name="affectObject">An optional GameObject to specify which object to apply the highlighting to.</param>
            <param name="options">A dictionary array containing the highlighter options:\r     * `&lt;'resetMainTexture', bool&gt;` - Determines if the default main texture should be cleared on highlight. `true` to reset the main default texture, `false` to not reset it.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialColorSwapHighlighter.ResetHighlighter">
            <summary>
            The ResetHighlighter method stores the object's materials and shared materials prior to highlighting.
            </summary>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialColorSwapHighlighter.Highlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Highlight method initiates the change of colour on the object and will fade to that colour (from a base white colour) for the given duration.
            </summary>
            <param name="color">The colour to highlight to.</param>
            <param name="duration">The time taken to fade to the highlighted colour.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialColorSwapHighlighter.Unhighlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Unhighlight method returns the object back to it's original colour.
            </summary>
            <param name="color">Not used.</param>
            <param name="duration">Not used.</param>
        </member>
        <member name="T:VRTK.Highlighters.VRTK_MaterialPropertyBlockColorSwapHighlighter">
             <summary>
             Swaps the texture colour on the Renderers material for the given highlight colour using property blocks.
             </summary>
             <remarks>
               > Utilising the MaterialPropertyBlock means that Draw Call Batching in Unity is not compromised.
            
             **Script Usage:**
              * Place the `VRTK_MaterialPropertyBlockColorSwapHighlighter` script on either:
                * The GameObject of the Interactable Object to highlight.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Object Highlighter` parameter to denote use of the highlighter.
              * Ensure the `Active` parameter is checked.
             </remarks>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialPropertyBlockColorSwapHighlighter.Initialise(System.Nullable{UnityEngine.Color},UnityEngine.GameObject,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The Initialise method sets up the highlighter for use.
            </summary>
            <param name="color">Not used.</param>
            <param name="affectObject">An optional GameObject to specify which object to apply the highlighting to.</param>
            <param name="options">A dictionary array containing the highlighter options:\r     * `&lt;'resetMainTexture', bool&gt;` - Determines if the default main texture should be cleared on highlight. `true` to reset the main default texture, `false` to not reset it.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_MaterialPropertyBlockColorSwapHighlighter.Unhighlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Unhighlight method returns the object back to it's original colour.
            </summary>
            <param name="color">Not used.</param>
            <param name="duration">Not used.</param>
        </member>
        <member name="T:VRTK.Highlighters.VRTK_OutlineObjectCopyHighlighter">
             <summary>
             Creates a mesh copy and applies an outline shader which is toggled on and off when highlighting the object.
             </summary>
             <remarks>
               > A valid mesh must be found or provided for the clone mesh to be created.
            
             **Script Usage:**
              * Place the `VRTK_OutlineObjectCopyHighlighter` script on either:
                * The GameObject of the Interactable Object to highlight.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Object Highlighter` parameter to denote use of the highlighter.
              * Ensure the `Active` parameter is checked.
             </remarks>
             <example>
             `VRTK/Examples/005_Controller_BasicObjectGrabbing` demonstrates the outline highlighting on the green sphere when the controller touches it.
            
             `VRTK/Examples/035_Controller_OpacityAndHighlighting` demonstrates the outline highlighting if the left controller collides with the green box.
             </example>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_OutlineObjectCopyHighlighter.Initialise(System.Nullable{UnityEngine.Color},UnityEngine.GameObject,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The Initialise method sets up the highlighter for use.
            </summary>
            <param name="color">Not used.</param>
            <param name="affectObject">An optional GameObject to specify which object to apply the highlighting to.</param>
            <param name="options">A dictionary array containing the highlighter options:\r     * `&lt;'thickness', float&gt;` - Same as `thickness` inspector parameter.\r     * `&lt;'customOutlineModels', GameObject[]&gt;` - Same as `customOutlineModels` inspector parameter.\r     * `&lt;'customOutlineModelPaths', string[]&gt;` - Same as `customOutlineModelPaths` inspector parameter.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_OutlineObjectCopyHighlighter.ResetHighlighter">
            <summary>
            The ResetHighlighter method creates the additional model to use as the outline highlighted object.
            </summary>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_OutlineObjectCopyHighlighter.Highlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Highlight method initiates the outline object to be enabled and display the outline colour.
            </summary>
            <param name="color">The colour to outline with.</param>
            <param name="duration">Not used.</param>
        </member>
        <member name="M:VRTK.Highlighters.VRTK_OutlineObjectCopyHighlighter.Unhighlight(System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The Unhighlight method hides the outline object and removes the outline colour.
            </summary>
            <param name="color">Not used.</param>
            <param name="duration">Not used.</param>
        </member>
        <member name="T:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher">
             <summary>
             An artificially simulated pushable pusher.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
            
             **Script Usage:**
              * Place the `VRTK_ArtificialPusher` script onto the GameObject that is to become the pusher.
             </remarks>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.GetValue">
            <summary>
            The GetValue method returns the current position value of the pusher.
            </summary>
            <returns>The actual position of the pusher.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current position value of the pusher normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized position of the pusher.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.SetValue(System.Single)">
            <summary>
            The SetValue method is not implemented as the pusher resets automatically.
            </summary>
            <param name="value">Not used.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.IsResting">
            <summary>
            The IsResting method returns whether the pusher is currently at it's resting position.
            </summary>
            <returns>Returns `true` if the pusher is currently at the resting position.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.SetStayPressed(System.Boolean)">
            <summary>
            The SetStayPressed method sets the `Stay Pressed` parameter to the given state and if the state is false and the pusher is currently pressed then it is reset to the original position.
            </summary>
            <param name="state">The state to set the `Stay Pressed` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialPusher.SetPositionTarget(System.Single)">
            <summary>
            The SetPositionTarget method sets the `Position Target` parameter to the given normalized value.
            </summary>
            <param name="normalizedTarget">The `Position Target` to set the pusher to between `0f` and `1f`.</param>
        </member>
        <member name="T:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator">
             <summary>
             A artificially simulated openable rotator.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
             
             **Script Usage:**
              * Create a rotator container GameObject and set the GameObject that is to become the rotator as a child of the newly created container GameObject.
              * Place the `VRTK_ArtificialRotator` script onto the GameObject that is to become the rotatable object and ensure the Transform rotation is `0, 0, 0`.
              * Create a nested GameObject under the rotator GameObject and position it where the hinge should operate.
              * Apply the nested hinge GameObject to the `Hinge Point` parameter on the Artificial Rotator script.
            
               > The rotator GameObject must not be at the root level and needs to have the Transform rotation set to `0,0,0`. This is the reason for the container GameObject requirement. Any positioning of the rotator must be set on the parent container GameObject.
               > The Artificial Rotator script GameObject will become the child of a runtime created GameObject that determines the rotational offset for the rotator.
             </remarks>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetValue">
            <summary>
            The GetValue method returns the current rotation value of the rotator.
            </summary>
            <returns>The actual rotation of the rotator.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current rotation value of the rotator normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized rotation of the rotator.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.SetValue(System.Single)">
            <summary>
            The SetValue method sets the current Angle of the rotator
            </summary>
            <param name="value">The new rotation value</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetContainer">
            <summary>
            The GetContainer method returns the GameObject that is generated to hold the rotator control.
            </summary>
            <returns>The GameObject container of the rotator control.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetStepValue(System.Single)">
            <summary>
            The GetStepValue method returns the current angle of the rotator based on the step value range.
            </summary>
            <param name="currentValue">The current angle value of the rotator to get the Step Value for.</param>
            <returns>The current Step Value based on the rotator angle.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.SetAngleTargetWithStepValue(System.Single)">
            <summary>
            The SetAngleTargetWithStepValue sets the `Angle Target` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Angle Target` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.SetRestingAngleWithStepValue(System.Single)">
            <summary>
            The SetRestingAngleWithStepValue sets the `Resting Angle` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Resting Angle` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetAngleFromStepValue(System.Single)">
            <summary>
            The GetAngleFromStepValue returns the angle the rotator would be at based on the given step value.
            </summary>
            <param name="givenStepValue">The step value to check the angle for.</param>
            <returns>The angle the rotator would be at based on the given step value.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.SetAngleTarget(System.Single)">
            <summary>
            The SetAngleTarget method sets a target angle to rotate the rotator to.
            </summary>
            <param name="newAngle">The angle in which to rotate the rotator to.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.IsResting">
            <summary>
            The IsResting method returns whether the rotator is at the resting angle or within the resting angle threshold.
            </summary>
            <returns>Returns `true` if the rotator is at the resting angle or within the resting angle threshold.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialRotator.GetControlInteractableObject">
            <summary>
            The GetControlInteractableObject method returns the Interactable Object associated with the control.
            </summary>
            <returns>The Interactable Object associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider">
             <summary>
             A artificially simulated slider.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
            
             **Script Usage:**
              * Create a slider container GameObject and set the GameObject that is to become the slider as a child of the container.
              * Place the `VRTK_ArtificialSlider` script onto the GameObject that is to become the slider.
            
               > The slider GameObject must not be at the root level and needs to have it's Transform position set to `0,0,0`. This is the reason for the container GameObject requirement. Any positioning of the slider must be set on the parent GameObject.
             </remarks>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.GetValue">
            <summary>
            The GetValue method returns the current position value of the slider.
            </summary>
            <returns>The actual position of the button.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current position value of the slider normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized position of the button.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.SetValue(System.Single)">
            <summary>
            The SetValue method sets the current position value of the slider
            </summary>
            <param name="value">The new position value</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.GetStepValue(System.Single)">
            <summary>
            The GetStepValue method returns the current position of the slider based on the step value range.
            </summary>
            <param name="currentValue">The current position value of the slider to get the Step Value for.</param>
            <returns>The current Step Value based on the slider position.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.SetPositionTarget(System.Single,System.Single)">
            <summary>
            The SetPositionTarget method allows the setting of the `Position Target` parameter at runtime.
            </summary>
            <param name="newPositionTarget">The new position target value.</param>
            <param name="speed">The speed to move to the new position target.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.SetPositionTargetWithStepValue(System.Single,System.Single)">
            <summary>
            The SetPositionTargetWithStepValue sets the `Position Target` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Position Target` parameter to.</param>
            <param name="speed">The speed to move to the new position target.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.SetRestingPositionWithStepValue(System.Single)">
            <summary>
            The SetRestingPositionWithStepValue sets the `Resting Position` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Resting Position` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.GetPositionFromStepValue(System.Single)">
            <summary>
            The GetPositionFromStepValue returns the position the slider would be at based on the given step value.
            </summary>
            <param name="givenStepValue">The step value to check the position for.</param>
            <returns>The position the slider would be at based on the given step value.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.IsResting">
            <summary>
            The IsResting method returns whether the slider is at the resting position or within the resting position threshold.
            </summary>
            <returns>Returns `true` if the slider is at the resting position or within the resting position threshold.</returns>
        </member>
        <member name="M:VRTK.Controllables.ArtificialBased.VRTK_ArtificialSlider.GetControlInteractableObject">
            <summary>
            The GetControlInteractableObject method returns the Interactable Object associated with the control.
            </summary>
            <returns>The Interactable Object associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.PhysicsBased.VRTK_BasePhysicsControllable">
            <summary>
            Provides a base that all physics based Controllables can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides physics based controllable functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_BasePhysicsControllable.GetControlRigidbody">
            <summary>
            The GetControlRigidbody method returns the rigidbody associated with the control.
            </summary>
            <returns>The Rigidbody associated with the control.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_BasePhysicsControllable.GetControlActivatorContainer">
            <summary>
            The GetControlActivatorContainer method returns the GameObject that contains the Controller Rigidbody Activator associated with the control.
            </summary>
            <returns>The GameObject that contains the Controller Rigidbody Activator associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher">
             <summary>
             A physics based pushable pusher.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
              * `Rigidbody` - A Unity Rigidbody to allow the GameObject to be affected by the Unity Physics System. Will be automatically added at runtime.
            
             **Optional Components:**
              * `VRTK_ControllerRigidbodyActivator` - A Controller Rigidbody Activator to automatically enable the controller rigidbody upon touching the pusher.
             
             **Script Usage:**
              * Create a pusher container GameObject and set the GameObject that is to become the pusher as a child of the newly created container GameObject.
              * Place the `VRTK_PhysicsPusher` script onto the GameObject that is to become the pusher.
            
               > The Physics Pusher script must not be on a root level GameObject. Any runtime world positioning of the pusher must be set on the parent container GameObject.
             </remarks>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher.GetValue">
            <summary>
            The GetValue method returns the current position value of the pusher.
            </summary>
            <returns>The actual position of the pusher.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current position value of the pusher normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized position of the pusher.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher.SetValue(System.Single)">
            <summary>
            The SetValue method is not implemented as the pusher resets automatically.
            </summary>
            <param name="value">Not used.</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher.IsResting">
            <summary>
            The IsResting method returns whether the pusher is currently at it's resting position.
            </summary>
            <returns>Returns `true` if the pusher is currently at the resting position.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsPusher.GetControlJoint">
            <summary>
            The GetControlJoint method returns the joint associated with the control.
            </summary>
            <returns>The joint associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator">
             <summary>
             A physics based rotatable object.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
              * `Rigidbody` - A Unity Rigidbody to allow the GameObject to be affected by the Unity Physics System. Will be automatically added at runtime.
            
             **Optional Components:**
              * `VRTK_ControllerRigidbodyActivator` - A Controller Rigidbody Activator to automatically enable the controller rigidbody when near the rotator.
             
             **Script Usage:**
              * Create a rotator container GameObject and set the GameObject that is to become the rotator as a child of the newly created container GameObject.
              * Place the `VRTK_PhysicsRotator` script onto the GameObject that is to become the rotatable object and ensure the Transform rotation is `0, 0, 0`.
              * Create a nested GameObject under the rotator GameObject and position it where the hinge should operate.
              * Apply the nested hinge GameObject to the `Hinge Point` parameter on the Physics Rotator script.
            
               > The rotator GameObject must not be at the root level and needs to have the Transform rotation set to `0,0,0`. This is the reason for the container GameObject requirement. Any positioning of the rotator must be set on the parent container GameObject.
             </remarks>
        </member>
        <member name="T:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GrabMechanic">
            <summary>
            Type of Grab Mechanic
            </summary>
        </member>
        <member name="F:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GrabMechanic.TrackObject">
            <summary>
            The Track Object Grab Mechanic
            </summary>
        </member>
        <member name="F:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GrabMechanic.RotatorTrack">
            <summary>
            The Rotator Track Grab Mechanic
            </summary>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetValue">
            <summary>
            The GetValue method returns the current rotation value of the rotator.
            </summary>
            <returns>The actual rotation of the rotator.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current rotation value of the rotator normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized rotation of the rotator.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.SetValue(System.Single)">
            <summary>
            The SetValue method sets the current Angle of the rotator
            </summary>
            <param name="value">The new rotation value</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetStepValue(System.Single)">
            <summary>
            The GetStepValue method returns the current angle of the rotator based on the step value range.
            </summary>
            <param name="currentValue">The current angle value of the rotator to get the Step Value for.</param>
            <returns>The current Step Value based on the rotator angle.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.SetAngleTargetWithStepValue(System.Single)">
            <summary>
            The SetAngleTargetWithStepValue sets the `Angle Target` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Angle Target` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.SetRestingAngleWithStepValue(System.Single)">
            <summary>
            The SetRestingAngleWithStepValue sets the `Resting Angle` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Resting Angle` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetAngleFromStepValue(System.Single)">
            <summary>
            The GetAngleFromStepValue returns the angle the rotator would be at based on the given step value.
            </summary>
            <param name="givenStepValue">The step value to check the angle for.</param>
            <returns>The angle the rotator would be at based on the given step value.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.IsResting">
            <summary>
            The IsResting method returns whether the rotator is at the resting angle or within the resting angle threshold.
            </summary>
            <returns>Returns `true` if the rotator is at the resting angle or within the resting angle threshold.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetControlJoint">
            <summary>
            The GetControlJoint method returns the joint associated with the control.
            </summary>
            <returns>The joint associated with the control.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsRotator.GetControlInteractableObject">
            <summary>
            The GetControlInteractableObject method returns the Interactable Object associated with the control.
            </summary>
            <returns>The Interactable Object associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider">
             <summary>
             A physics based slider.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects. Will be automatically added at runtime.
              * `Rigidbody` - A Unity Rigidbody to allow the GameObject to be affected by the Unity Physics System. Will be automatically added at runtime.
            
             **Optional Components:**
              * `VRTK_ControllerRigidbodyActivator` - A Controller Rigidbody Activator to automatically enable the controller rigidbody when near the slider.
             
             **Script Usage:**
              * Create a slider container GameObject and set the GameObject that is to become the slider as a child of the container.
              * Place the `VRTK_PhysicsSlider` script onto the GameObject that is to become the slider.
            
               > The slider GameObject must not be at the root level and needs to have it's Transform position set to `0,0,0`. This is the reason for the container GameObject requirement. Any positioning of the slider must be set on the parent GameObject.
             </remarks>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetValue">
            <summary>
            The GetValue method returns the current position value of the slider.
            </summary>
            <returns>The actual position of the button.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetNormalizedValue">
            <summary>
            The GetNormalizedValue method returns the current position value of the slider normalized between `0f` and `1f`.
            </summary>
            <returns>The normalized position of the button.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.SetValue(System.Single)">
            <summary>
            The SetValue method sets the current position value of the slider
            </summary>
            <param name="value">The new position value</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetStepValue(System.Single)">
            <summary>
            The GetStepValue method returns the current position of the slider based on the step value range.
            </summary>
            <param name="currentValue">The current position value of the slider to get the Step Value for.</param>
            <returns>The current Step Value based on the slider position.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.SetPositionTargetWithStepValue(System.Single)">
            <summary>
            The SetTargetPositionWithStepValue sets the `Position Target` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Position Target` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.SetRestingPositionWithStepValue(System.Single)">
            <summary>
            The SetRestingPositionWithStepValue sets the `Resting Position` parameter but uses a value within the `Step Value Range`.
            </summary>
            <param name="givenStepValue">The step value within the `Step Value Range` to set the `Resting Position` parameter to.</param>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetPositionFromStepValue(System.Single)">
            <summary>
            The GetPositionFromStepValue returns the position the slider would be at based on the given step value.
            </summary>
            <param name="givenStepValue">The step value to check the position for.</param>
            <returns>The position the slider would be at based on the given step value.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.IsResting">
            <summary>
            The IsResting method returns whether the slider is currently in a resting state at the resting position or within the resting position threshold and not grabbed.
            </summary>
            <returns>Returns `true` if the slider is at the resting position or within the resting position threshold.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetControlJoint">
            <summary>
            The GetControlJoint method returns the joint associated with the control.
            </summary>
            <returns>The joint associated with the control.</returns>
        </member>
        <member name="M:VRTK.Controllables.PhysicsBased.VRTK_PhysicsSlider.GetControlInteractableObject">
            <summary>
            The GetControlInteractableObject method returns the Interactable Object associated with the control.
            </summary>
            <returns>The Interactable Object associated with the control.</returns>
        </member>
        <member name="T:VRTK.Controllables.ControllableEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingCollider">The Collider that is initiating the interaction.</param>
            <param name="interactingTouchScript">The optional Interact Touch script that is initiating the interaction.</param>
            <param name="value">The current value being reported by the controllable.</param>
            <param name="normalizedValue">The normalized value being reported by the controllable.</param>
        </member>
        <member name="T:VRTK.Controllables.ControllableEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.Controllables.ControllableEventArgs"/></param>
        </member>
        <member name="T:VRTK.Controllables.VRTK_BaseControllable">
            <summary>
            Provides a base that all Controllables can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides controllable functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="T:VRTK.Controllables.VRTK_BaseControllable.OperatingAxis">
            <summary>
            The local axis that the Controllable will be operated through.
            </summary>
        </member>
        <member name="F:VRTK.Controllables.VRTK_BaseControllable.OperatingAxis.xAxis">
            <summary>
            The local x axis.
            </summary>
        </member>
        <member name="F:VRTK.Controllables.VRTK_BaseControllable.OperatingAxis.yAxis">
            <summary>
            The local y axis.
            </summary>
        </member>
        <member name="F:VRTK.Controllables.VRTK_BaseControllable.OperatingAxis.zAxis">
            <summary>
            The local z axis.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.ValueChanged">
            <summary>
            Emitted when the Controllable value has changed.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.RestingPointReached">
            <summary>
            Emitted when the Controllable value has reached the resting point.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.MinLimitReached">
            <summary>
            Emitted when the Controllable value has reached the minimum limit.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.MinLimitExited">
            <summary>
            Emitted when the Controllable value has exited the minimum limit.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.MaxLimitReached">
            <summary>
            Emitted when the Controllable value has reached the maximum limit.
            </summary>
        </member>
        <member name="E:VRTK.Controllables.VRTK_BaseControllable.MaxLimitExited">
            <summary>
            Emitted when the Controllable value has exited the maximum limit.
            </summary>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.AtMinLimit">
            <summary>
            The AtMinLimit method returns whether the Controllable is currently at it's minimum limit.
            </summary>
            <returns>Returns `true` if the Controllable is at it's minimum limit.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.AtMaxLimit">
            <summary>
            The AtMaxLimit method returns whether the Controllable is currently at it's maximum limit.
            </summary>
            <returns>Returns `true` if the Controllable is at it's maximum limit.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.GetOriginalLocalPosition">
            <summary>
            The GetOriginalLocalPosition method returns the original local position of the control.
            </summary>
            <returns>A Vector3 of the original local position.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.GetOriginalLocalRotation">
            <summary>
            The GetOriginalLocalRotation method returns the original local rotation of the control.
            </summary>
            <returns>A quaternion of the original local rotation.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.GetControlColliders">
            <summary>
            The GetControlColliders method returns the Colliders array associated with the control.
            </summary>
            <returns>The Colliders array associated with the control.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.GetInteractingCollider">
            <summary>
            The GetInteractingCollider method returns the Collider of the GameObject currently interacting with the control.
            </summary>
            <returns>The Collider currently interacting with the control.</returns>
        </member>
        <member name="M:VRTK.Controllables.VRTK_BaseControllable.GetInteractingTouch">
            <summary>
            The GetInteractingTouch method returns the Interact Touch script of the GameObject currently interacting with the control.
            </summary>
            <returns>The Interact Touch script currently interacting with the control.</returns>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach">
            <summary>
            Provides a base that all grab attach mechanics can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides grab attach functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.IsTracked">
            <summary>
            The IsTracked method determines if the grab attach mechanic is a track object type.
            </summary>
            <returns>Is true if the mechanic is of type tracked.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.IsClimbable">
            <summary>
            The IsClimbable method determines if the grab attach mechanic is a climbable object type.
            </summary>
            <returns>Is true if the mechanic is of type climbable.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.IsKinematic">
            <summary>
            The IsKinematic method determines if the grab attach mechanic is a kinematic object type.
            </summary>
            <returns>Is true if the mechanic is of type kinematic.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.ValidGrab(UnityEngine.Rigidbody)">
            <summary>
            The ValidGrab method determines if the grab attempt is valid.
            </summary>
            <param name="checkAttachPoint">The rigidbody attach point to check.</param>
            <returns>Always returns `true` for the base check.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.SetTrackPoint(UnityEngine.Transform)">
            <summary>
            The SetTrackPoint method sets the point on the grabbed Interactable Object where the grab is happening.
            </summary>
            <param name="givenTrackPoint">The track point to set on the grabbed Interactable Object.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.SetInitialAttachPoint(UnityEngine.Transform)">
            <summary>
            The SetInitialAttachPoint method sets the point on the grabbed Interactable Object where the initial grab happened.
            </summary>
            <param name="givenInitialAttachPoint">The point where the initial grab took place.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.CreateTrackPoint(UnityEngine.Transform,UnityEngine.GameObject,UnityEngine.GameObject,System.Boolean@)">
            <summary>
            The CreateTrackPoint method sets up the point of grab to track on the grabbed object.
            </summary>
            <param name="controllerPoint">The point on the controller where the grab was initiated.</param>
            <param name="currentGrabbedObject">The GameObject that is currently being grabbed.</param>
            <param name="currentGrabbingObject">The GameObject that is currently doing the grabbing.</param>
            <param name="customTrackPoint">A reference to whether the created track point is an auto generated custom object.</param>
            <returns>The Transform of the created track point.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.ProcessUpdate">
            <summary>
            The ProcessUpdate method is run in every Update method on the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method is run in every FixedUpdate method on the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseGrabAttach.ResetState">
            <summary>
            The ResetState method re-initializes the grab attach.
            </summary>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_BaseJointGrabAttach">
            <summary>
            Provides a base that all joint based grab attach mechanics can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides joint based grab attach functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseJointGrabAttach.ValidGrab(UnityEngine.Rigidbody)">
            <summary>
            The ValidGrab method determines if the grab attempt is valid.
            </summary>
            <param name="checkAttachPoint">The rigidbody attach point to check.</param>
            <returns>Returns `true` if there is no current grab happening, or the grab is initiated by another grabbing object.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseJointGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed. It is also responsible for creating the joint on the grabbed object.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_BaseJointGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state. It is also responsible for removing the joint from the grabbed object.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_ChildOfControllerGrabAttach">
             <summary>
             Sets the grabbed Interactable Object to be a child of the grabbing object.
             </summary>
             <remarks>
               > The Interactable Object will have 1:1 tracking of the grabbing object, however it will also have reduced collision detection and will be able to pass through other colliders.
            
             **Script Usage:**
              * Place the `VRTK_ChildOfControllerGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/023_Controller_ChildOfControllerOnGrab` uses this grab attach mechanic for the bow and the arrow.
             </example>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ChildOfControllerGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed. It is also responsible for creating the joint on the grabbed object.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ChildOfControllerGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_ClimbableGrabAttach">
             <summary>
             Marks the Interactable Object as being climbable.
             </summary>
             <remarks>
               > The Interactable Object will not be grabbed to the controller, instead in conjunction with the `VRTK_PlayerClimb` script will enable the PlayArea to be moved around as if it was climbing.
            
             **Script Usage:**
              * Place the `VRTK_ClimbableGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/037_CameraRig_ClimbingFalling` uses this grab attach mechanic for each item that is climbable in the scene.
             </example>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.ControlAnimationGrabAttachEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The GameObject that is performing the interaction (e.g. a controller).</param>
            <param name="currentFrame">The current frame the animation is on.</param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.ControlAnimationGrabAttachEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.GrabAttachMechanics.ControlAnimationGrabAttachEventArgs"/></param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach">
            <summary>
            Scrubs through the given animation based on the distance from the grabbing object to the original grabbing point.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_ControlAnimationGrabAttach` script on either:
               * The GameObject of the Interactable Object to detect interactions on.
               * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
               * Create and apply an animation via:
                 * `Animation Timeline` parameter takes a legacy `Animation` component to use as the timeline to scrub through. The animation must be marked as `legacy` via the inspector in debug mode.
                 * `Animator Timeline` parameter takes an Animator component to use as the timeline to scrub through.
            </remarks>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.AnimationFrameAtStart">
            <summary>
            Emitted when the Animation Frame is at the start.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.AnimationFrameAtEnd">
            <summary>
            Emitted when the Animation Frame is at the end.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.AnimationFrameChanged">
            <summary>
            Emitted when the Animation Frame has changed.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.CreateTrackPoint(UnityEngine.Transform,UnityEngine.GameObject,UnityEngine.GameObject,System.Boolean@)">
            <summary>
            The CreateTrackPoint method sets up the point of grab to track on the grabbed object.
            </summary>
            <param name="controllerPoint">The point on the controller where the grab was initiated.</param>
            <param name="currentGrabbedObject">The GameObject that is currently being grabbed.</param>
            <param name="currentGrabbingObject">The GameObject that is currently doing the grabbing.</param>
            <param name="customTrackPoint">A reference to whether the created track point is an auto generated custom object.</param>
            <returns>The Transform of the created track point.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.ProcessUpdate">
            <summary>
            The ProcessUpdate method is run in every Update method on the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.SetFrame(System.Single)">
            <summary>
            The SetFrame method scrubs to the specific frame of the Animator timeline.
            </summary>
            <param name="frame">The frame to scrub to.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_ControlAnimationGrabAttach.RewindAnimation">
            <summary>
            The RewindAnimation method will force the animation to rewind to the start frame.
            </summary>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_CustomJointGrabAttach">
             <summary>
             Attaches the grabbed Interactable Object to the grabbing object via a custom Joint.
             </summary>
             <remarks>
               > The Interactable Object will be attached to the grabbing object via a custom Joint and the Joint can be broken upon colliding the Interactable Object with other colliders.
            
             **Script Usage:**
              * Place the `VRTK_CustomJointGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
              * Create a `Joint` component suitable for attaching the grabbed Interactable Object to the grabbing object with and provide it to the `Custom Joint` parameter.
             </remarks>
             <example>
             `VRTK/Examples/021_Controller_GrabbingObjectsWithJoints` demonstrates this grab attach mechanic on the Lamp object in the scene.
             </example>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_FixedJointGrabAttach">
             <summary>
             Attaches the grabbed Interactable Object to the grabbing object via a Fixed Joint.
             </summary>
             <remarks>
               > The Interactable Object will be attached to the grabbing object via a Fixed Joint and the Joint can be broken upon colliding the Interactable Object with other colliders.
            
             **Script Usage:**
              * Place the `VRTK_FixedJointGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/005_Controller_BasicObjectGrabbing` demonstrates this grab attach mechanic all of the grabbable objects in the scene.
             </example>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.MoveTransformGrabAttachEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The GameObject that is performing the interaction (e.g. a controller).</param>
            <param name="position">The current position in relation to the axis limits from the origin position.</param>
            <param name="normalizedPosition">The normalized position (between `0f` and `1f`) of the Interactable Object in relation to the axis limits.</param>
            <param name="currentDirection">The direction vector that the Interactable Object is currently moving across the axes in.</param>
            <param name="originDirection">The direction vector that the Interactable Object is currently moving across the axes in in relation to the origin position.</param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.MoveTransformGrabAttachEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.GrabAttachMechanics.MoveTransformGrabAttachEventArgs"/></param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach">
             <summary>
             Moves the Transform of the Interactable Object towards the interacting object within specified limits.
             </summary>
             <remarks>
               > To allow unrestricted movement, set the axis limit minimum to `-infinity` and the axis limit maximum to `infinity`.
            
             **Script Usage:**
              * Place the `VRTK_MoveTransformGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.localOrigin">
            <summary>
            The default local position of the Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.TransformPositionChanged">
            <summary>
            Emitted when the Transform position has changed.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.XAxisMinLimitReached">
            <summary>
            Emitted when the Transform position has reached the X Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.XAxisMinLimitExited">
            <summary>
            Emitted when the Transform position has exited the X Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.XAxisMaxLimitReached">
            <summary>
            Emitted when the Transform position has reached the X Axis Max Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.XAxisMaxLimitExited">
            <summary>
            Emitted when the Transform position has exited the X Axis Max Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.YAxisMinLimitReached">
            <summary>
            Emitted when the Transform position has reached the Y Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.YAxisMinLimitExited">
            <summary>
            Emitted when the Transform position has exited the Y Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.YAxisMaxLimitReached">
            <summary>
            Emitted when the Transform position has reached the Y Axis Max Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.YAxisMaxLimitExited">
            <summary>
            Emitted when the Transform position has exited the Y Axis Max Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ZAxisMinLimitReached">
            <summary>
            Emitted when the Transform position has reached the Z Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ZAxisMinLimitExited">
            <summary>
            Emitted when the Transform position has exited the Z Axis Min Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ZAxisMaxLimitReached">
            <summary>
            Emitted when the Transform position has reached the Z Axis Max Limit.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ZAxisMaxLimitExited">
            <summary>
            Emitted when the Transform position has exited the Z Axis Max Limit.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.CreateTrackPoint(UnityEngine.Transform,UnityEngine.GameObject,UnityEngine.GameObject,System.Boolean@)">
            <summary>
            The CreateTrackPoint method sets up the point of grab to track on the grabbed object.
            </summary>
            <param name="controllerPoint">The point on the controller where the grab was initiated.</param>
            <param name="currentGrabbedObject">The GameObject that is currently being grabbed.</param>
            <param name="currentGrabbingObject">The GameObject that is currently doing the grabbing.</param>
            <param name="customTrackPoint">A reference to whether the created track point is an auto generated custom object.</param>
            <returns>The Transform of the created track point.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ProcessUpdate">
            <summary>
            The ProcessUpdate method is run in every Update method on the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.GetPosition">
            <summary>
            The GetPosition method returns a Vector3 of the Transform position in relation to the axis limits.
            </summary>
            <returns>A Vector3 containing the current Transform position in relation to the axis limits.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.GetNormalizedPosition">
            <summary>
            The GetNormalizedPosition method returns a Vector3 of the Transform position normalized between `0f` and `1f` in relation to the axis limits.;
            </summary>
            <returns>A normalized Vector3 of the Transform position in relation to the axis limits.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.GetCurrentDirection">
            <summary>
            The GetCurrentDirection method returns a Vector3 of the current positive/negative axis direction that the Transform is moving in.
            </summary>
            <returns>A Vector3 of the direction the Transform is moving across the relevant axis in.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.GetDirectionFromOrigin">
            <summary>
            The GetDirectionFromOrigin method returns a Vector3 of the direction across the axis from the original position.
            </summary>
            <returns>A Vector3 of the direction the Transform is moving across the relevant axis in relation to the original position.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.SetCurrentPosition(UnityEngine.Vector3,System.Single)">
            <summary>
            The SetCurrentPosition method sets the position of the Interactable Object to the given new position at the appropriate speed.
            </summary>
            <param name="newPosition">The position to move the Interactable Object to.</param>
            <param name="speed">The speed in which to move the Interactable Object.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.ResetPosition">
            <summary>
            The ResetPosition method will move the Interactable Object back to the origin position.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_MoveTransformGrabAttach.GetWorldLimits">
            <summary>
            The GetWorldLimits method returns an array of minimum and maximum axis limits for the Interactable Object in world space.
            </summary>
            <returns>An array of axis limits in world space.</returns>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.RotateTransformGrabAttachEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The GameObject that is performing the interaction (e.g. a controller).</param>
            <param name="currentAngle">The current angle the Interactable Object is rotated to.</param>
            <param name="normalizedAngle">The normalized angle (between `0f` and `1f`) the Interactable Object is rotated to.</param>
            <param name="rotationSpeed">The speed in which the rotation is occuring.</param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.RotateTransformGrabAttachEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.GrabAttachMechanics.RotateTransformGrabAttachEventArgs"/></param>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach">
             <summary>
             Rotates the Transform of the Interactable Object around a specified transform local axis within the given limits.
             </summary>
             <remarks>
               > To allow unrestricted movement, set the angle limits minimum to `-infinity` and the angle limits maximum to `infinity`.
            
             **Script Usage:**
              * Place the `VRTK_RotateTransformGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationAxis">
            <summary>
            The local axis for rotation.
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationAxis.xAxis">
            <summary>
            The local X Axis of the transform.
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationAxis.yAxis">
            <summary>
            The local Y Axis of the transform.
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationAxis.zAxis">
            <summary>
            The local Z Axis of the transform.
            </summary>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationType">
            <summary>
            The way in which rotation from the grabbing object is applied.
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationType.FollowAttachPoint">
            <summary>
            The angle between the Interactable Object origin and the grabbing object attach point.
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationType.FollowLongitudinalAxis">
            <summary>
            The angular velocity across the grabbing object's longitudinal axis (the roll axis).
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationType.FollowLateralAxis">
            <summary>
            The angular velocity across the grabbing object's lateral axis (the pitch axis).
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.RotationType.FollowPerpendicularAxis">
            <summary>
            The angular velocity across the grabbing object's perpendicular axis (the yaw axis).
            </summary>
        </member>
        <member name="F:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.originRotation">
            <summary>
            The default local rotation of the Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.AngleChanged">
            <summary>
            Emitted when the angle changes.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.MinAngleReached">
            <summary>
            Emitted when the angle reaches the minimum angle.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.MinAngleExited">
            <summary>
            Emitted when the angle exits the minimum angle state.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.MaxAngleReached">
            <summary>
            Emitted when the angle reaches the maximum angle.
            </summary>
        </member>
        <member name="E:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.MaxAngleExited">
            <summary>
            Emitted when the angle exits the maximum angle state.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.StartGrab(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Rigidbody)">
            <summary>
            The StartGrab method sets up the grab attach mechanic as soon as an Interactable Object is grabbed.
            </summary>
            <param name="grabbingObject">The GameObject that is doing the grabbing.</param>
            <param name="givenGrabbedObject">The GameObject that is being grabbed.</param>
            <param name="givenControllerAttachPoint">The point on the grabbing object that the grabbed object should be attached to after grab occurs.</param>
            <returns>Returns `true` if the grab is successful, `false` if the grab is unsuccessful.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.ProcessUpdate">
            <summary>
            The ProcessUpdate method is run in every Update method on the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.SetRotation(System.Single,System.Single)">
            <summary>
            The SetRotation method sets the rotation on the Interactable Object to the given angle over the desired time.
            </summary>
            <param name="newAngle">The angle to rotate to through the current rotation axis.</param>
            <param name="transitionTime">The time in which the entire rotation operation will take place.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.ResetRotation(System.Boolean)">
            <summary>
            The ResetRotation method will rotate the Interactable Object back to the origin rotation.
            </summary>
            <param name="ignoreTransition">If this is `true` then the `Reset To Origin On Release Speed` will be ignored and the reset will occur instantly.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.GetAngle">
            <summary>
            The GetAngle method returns the current angle the Interactable Object is rotated to.
            </summary>
            <returns>The current rotated angle.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.GetNormalizedAngle">
            <summary>
            The GetNormalizedAngle returns the normalized current angle between the minimum and maximum angle limits.
            </summary>
            <returns>The normalized rotated angle. Will return `0f` if either limit is set to `infinity`.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotateTransformGrabAttach.GetRotationSpeed">
            <summary>
            The GetRotationSpeed returns the current speed in which the Interactable Object is rotating.
            </summary>
            <returns>A Vector3 containing the speed each axis is rotating in.</returns>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_RotatorTrackGrabAttach">
             <summary>
             Applies a rotational force to the grabbed Interactable Object.
             </summary>
             <remarks>
               > The Interactable Object is not attached to the grabbing object but rather has a rotational force applied based on the rotation of the grabbing object.
            
             **Script Usage:**
              * Place the `VRTK_RotatorTrackGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/021_Controller_GrabbingObjectsWithJoints` demonstrates this grab attach mechanic on the Wheel and Door objects in the scene.
             </example>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotatorTrackGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed Interactable Object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_RotatorTrackGrabAttach.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method is run in every FixedUpdate method on the Interactable Object. It applies a force to the grabbed Interactable Object to move it in the direction of the grabbing object.
            </summary>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_SpringJointGrabAttach">
             <summary>
             Attaches the grabbed Interactable Object to the grabbing object via a Spring Joint.
             </summary>
             <remarks>
               > The Interactable Object will be attached to the grabbing object via a Spring Joint and the Joint can be broken upon colliding the Interactable Object with other colliders.
            
             **Script Usage:**
              * Place the `VRTK_SpringJointGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/021_Controller_GrabbingObjectsWithJoints` demonstrates this grab attach mechanic on the Drawer object in the scene.
             </example>
        </member>
        <member name="T:VRTK.GrabAttachMechanics.VRTK_TrackObjectGrabAttach">
             <summary>
             Applies velocity to the grabbed Interactable Object to ensure it tracks the position of the grabbing object.
             </summary>
             <remarks>
               > The Interactable Object follows the grabbing object based on velocity being applied and therefore fully interacts with all other scene Colliders but not at a true 1:1 tracking.
            
             **Script Usage:**
              * Place the `VRTK_TrackObjectGrabAttach` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Grab Attach Mechanic Script` parameter to denote use of the grab mechanic.
             </remarks>
             <example>
             `VRTK/Examples/021_Controller_GrabbingObjectsWithJoints` demonstrates this grab attach mechanic on the Chest handle and Fire Extinguisher body.
             </example>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_TrackObjectGrabAttach.StopGrab(System.Boolean)">
            <summary>
            The StopGrab method ends the grab of the current Interactable Object and cleans up the state.
            </summary>
            <param name="applyGrabbingObjectVelocity">If `true` will apply the current velocity of the grabbing object to the grabbed Interactable Object on release.</param>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_TrackObjectGrabAttach.CreateTrackPoint(UnityEngine.Transform,UnityEngine.GameObject,UnityEngine.GameObject,System.Boolean@)">
            <summary>
            The CreateTrackPoint method sets up the point of grab to track on the grabbed object.
            </summary>
            <param name="controllerPoint">The point on the controller where the grab was initiated.</param>
            <param name="currentGrabbedObject">The GameObject that is currently being grabbed.</param>
            <param name="currentGrabbingObject">The GameObject that is currently doing the grabbing.</param>
            <param name="customTrackPoint">A reference to whether the created track point is an auto generated custom object.</param>
            <returns>The Transform of the created track point.</returns>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_TrackObjectGrabAttach.ProcessUpdate">
            <summary>
            The ProcessUpdate method is run in every Update method on the Interactable Object. It is responsible for checking if the tracked object has exceeded it's detach distance.
            </summary>
        </member>
        <member name="M:VRTK.GrabAttachMechanics.VRTK_TrackObjectGrabAttach.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method is run in every FixedUpdate method on the Interactable Object. It applies velocity to the object to ensure it is tracking the grabbing object.
            </summary>
        </member>
        <member name="T:VRTK.SecondaryControllerGrabActions.VRTK_AxisScaleGrabAction">
            <summary>
            Scales the grabbed Interactable Object along the given axes based on the position of the secondary grabbing Interact Grab.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_AxisScaleGrabAction` script on either:
               * The GameObject of the Interactable Object to detect interactions on.
               * Any other scene GameObject and then link that GameObject to the Interactable Objects `Secondary Grab Action Script` parameter to denote use of the secondary grab action.
            </remarks>
            <example>
            `VRTK/Examples/043_Controller_SecondaryControllerActions` demonstrates the ability to grab an object with one controller and scale it by grabbing and pulling with the second controller.
            </example>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_AxisScaleGrabAction.Initialise(VRTK.VRTK_InteractableObject,VRTK.VRTK_InteractGrab,VRTK.VRTK_InteractGrab,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            The Initalise method is used to set up the state of the secondary action when the Interactable Object is initially grabbed by a secondary Interact Grab.
            </summary>
            <param name="currentGrabbdObject">The Interactable Object script for the object currently being grabbed by the primary grabbing object.</param>
            <param name="currentPrimaryGrabbingObject">The Interact Grab script for the object that is associated with the primary grabbing object.</param>
            <param name="currentSecondaryGrabbingObject">The Interact Grab script for the object that is associated with the secondary grabbing object.</param>
            <param name="primaryGrabPoint">The point on the Interactable Object where the primary Interact Grab initially grabbed the Interactable Object.</param>
            <param name="secondaryGrabPoint">The point on the Interactable Object where the secondary Interact Grab initially grabbed the Interactable Object.</param>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_AxisScaleGrabAction.ProcessUpdate">
            <summary>
            The ProcessUpdate method runs in every Update on the Interactable Object whilst it is being grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_AxisScaleGrabAction.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method runs in every FixedUpdate on the Interactable Object whilst it is being grabbed by a secondary Interact Grab and performs the scaling action.
            </summary>
        </member>
        <member name="T:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction">
            <summary>
            Provides a base that all secondary controller grab attach can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides secondary controller grab action functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.Initialise(VRTK.VRTK_InteractableObject,VRTK.VRTK_InteractGrab,VRTK.VRTK_InteractGrab,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            The Initalise method is used to set up the state of the secondary action when the Interactable Object is initially grabbed by a secondary Interact Grab.
            </summary>
            <param name="currentGrabbdObject">The Interactable Object script for the object currently being grabbed by the primary grabbing object.</param>
            <param name="currentPrimaryGrabbingObject">The Interact Grab script for the object that is associated with the primary grabbing object.</param>
            <param name="currentSecondaryGrabbingObject">The Interact Grab script for the object that is associated with the secondary grabbing object.</param>
            <param name="primaryGrabPoint">The point on the Interactable Object where the primary Interact Grab initially grabbed the Interactable Object.</param>
            <param name="secondaryGrabPoint">The point on the Interactable Object where the secondary Interact Grab initially grabbed the Interactable Object.</param>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.ResetAction">
            <summary>
            The ResetAction method is used to reset the secondary action when the Interactable Object is no longer grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.IsActionable">
            <summary>
            The IsActionable method is used to determine if the secondary grab action performs an action on grab.
            </summary>
            <returns>Returns `true` if the secondary grab action does perform an action on secondary grab.</returns>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.IsSwappable">
            <summary>
            The IsSwappable method is used to determine if the secondary grab action allows to swab the grab state to another grabbing Interactable Object.
            </summary>
            <returns>Returns `true` if the grab action allows swapping to another grabbing object.</returns>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.ProcessUpdate">
            <summary>
            The ProcessUpdate method runs in every Update on the Interactable Object whilst it is being grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method runs in every FixedUpdate on the Interactable Object whilst it is being grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_BaseGrabAction.OnDropAction">
            <summary>
            The OnDropAction method is executed when the current grabbed Interactable Object is dropped and can be used up to clean up any secondary grab actions.
            </summary>
        </member>
        <member name="T:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction">
             <summary>
             Controls the facing direction of the grabbed Interactable Object to rotate in the direction of the secondary grabbing object.
             </summary>
             <remarks>
               > Rotation will only occur correctly if the Interactable Object `forward` is correctly aligned to the world `z-axis` and the `up` is correctly aligned to the world `y-axis`. It is also not possible to control the direction of an Interactable Object that uses the Joint based grab mechanics.
            
             **Script Usage:**
              * Place the `VRTK_ControlDirectionGrabAction` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and then link that GameObject to the Interactable Objects `Secondary Grab Action Script` parameter to denote use of the secondary grab action.
             </remarks>
             <example>
             `VRTK/Examples/043_Controller_SecondaryControllerActions` demonstrates the ability to grab an object with one controller and control their direction with the second controller.
             </example>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction.Initialise(VRTK.VRTK_InteractableObject,VRTK.VRTK_InteractGrab,VRTK.VRTK_InteractGrab,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            The Initalise method is used to set up the state of the secondary action when the object is initially grabbed by a secondary controller.
            </summary>
            <param name="currentGrabbdObject">The Interactable Object script for the object currently being grabbed by the primary grabbing object.</param>
            <param name="currentPrimaryGrabbingObject">The Interact Grab script for the object that is associated with the primary grabbing object.</param>
            <param name="currentSecondaryGrabbingObject">The Interact Grab script for the object that is associated with the secondary grabbing object.</param>
            <param name="primaryGrabPoint">The point on the Interactable Object where the primary Interact Grab initially grabbed the Interactable Object.</param>
            <param name="secondaryGrabPoint">The point on the Interactable Object where the secondary Interact Grab initially grabbed the Interactable Object.</param>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction.ResetAction">
            <summary>
            The ResetAction method is used to reset the secondary action when the Interactable Object is no longer grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction.OnDropAction">
            <summary>
            The OnDropAction method is executed when the current grabbed Interactable Object is dropped and can be used up to clean up any secondary grab actions.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction.ProcessUpdate">
            <summary>
            The ProcessUpdate method runs in every Update on the Interactable Object whilst it is being grabbed by a secondary Interact Grab.
            </summary>
        </member>
        <member name="M:VRTK.SecondaryControllerGrabActions.VRTK_ControlDirectionGrabAction.ProcessFixedUpdate">
            <summary>
            The ProcessFixedUpdate method runs in every FixedUpdate on the Interactable Object whilst it is being grabbed by a secondary Interact Grab and influences the rotation of the Interactable Object.
            </summary>
        </member>
        <member name="T:VRTK.SecondaryControllerGrabActions.VRTK_SwapControllerGrabAction">
            <summary>
            Swaps the grabbed Interactable Object to the new grabbing object.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_SwapControllerGrabAction` script on either:
               * The GameObject of the Interactable Object to detect interactions on.
               * Any other scene GameObject and then link that GameObject to the Interactable Objects `Secondary Grab Action Script` parameter to denote use of the secondary grab action.
            </remarks>
            <example>
            `VRTK/Examples/005_Controller_BasicObjectGrabbing` demonstrates the ability to swap objects between controllers on grab.
            </example>
        </member>
        <member name="T:VRTK.VRTK_IgnoreInteractTouchColliders">
             <summary>
             Ignores the collisions between the given Interact Touch colliders and the colliders on the GameObject this script is attached to.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - Unity Colliders on the current GameObject or child GameObjects to ignore collisions from the given Interact Touch colliders.
            
             **Script Usage:**
              * Place the `VRTK_IgnoreInteractTouchColliders` script on the GameObject with colliders to ignore collisions from the given Interact Touch colliders.
              * Increase the size of the `Interact Touch To Ignore` element list.
              * Add the appropriate GameObjects that have the `VRTK_InteractTouch` script attached to use when ignoring collisions with the colliders on GameObject the script is attached to.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_InteractableListener">
            <summary>
            Provides a base that classes which require to subscribe to the interaction events of an Interactable Object can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides interaction event listener functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="T:VRTK.InteractableObjectEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The GameObject that is initiating the interaction (e.g. a controller).</param>
        </member>
        <member name="T:VRTK.InteractableObjectEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.InteractableObjectEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractableObject">
             <summary>
             Determines if the GameObject can be interacted with.
             </summary>
             <remarks>
             **Required Components:**
              * `Collider` - A Unity Collider to determine when an interaction has occured. Can be a compound collider set in child GameObjects.
            
             **Optional Components:**
              * `Rigidbody` - A Unity Rigidbody to allow the GameObject to be affected by the Unity Physics System (not required for Climbable Grab Attach Types).
              * `VRTK_BaseGrabAttach` - A Grab Attach mechanic for determining how the Interactable Object is grabbed by the primary interacting object.
              * `VRTK_BaseGrabAction` - A Grab Action mechanic for determining how to manipulate the Interactable Object when grabbed by the secondary interacting object.
            
             **Script Usage:**
              * Place the `VRTK_InteractableObject` script onto the GameObject that is to be interactable.
              * Alternatively, select the GameObject and use the `Window -> VRTK -> Setup Interactable Object` panel to set up quickly.
              * The optional Highlighter used by the Interactable Object will be selected in the following order:
                * The provided Base Highlighter in the `Object Highlighter` parameter.
                * If the above is not provided, then the first active Base Highlighter found on the Interactable Object GameObject will be used.
                * If the above is not found, then a Material Color Swap Highlighter will be created on the Interactable Object GameObject at runtime.
            
             **Script Dependencies:**
              * Interactions
                * To near touch an Interactable Object the Interact NearTouch script is required on a controller Script Alias GameObject.
                * To touch an Interactable Object the Interact NearTouch script is required on a controller Script Alias GameObject.
                * To grab an Interactable Object the Interact Grab script is required on a controller Script Alias GameObject.
                * To use an Interactable Object the Interact Use script is required on a controller Script Alias GameObject.
              * Highlighting
                * To highlight an Interactable Object on a given interaction then a valid Interact Object Highlighter script must be associated with the Interactable Object.
              * Appearance
                * To affect the appearance of an Interactable Object then a valid Interact Object Appearance script must be associated with the Interactable Object.
             </remarks>
             <example>
             `VRTK/Examples/005_Controller_BasicObjectGrabbing` uses the `VRTK_InteractTouch` and `VRTK_InteractGrab` scripts on the controllers to show how an interactable object can be grabbed and snapped to the controller and thrown around the game world.
            
             `VRTK/Examples/013_Controller_UsingAndGrabbingMultipleObjects` shows multiple objects that can be grabbed by holding the buttons or grabbed by toggling the button click and also has objects that can have their Using state toggled to show how multiple items can be turned on at the same time.
             </example>
        </member>
        <member name="T:VRTK.VRTK_InteractableObject.InteractionType">
            <summary>
            The interaction type.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.None">
            <summary>
            No interaction is affecting the object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.NearTouch">
            <summary>
            The near touch interaction is affecting the object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.NearUntouch">
            <summary>
            The near untouch interaction stopped affecting the object
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Touch">
            <summary>
            The touch interaction is affecting the object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Untouch">
            <summary>
            The untouch interaction stopped affecting the object
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Grab">
            <summary>
            The grab interaction is affecting the object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Ungrab">
            <summary>
            The ungrab interaction stopped affecting the object
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Use">
            <summary>
            The use interaction is affecting the object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.InteractionType.Unuse">
            <summary>
            The unuse interaction stopped affecting the object
            </summary>
        </member>
        <member name="T:VRTK.VRTK_InteractableObject.AllowedController">
            <summary>
            Allowed controller type.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.AllowedController.Both">
            <summary>
            Both controllers are allowed to interact.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.AllowedController.LeftOnly">
            <summary>
            Only the left controller is allowed to interact.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.AllowedController.RightOnly">
            <summary>
            Only the right controller is allowed to interact.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_InteractableObject.ValidDropTypes">
            <summary>
            The types of valid situations that the object can be released from grab.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.ValidDropTypes.NoDrop">
            <summary>
            The object cannot be dropped via the controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.ValidDropTypes.DropAnywhere">
            <summary>
            The object can be dropped anywhere in the scene via the controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.ValidDropTypes.DropValidSnapDropZone">
            <summary>
            The object can only be dropped when it is hovering over a valid snap drop zone.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectEnabled">
            <summary>
            Emitted when the Interactable Object script is enabled;
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectDisabled">
            <summary>
            Emitted when the Interactable Object script is disabled;
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectNearTouched">
            <summary>
            Emitted when another interacting object near touches the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectNearUntouched">
            <summary>
            Emitted when the other interacting object stops near touching the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectTouched">
            <summary>
            Emitted when another interacting object touches the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectUntouched">
            <summary>
            Emitted when the other interacting object stops touching the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectGrabbed">
            <summary>
            Emitted when another interacting object grabs the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectUngrabbed">
            <summary>
            Emitted when the other interacting object stops grabbing the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectUsed">
            <summary>
            Emitted when another interacting object uses the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectUnused">
            <summary>
            Emitted when the other interacting object stops using the current Interactable Object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectEnteredSnapDropZone">
            <summary>
            Emitted when the Interactable Object enters a Snap Drop Zone.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectExitedSnapDropZone">
            <summary>
            Emitted when the Interactable Object exists a Snap Drop Zone.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectSnappedToDropZone">
            <summary>
            Emitted when the Interactable Object gets snapped to a Snap Drop Zone.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractableObject.InteractableObjectUnsnappedFromDropZone">
            <summary>
            Emitted when the Interactable Object gets unsnapped from a Snap Drop Zone.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractableObject.usingState">
            <summary>
            The current using state of the Interactable Object. `0` not being used, `1` being used.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_InteractableObject.isKinematic">
            <summary>
            isKinematic is a pass through to the `isKinematic` getter/setter on the Interactable Object's Rigidbody component.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsNearTouched">
            <summary>
            The IsNearTouched method is used to determine if the Interactable Object is currently being near touched.
            </summary>
            <returns>Returns `true` if the Interactable Object is currently being near touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsTouched">
            <summary>
            The IsTouched method is used to determine if the Interactable Object is currently being touched.
            </summary>
            <returns>Returns `true` if the Interactable Object is currently being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsGrabbed(UnityEngine.GameObject)">
            <summary>
            The IsGrabbed method is used to determine if the Interactable Object is currently being grabbed.
            </summary>
            <param name="grabbedBy">An optional GameObject to check if the Interactable Object is grabbed by that specific GameObject. Defaults to `null`</param>
            <returns>Returns `true` if the Interactable Object is currently being grabbed.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsUsing(UnityEngine.GameObject)">
            <summary>
            The IsUsing method is used to determine if the Interactable Object is currently being used.
            </summary>
            <param name="usedBy">An optional GameObject to check if the Interactable Object is used by that specific GameObject. Defaults to `null`</param>
            <returns>Returns `true` if the Interactable Object is currently being used.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StartNearTouching(VRTK.VRTK_InteractNearTouch)">
            <summary>
            The StartNearTouching method is called automatically when the Interactable Object is initially nearly touched.
            </summary>
            <param name="currentNearTouchingObject">The interacting object that is currently nearly touching this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StopNearTouching(VRTK.VRTK_InteractNearTouch)">
            <summary>
            The StopNearTouching method is called automatically when the Interactable Object has stopped being nearly touched.
            </summary>
            <param name="previousNearTouchingObject">The interacting object that was previously nearly touching this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StartTouching(VRTK.VRTK_InteractTouch)">
            <summary>
            The StartTouching method is called automatically when the Interactable Object is touched initially.
            </summary>
            <param name="currentTouchingObject">The interacting object that is currently touching this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StopTouching(VRTK.VRTK_InteractTouch)">
            <summary>
            The StopTouching method is called automatically when the Interactable Object has stopped being touched.
            </summary>
            <param name="previousTouchingObject">The interacting object that was previously touching this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.Grabbed(VRTK.VRTK_InteractGrab)">
            <summary>
            The Grabbed method is called automatically when the Interactable Object is grabbed initially.
            </summary>
            <param name="currentGrabbingObject">The interacting object that is currently grabbing this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.Ungrabbed(VRTK.VRTK_InteractGrab)">
            <summary>
            The Ungrabbed method is called automatically when the Interactable Object has stopped being grabbed.
            </summary>
            <param name="previousGrabbingObject">The interacting object that was previously grabbing this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StartUsing(VRTK.VRTK_InteractUse)">
            <summary>
            The StartUsing method is called automatically when the Interactable Object is used initially.
            </summary>
            <param name="currentUsingObject">The interacting object that is currently using this Interactable Object.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StopUsing(VRTK.VRTK_InteractUse,System.Boolean)">
            <summary>
            The StopUsing method is called automatically when the Interactable Object has stopped being used.
            </summary>
            <param name="previousUsingObject">The interacting object that was previously using this Interactable Object.</param>
            <param name="resetUsingObjectState">Resets the using object state to reset it's using action.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ToggleHighlight(System.Boolean,System.Nullable{UnityEngine.Color})">
            <summary>
            The ToggleHighlight method is used to turn on or off the highlight of the Interactable Object.
            </summary>
            <param name="toggle">The state to determine whether to activate or deactivate the highlight. `true` will enable the highlight and `false` will remove the highlight.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.Highlight(UnityEngine.Color)">
            <summary>
            The Highlight method turns on the highlighter attached to the Interactable Object with the given Color.
            </summary>
            <param name="highlightColor">The colour to apply to the highlighter.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.Unhighlight">
            <summary>
            The Unhighlight method turns off the highlighter attached to the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ResetHighlighter">
            <summary>
            The ResetHighlighter method is used to reset the currently attached highlighter.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.PauseCollisions(System.Single)">
            <summary>
            The PauseCollisions method temporarily pauses all collisions on the Interactable Object at grab time by removing the Interactable Object's Rigidbody's ability to detect collisions.
            </summary>
            <param name="delay">The time in seconds to pause the collisions for.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ZeroVelocity">
            <summary>
            The ZeroVelocity method resets the velocity and angular velocity to zero on the Rigidbody attached to the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.SaveCurrentState">
            <summary>
            The SaveCurrentState method stores the existing Interactable Object parent and the Rigidbody kinematic setting.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetPreviousState(UnityEngine.Transform@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns the previous state of the Interactable Object
            </summary>
            <param name="previousParent">Out param for the previous parent</param>
            <param name="previousKinematic">Out param for the previous Kinematic state</param>
            <param name="previousGrabbable">Out param for the previous Grabbable State</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.OverridePreviousState(UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Overrides the previous state of the Interactable Object
            </summary>
            <param name="previousParent">value of the previous parent</param>
            <param name="previousKinematic">value of the previous Kinematic state</param>
            <param name="previousGrabbable">value of the previous Grabbable State</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetNearTouchingObjects">
            <summary>
            The GetNearTouchingObjects method is used to return the collecetion of valid GameObjects that are currently nearly touching this Interactable Object.
            </summary>
            <returns>A list of GameObject of that are currently nearly touching the current Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetTouchingObjects">
            <summary>
            The GetTouchingObjects method is used to return the collecetion of valid GameObjects that are currently touching this Interactable Object.
            </summary>
            <returns>A list of GameObject of that are currently touching the current Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetGrabbingObject">
            <summary>
            The GetGrabbingObject method is used to return the GameObject that is currently grabbing this Interactable Object.
            </summary>
            <returns>The GameObject of what is grabbing the current Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetSecondaryGrabbingObject">
            <summary>
            The GetSecondaryGrabbingObject method is used to return the GameObject that is currently being used to influence this Interactable Object whilst it is being grabbed by a secondary influencing.
            </summary>
            <returns>The GameObject of the secondary influencing object of the current grabbed Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetUsingObject">
            <summary>
            The GetUsingObject method is used to return the GameObject that is currently using this Interactable Object.
            </summary>
            <returns>The GameObject of what is using the current Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetUsingScript">
            <summary>
            The GetUsingScript method is used to return the Interact Use component that is currently using this Interactable Object.
            </summary>
            <returns>The Interact Use script of the interacting object that is using the current Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsValidInteractableController(UnityEngine.GameObject,VRTK.VRTK_InteractableObject.AllowedController)">
            <summary>
            The IsValidInteractableController method is used to check to see if a controller is allowed to perform an interaction with this Interactable Object as sometimes controllers are prohibited from grabbing or using an Interactable Object depedning on the use case.
            </summary>
            <param name="actualController">The GameObject of the controller that is being checked.</param>
            <param name="controllerCheck">The value of which controller is allowed to interact with this object.</param>
            <returns>Returns `true` if the interacting controller is allowed to grab the Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ForceStopInteracting">
            <summary>
            The ForceStopInteracting method forces the Interactable Object to no longer be interacted with and will cause an interacting object to drop the Interactable Object and stop touching it.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ForceStopSecondaryGrabInteraction">
            <summary>
            The ForceStopSecondaryGrabInteraction method forces the Interactable Object to no longer be influenced by the second controller grabbing it.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.RegisterTeleporters">
            <summary>
            The RegisterTeleporters method is used to find all GameObjects that have a teleporter script and register the Interactable Object on the `OnTeleported` event.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.UnregisterTeleporters">
            <summary>
            The UnregisterTeleporters method is used to unregister all teleporter events that are active on this Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.StoreLocalScale">
            <summary>
            the StoreLocalScale method saves the current transform local scale values.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ToggleSnapDropZone(VRTK.VRTK_SnapDropZone,System.Boolean)">
            <summary>
            The ToggleSnapDropZone method is used to set the state of whether the Interactable Object is in a Snap Drop Zone or not.
            </summary>
            <param name="snapDropZone">The Snap Drop Zone object that is being interacted with.</param>
            <param name="state">The state of whether the Interactable Object is fixed in or removed from the Snap Drop Zone. `true` denotes the Interactable Object is snapped to the Snap Drop Zone and `false` denotes it has been removed from the Snap Drop Zone.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsInSnapDropZone">
            <summary>
            The IsInSnapDropZone method determines whether the Interactable Object is currently snapped to a Snap Drop Zone.
            </summary>
            <returns>Returns `true` if the Interactable Object is currently snapped in a Snap Drop Zone, returns `false` if it is not.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.SetSnapDropZoneHover(VRTK.VRTK_SnapDropZone,System.Boolean)">
            <summary>
            The SetSnapDropZoneHover method sets whether the Interactable Object is currently being hovered over a valid Snap Drop Zone.
            </summary>
            <param name="snapDropZone">The Snap Drop Zone that is being interacted with.</param>
            <param name="state">The state of whether the Interactable Object is being hovered or not.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetStoredSnapDropZone">
            <summary>
            The GetStoredSnapDropZone method returns the Snap Drop Zone that the Interactable Object is currently snapped to.
            </summary>
            <returns>The SnapDropZone that the Interactable Object is currently snapped to.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsHoveredOverSnapDropZone">
            <summary>
            The IsHoveredOverSnapDropZone method returns whether the Interactable Object is currently hovering over a Snap Drop Zone.
            </summary>
            <returns>Returns `true` if the Interactable Object is currently hovering over a Snap Drop Zone.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsDroppable">
            <summary>
            The IsDroppable method returns whether the Interactable Object can be dropped or not in it's current situation.
            </summary>
            <returns>Returns `true` if the Interactable Object can currently be dropped, returns `false` if it is not currently possible to drop.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsSwappable">
            <summary>
            The IsSwappable method returns whether the Interactable Object can be grabbed with one interacting object and then swapped to another interacting object by grabbing with the secondary grab action.
            </summary>
            <returns>Returns `true` if the Interactable Object can be grabbed by a secondary interacting object whilst already being grabbed and the Interactable Object will swap controllers. Returns `false` if the Interactable Object cannot be swapped.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.PerformSecondaryAction">
            <summary>
            The PerformSecondaryAction method returns whether the Interactable Object has a Secondary Grab Action that can be performed when grabbing the object with a secondary interacting object.
            </summary>
            <returns>Returns `true` if the Interactable Object has a Secondary Grab Action, returns `false` if it has no Secondary Grab Action or is swappable.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.ResetIgnoredColliders">
            <summary>
            The ResetIgnoredColliders method is used to clear any stored ignored colliders in case the `Ignored Colliders` array parameter is changed at runtime. This needs to be called manually if changes are made at runtime.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.SubscribeToInteractionEvent(VRTK.VRTK_InteractableObject.InteractionType,VRTK.InteractableObjectEventHandler)">
            <summary>
            The SubscribeToInteractionEvent method subscribes a given method callback for the given Interaction Type.
            </summary>
            <param name="givenType">The Interaction Type to register the events for.</param>
            <param name="methodCallback">The method to execute when the Interaction Type is initiated.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.UnsubscribeFromInteractionEvent(VRTK.VRTK_InteractableObject.InteractionType,VRTK.InteractableObjectEventHandler)">
            <summary>
            The UnsubscribeFromInteractionEvent method unsubscribes a previous event subscription for the given Interaction Type.
            </summary>
            <param name="givenType">The Interaction Type that the previous event subscription was under.</param>
            <param name="methodCallback">The method that was being executed when the Interaction Type was initiated.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetPrimaryAttachPoint">
            <summary>
            The GetPrimaryAttachPoint returns the Transform that determines where the primary grabbing object is grabbing the Interactable Object at.
            </summary>
            <returns>A Transform that denotes where the primary grabbing object is grabbing the Interactable Object at.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.GetSecondaryAttachPoint">
            <summary>
            The GetSecondaryAttachPoint returns the Transform that determines where the secondary grabbing object is grabbing the Interactable Object at.
            </summary>
            <returns>A Transform that denotes where the secondary grabbing object is grabbing the Interactable Object at.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractableObject.IsIdle">
            <summary>
            determines if this object is currently idle
            used to determine whether or not the script
            can be disabled for now
            </summary>
            <returns>whether or not the script is currently idle</returns>
        </member>
        <member name="T:VRTK.InteractControllerAppearanceEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactingObject">The object that is interacting.</param>
            <param name="ignoredObject">The object that is being ignored.</param>
        </member>
        <member name="T:VRTK.InteractControllerAppearanceEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.InteractControllerAppearanceEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractControllerAppearance">
            <summary>
            The Interact Controller Appearance script is attached on the same GameObject as an Interactable Object script and is used to determine whether the controller model should be visible or hidden on touch, grab or use.
            </summary>
            <example>
            `VRTK/Examples/008_Controller_UsingAGrabbedObject` shows that the controller can be hidden when touching, grabbing and using an object.
            </example>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.ControllerHidden">
            <summary>
            Emitted when the interacting object is hidden.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.ControllerVisible">
            <summary>
            Emitted when the interacting object is shown.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.HiddenOnTouch">
            <summary>
            Emitted when the interacting object is hidden on touch.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.VisibleOnTouch">
            <summary>
            Emitted when the interacting object is shown on untouch.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.HiddenOnGrab">
            <summary>
            Emitted when the interacting object is hidden on grab.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.VisibleOnGrab">
            <summary>
            Emitted when the interacting object is shown on ungrab.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.HiddenOnUse">
            <summary>
            Emitted when the interacting object is hidden on use.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractControllerAppearance.VisibleOnUse">
            <summary>
            Emitted when the interacting object is shown on unuse.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractControllerAppearance.ToggleControllerOnTouch(System.Boolean,UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The ToggleControllerOnTouch method determines whether the controller should be shown or hidden when touching an interactable object.
            </summary>
            <param name="showController">If true then the controller will attempt to be made visible when no longer touching, if false then the controller will be hidden on touch.</param>
            <param name="touchingObject">The touching object to apply the visibility state to.</param>
            <param name="ignoredObject">The object that is currently being interacted with by the touching object which is passed through to the visibility to prevent the object from being hidden as well.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractControllerAppearance.ToggleControllerOnGrab(System.Boolean,UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The ToggleControllerOnGrab method determines whether the controller should be shown or hidden when grabbing an interactable object.
            </summary>
            <param name="showController">If true then the controller will attempt to be made visible when no longer grabbing, if false then the controller will be hidden on grab.</param>
            <param name="grabbingObject">The grabbing object to apply the visibility state to.</param>
            <param name="ignoredObject">The object that is currently being interacted with by the grabbing object which is passed through to the visibility to prevent the object from being hidden as well.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractControllerAppearance.ToggleControllerOnUse(System.Boolean,UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The ToggleControllerOnUse method determines whether the controller should be shown or hidden when using an interactable object.
            </summary>
            <param name="showController">If true then the controller will attempt to be made visible when no longer using, if false then the controller will be hidden on use.</param>
            <param name="usingObject">The using object to apply the visibility state to.</param>
            <param name="ignoredObject">The object that is currently being interacted with by the using object which is passed through to the visibility to prevent the object from being hidden as well.</param>
        </member>
        <member name="T:VRTK.InteractHapticsEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controllerReference">The reference to the controller to perform haptics on.</param>
        </member>
        <member name="T:VRTK.InteractHapticsEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.InteractHapticsEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractHaptics">
             <summary>
             Provides controller haptics upon interaction with the specified Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractableObject` - The Interactable Object component to detect interactions on. This must be applied on the same GameObject as this script if one is not provided via the `Object To Affect` parameter.
            
             **Script Usage:**
              * Place the `VRTK_InteractHaptics` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and provide a valid `VRTK_InteractableObject` component to the `Object To Affect` parameter of this script.
             </remarks>
        </member>
        <member name="E:VRTK.VRTK_InteractHaptics.InteractHapticsNearTouched">
            <summary>
            Emitted when the haptics are from a near touch.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractHaptics.InteractHapticsTouched">
            <summary>
            Emitted when the haptics are from a touch.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractHaptics.InteractHapticsGrabbed">
            <summary>
            Emitted when the haptics are from a grab.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractHaptics.InteractHapticsUsed">
            <summary>
            Emitted when the haptics are from a use.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractHaptics.CancelHaptics(VRTK.VRTK_ControllerReference)">
            <summary>
            The CancelHaptics method cancels any existing haptic feedback on the given controller.
            </summary>
            <param name="controllerReference"></param>
        </member>
        <member name="M:VRTK.VRTK_InteractHaptics.HapticsOnNearTouch(VRTK.VRTK_ControllerReference)">
            <summary>
            The HapticsOnNearTouch method triggers the haptic feedback on the given controller for the settings associated with near touch.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractHaptics.HapticsOnTouch(VRTK.VRTK_ControllerReference)">
            <summary>
            The HapticsOnTouch method triggers the haptic feedback on the given controller for the settings associated with touch.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractHaptics.HapticsOnGrab(VRTK.VRTK_ControllerReference)">
            <summary>
            The HapticsOnGrab method triggers the haptic feedback on the given controller for the settings associated with grab.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractHaptics.HapticsOnUse(VRTK.VRTK_ControllerReference)">
            <summary>
            The HapticsOnUse method triggers the haptic feedback on the given controller for the settings associated with use.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
        </member>
        <member name="T:VRTK.InteractObjectAppearanceEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="affectingObject">The GameObject that is being affected.</param>
            <param name="monitoringObject">The Interactable Object that is being monitored.</param>
            <param name="interactionType">The type of interaction initiating the event.</param>
        </member>
        <member name="T:VRTK.InteractObjectAppearanceEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.InteractObjectAppearanceEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractObjectAppearance">
             <summary>
             Determine whether the `Object To Affect` should be visible or hidden by default or on interaction (near touch, touch, grab, use).
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractableObject` - The Interactable Object component to detect interactions on. This must be applied on the same GameObject as this script if one is not provided via the `Object To Monitor` parameter.
            
             **Script Usage:**
              * Place the `VRTK_InteractObjectAppearance` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and provide a valid `VRTK_InteractableObject` component to the `Object To Monitor` parameter of this script.
              * Optionally provide a GameObject to the `Object To Affect` parameter to determine which GameObject to affect the appearance of.
             </remarks>
             <example>
             `VRTK/Examples/008_Controller_UsingAGrabbedObject` shows that the controller can be hidden when touching, grabbing and using an object.
             </example>
        </member>
        <member name="T:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject">
            <summary>
            The valid interacting object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject.Anything">
            <summary>
            Any GameObject is considered a valid interacting object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject.EitherController">
            <summary>
            Only a game controller is considered a valid interacting objcet.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject.NeitherController">
            <summary>
            Any GameObject except a game controller is considered a valid interacting object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject.LeftControllerOnly">
            <summary>
            Only the left game controller is considered a valid interacting objcet.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_InteractObjectAppearance.ValidInteractingObject.RightControllerOnly">
            <summary>
            Only the right game controller is considered a valid interacting objcet.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectAppearance.GameObjectEnabled">
            <summary>
            Emitted when the GameObject on the `Object To Affect` is enabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectAppearance.GameObjectDisabled">
            <summary>
            Emitted when the GameObject on the `Object To Affect` is disabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectAppearance.RenderersEnabled">
            <summary>
            Emitted when the Renderers on the `Object To Affect` are enabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectAppearance.RenderersDisabled">
            <summary>
            Emitted when the Renderers on the `Object To Affect` are disabled.
            </summary>
        </member>
        <member name="T:VRTK.InteractObjectHighlighterEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="interactionType">The type of interaction occuring on the object to monitor.</param>
            <param name="highlightColor">The colour being provided to highlight the affected object with.</param>
            <param name="affectingObject">The GameObject is initiating the highlight via an interaction.</param>
            <param name="objectToMonitor">The Interactable Object that is being interacted with.</param>
            <param name="affectedObject">The GameObject that is being highlighted.</param>
        </member>
        <member name="T:VRTK.InteractObjectHighlighterEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.InteractObjectHighlighterEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractObjectHighlighter">
             <summary>
             Enable highlighting of an Interactable Object base on interaction type.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractableObject` - The Interactable Object component to detect interactions on. This must be applied on the same GameObject as this script if one is not provided via the `Object To Monitor` parameter.
            
             **Optional Components:**
              * `VRTK_BaseHighlighter` - The highlighter to use when highligting the Object. If one is not already injected in the `Object Highlighter` parameter then the component on the same GameObject will be used.
            
             **Script Usage:**
              * Place the `VRTK_InteractObjectHighlighter` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and provide a valid `VRTK_InteractableObject` component to the `Object To Affect` parameter of this script.
             </remarks>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectHighlighter.InteractObjectHighlighterHighlighted">
            <summary>
            Emitted when the object is highlighted
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractObjectHighlighter.InteractObjectHighlighterUnhighlighted">
            <summary>
            Emitted when the object is unhighlighted
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractObjectHighlighter.ResetHighlighter">
            <summary>
            The ResetHighlighter method is used to reset the currently attached highlighter.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractObjectHighlighter.Highlight(UnityEngine.Color)">
            <summary>
            The Highlight method turns on the highlighter with the given Color.
            </summary>
            <param name="highlightColor">The colour to apply to the highlighter.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractObjectHighlighter.Unhighlight">
            <summary>
            The Unhighlight method turns off the highlighter.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractObjectHighlighter.GetCurrentHighlightColor">
            <summary>
            The GetCurrentHighlightColor returns the colour that the Interactable Object is currently being highlighted to.
            </summary>
            <returns>The Color that the Interactable Object is being highlighted to.</returns>
        </member>
        <member name="T:VRTK.VRTK_ObjectTouchAutoInteract">
             <summary>
             Allows for Interact Grab or Interact Use interactions to automatically happen upon touching an Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractableObject` - The Interactable Object component to detect interactions on. This must be applied on the same GameObject as this script if one is not provided via the `Interactable Object` parameter.
            
             **Script Usage:**
              * Place the `VRTK_ObjectTouchAutoInteract` script on either:
                * The GameObject of the Interactable Object to detect interactions on.
                * Any other scene GameObject and provide a valid `VRTK_InteractableObject` component to the `Interactable Object` parameter of this script.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_ObjectTouchAutoInteract.AutoInteractions">
            <summary>
            Situation when auto interaction can occur.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectTouchAutoInteract.AutoInteractions.Never">
            <summary>
            Auto interaction can never occur on touch.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectTouchAutoInteract.AutoInteractions.NoButtonHeld">
            <summary>
            Auto interaction will occur on touch even if the specified interaction button is not held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectTouchAutoInteract.AutoInteractions.ButtonHeld">
            <summary>
            Auto interaction will only occur on touch if the specified interaction button is held down.
            </summary>
        </member>
        <member name="T:VRTK.ControllerInteractionEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controllerReference">The reference for the controller that initiated the event.</param>
            <param name="buttonPressure">The amount of pressure being applied to the button pressed. `0f` to `1f`.</param>
            <param name="touchpadAxis">The position the touchpad is touched at. `(0,0)` to `(1,1)`.</param>
            <param name="touchpadAngle">The rotational position the touchpad is being touched at, 0 being top, 180 being bottom and all other angles accordingly. `0f` to `360f`.</param>
            <param name="touchpadTwoAxis">The position the touchpad two is touched at. `(0,0)` to `(1,1)`.</param>
            <param name="touchpadTwoAngle">The rotational position the touchpad two is being touched at, 0 being top, 180 being bottom and all other angles accordingly. `0f` to `360f`.</param>
        </member>
        <member name="T:VRTK.ControllerInteractionEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ControllerInteractionEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_ControllerEvents">
            <summary>
            A relationship to a physical VR controller and emits events based on the inputs of the controller.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_ControllerEvents` script on the controller script alias GameObject of the controller to track (e.g. Right Controller Script Alias).
            </remarks>
            <example>
            `VRTK/Examples/002_Controller_Events` shows how the events are utilised and listened to. The accompanying example script can be viewed in `VRTK/Examples/ExampleResources/Scripts/VRTK_ControllerEvents_ListenerExample.cs`.
            </example>
        </member>
        <member name="T:VRTK.VRTK_ControllerEvents.ButtonAlias">
            <summary>
            Button types
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.Undefined">
            <summary>
            No button specified.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TriggerHairline">
            <summary>
            The trigger is squeezed past the current hairline threshold.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TriggerTouch">
            <summary>
            The trigger is squeezed a small amount.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TriggerPress">
            <summary>
            The trigger is squeezed about half way in.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TriggerClick">
            <summary>
            The trigger is squeezed all the way down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripHairline">
            <summary>
            The grip is squeezed past the current hairline threshold.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripTouch">
            <summary>
            The grip button is touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripPress">
            <summary>
            The grip button is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripClick">
            <summary>
            The grip button is pressed all the way down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TouchpadTouch">
            <summary>
            The touchpad is touched (without pressing down to click).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TouchpadPress">
            <summary>
            The touchpad is pressed (to the point of hearing a click).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TouchpadTwoTouch">
            <summary>
            The touchpad two is touched (without pressing down to click).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TouchpadTwoPress">
            <summary>
            The touchpad two is pressed (to the point of hearing a click).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.ButtonOneTouch">
            <summary>
            The button one is touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.ButtonOnePress">
            <summary>
            The button one is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.ButtonTwoTouch">
            <summary>
            The button two is touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.ButtonTwoPress">
            <summary>
            The button two is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.StartMenuPress">
            <summary>
            The start menu is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TouchpadSense">
            <summary>
            The touchpad sense touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.TriggerSense">
            <summary>
            The trigger sense touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.MiddleFingerSense">
            <summary>
            The middle finger sense touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.RingFingerSense">
            <summary>
            The ring finger sense touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.PinkyFingerSense">
            <summary>
            The pinky finger sense touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripSense">
            <summary>
            The grip sense axis touch is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ButtonAlias.GripSensePress">
            <summary>
            The grip sense axis is pressed.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_ControllerEvents.Vector2AxisAlias">
            <summary>
            Vector2 Axis Types.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.Vector2AxisAlias.Undefined">
            <summary>
            No axis specified.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.Vector2AxisAlias.Touchpad">
            <summary>
            Touchpad on the controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.Vector2AxisAlias.TouchpadTwo">
            <summary>
            Touchpad Two on the controller.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_ControllerEvents.AxisType">
            <summary>
            Axis Types
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.AxisType.Digital">
            <summary>
            A digital axis with a binary result of 0f not pressed or 1f is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.AxisType.Axis">
            <summary>
            An analog axis ranging from no squeeze at 0f to full squeeze at 1f.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.AxisType.SenseAxis">
            <summary>
            A cap sens axis ranging from not near at 0f to touching at 1f.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerPressed">
            <summary>
            This will be true if the trigger is squeezed about half way in.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerTouched">
            <summary>
            This will be true if the trigger is squeezed a small amount.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerHairlinePressed">
            <summary>
            This will be true if the trigger is squeezed a small amount more from any previous squeeze on the trigger.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerClicked">
            <summary>
            This will be true if the trigger is squeezed all the way down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerAxisChanged">
            <summary>
            This will be true if the trigger has been squeezed more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.triggerSenseAxisChanged">
            <summary>
            This will be true if the trigger sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripPressed">
            <summary>
            This will be true if the grip is squeezed about half way in.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripTouched">
            <summary>
            This will be true if the grip is touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripHairlinePressed">
            <summary>
            This will be true if the grip is squeezed a small amount more from any previous squeeze on the grip.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripClicked">
            <summary>
            This will be true if the grip is squeezed all the way down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripAxisChanged">
            <summary>
            This will be true if the grip has been squeezed more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadPressed">
            <summary>
            This will be true if the touchpad is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadTouched">
            <summary>
            This will be true if the touchpad is being touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadAxisChanged">
            <summary>
            This will be true if the touchpad position has changed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadSenseAxisChanged">
            <summary>
            This will be true if the touchpad sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadTwoTouched">
            <summary>
            This will be true if the touchpad two is being touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadTwoPressed">
            <summary>
            This will be true if the touchpad two is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.touchpadTwoAxisChanged">
            <summary>
            This will be true if the touchpad two position has changed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.buttonOnePressed">
            <summary>
            This will be true if button one is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.buttonOneTouched">
            <summary>
            This will be true if button one is being touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.buttonTwoPressed">
            <summary>
            This will be true if button two is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.buttonTwoTouched">
            <summary>
            This will be true if button two is being touched.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.startMenuPressed">
            <summary>
            This will be true if start menu is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.middleFingerSenseAxisChanged">
            <summary>
            This will be true if the middle finger sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.ringFingerSenseAxisChanged">
            <summary>
            This will be true if the ring finger sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.pinkyFingerSenseAxisChanged">
            <summary>
            This will be true if the pinky finger sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripSenseAxisChanged">
            <summary>
            This will be true if the grip sense is being touched more or less.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.gripSensePressed">
            <summary>
            This will be true if grip sense is held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ControllerEvents.controllerVisible">
            <summary>
            This will be true if the controller model alias renderers are visible.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerPressed">
            <summary>
            Emitted when the trigger is squeezed about half way in.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerReleased">
            <summary>
            Emitted when the trigger is released under half way.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerTouchStart">
            <summary>
            Emitted when the trigger is squeezed a small amount.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerTouchEnd">
            <summary>
            Emitted when the trigger is no longer being squeezed at all.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerHairlineStart">
            <summary>
            Emitted when the trigger is squeezed past the current hairline threshold.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerHairlineEnd">
            <summary>
            Emitted when the trigger is released past the current hairline threshold.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerClicked">
            <summary>
            Emitted when the trigger is squeezed all the way down.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerUnclicked">
            <summary>
            Emitted when the trigger is no longer being held all the way down.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerAxisChanged">
            <summary>
            Emitted when the amount of squeeze on the trigger changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TriggerSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the trigger sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripPressed">
            <summary>
            Emitted when the grip is squeezed about half way in.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripReleased">
            <summary>
            Emitted when the grip is released under half way.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripTouchStart">
            <summary>
            Emitted when the grip is squeezed a small amount.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripTouchEnd">
            <summary>
            Emitted when the grip is no longer being squeezed at all.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripHairlineStart">
            <summary>
            Emitted when the grip is squeezed past the current hairline threshold.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripHairlineEnd">
            <summary>
            Emitted when the grip is released past the current hairline threshold.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripClicked">
            <summary>
            Emitted when the grip is squeezed all the way down.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripUnclicked">
            <summary>
            Emitted when the grip is no longer being held all the way down.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripAxisChanged">
            <summary>
            Emitted when the amount of squeeze on the grip changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadPressed">
            <summary>
            Emitted when the touchpad is pressed (to the point of hearing a click).
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadReleased">
            <summary>
            Emitted when the touchpad has been released after a pressed state.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTouchStart">
            <summary>
            Emitted when the touchpad is touched (without pressing down to click).
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTouchEnd">
            <summary>
            Emitted when the touchpad is no longer being touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadAxisChanged">
            <summary>
            Emitted when the touchpad is being touched in a different location.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the touchpad sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTwoPressed">
            <summary>
            Emitted when the touchpad two is pressed (to the point of hearing a click).
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTwoReleased">
            <summary>
            Emitted when the touchpad two has been released after a pressed state.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTwoTouchStart">
            <summary>
            Emitted when the touchpad two is touched (without pressing down to click).
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTwoTouchEnd">
            <summary>
            Emitted when the touchpad two is no longer being touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.TouchpadTwoAxisChanged">
            <summary>
            Emitted when the touchpad two is being touched in a different location.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonOneTouchStart">
            <summary>
            Emitted when button one is touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonOneTouchEnd">
            <summary>
            Emitted when button one is no longer being touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonOnePressed">
            <summary>
            Emitted when button one is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonOneReleased">
            <summary>
            Emitted when button one is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonTwoTouchStart">
            <summary>
            Emitted when button two is touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonTwoTouchEnd">
            <summary>
            Emitted when button two is no longer being touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonTwoPressed">
            <summary>
            Emitted when button two is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ButtonTwoReleased">
            <summary>
            Emitted when button two is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.StartMenuPressed">
            <summary>
            Emitted when start menu is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.StartMenuReleased">
            <summary>
            Emitted when start menu is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.MiddleFingerSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the middle finger sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.RingFingerSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the ring finger sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.PinkyFingerSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the pinky finger sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripSenseAxisChanged">
            <summary>
            Emitted when the amount of touch on the grip sense changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripSensePressed">
            <summary>
            Emitted when grip sense is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.GripSenseReleased">
            <summary>
            Emitted when grip sense is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerEnabled">
            <summary>
            Emitted when the controller is enabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerDisabled">
            <summary>
            Emitted when the controller is disabled.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerIndexChanged">
            <summary>
            Emitted when the controller index changed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerModelAvailable">
            <summary>
            Emitted when the controller model becomes available.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerVisible">
            <summary>
            Emitted when the controller is set to visible.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ControllerEvents.ControllerHidden">
            <summary>
            Emitted when the controller is set to hidden.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.SetControllerEvent">
            <summary>
            The SetControllerEvent/0 method is used to set the Controller Event payload.
            </summary>
            <returns>The payload for a Controller Event.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.SetControllerEvent(System.Boolean@,System.Boolean,System.Single)">
            <summary>
            The SetControllerEvent/3 method is used to set the Controller Event payload.
            </summary>
            <param name="buttonBool">The state of the pressed button if required.</param>
            <param name="value">The value to set the `buttonBool` reference to.</param>
            <param name="buttonPressure">The pressure of the button pressed if required.</param>
            <returns>The payload for a Controller Event.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetControllerType">
            <summary>
            The GetControllerType method is a shortcut to retrieve the current controller type the Controller Events is attached to.
            </summary>
            <returns>The type of controller that the Controller Events is attached to.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetAxis(VRTK.VRTK_ControllerEvents.Vector2AxisAlias)">
            <summary>
            The GetAxis method returns the coordinates of where the given axis type is being touched.
            </summary>
            <param name="vector2AxisType">The Vector2AxisType to check the touch position of.</param>
            <returns>A two dimensional vector containing the `x` and `y` position of where the given axis type is being touched. `(0,0)` to `(1,1)`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTouchpadAxis">
            <summary>
            The GetTouchpadAxis method returns the coordinates of where the touchpad is being touched and can be used for directional input via the touchpad. The `x` value is the horizontal touch plane and the `y` value is the vertical touch plane.
            </summary>
            <returns>A two dimensional vector containing the `x` and `y` position of where the touchpad is being touched. `(0,0)` to `(1,1)`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTouchpadTwoAxis">
            <summary>
            The GetTouchpadTwoAxis method returns the coordinates of where the touchpad two is being touched and can be used for directional input via the touchpad two. The `x` value is the horizontal touch plane and the `y` value is the vertical touch plane.
            </summary>
            <returns>A two dimensional vector containing the `x` and `y` position of where the touchpad two is being touched. `(0,0)` to `(1,1)`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetAxisAngle(VRTK.VRTK_ControllerEvents.Vector2AxisAlias)">
            <summary>
            The GetAxisAngle method returns the angle of where the given axis type is currently being touched with the top of the given axis type being `0` degrees and the bottom of the given axis type being `180` degrees.
            </summary>
            <param name="vector2AxisType">The Vector2AxisType to get the touch angle for.</param>
            <returns>A float representing the angle of where the given axis type is being touched. `0f` to `360f`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTouchpadAxisAngle">
            <summary>
            The GetTouchpadAxisAngle method returns the angle of where the touchpad is currently being touched with the top of the touchpad being `0` degrees and the bottom of the touchpad being `180` degrees.
            </summary>
            <returns>A float representing the angle of where the touchpad is being touched. `0f` to `360f`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTouchpadTwoAxisAngle">
            <summary>
            The GetTouchpadTwoAxisAngle method returns the angle of where the touchpad two is currently being touched with the top of the touchpad two being `0` degrees and the bottom of the touchpad two being `180` degrees.
            </summary>
            <returns>A float representing the angle of where the touchpad two is being touched. `0f` to `360f`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTriggerAxis">
            <summary>
            The GetTriggerAxis method returns a float that represents how much the trigger is being squeezed. This can be useful for using the trigger axis to perform high fidelity tasks or only activating the trigger press once it has exceeded a given press threshold.
            </summary>
            <returns>A float representing the amount of squeeze that is being applied to the trigger. `0f` to `1f`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetGripAxis">
            <summary>
            The GetGripAxis method returns a float that represents how much the grip is being squeezed. This can be useful for using the grip axis to perform high fidelity tasks or only activating the grip press once it has exceeded a given press threshold.
            </summary>
            <returns>A float representing the amount of squeeze that is being applied to the grip. `0f` to `1f`.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetHairTriggerDelta">
            <summary>
            The GetHairTriggerDelta method returns a float representing the difference in how much the trigger is being pressed in relation to the hairline threshold start.
            </summary>
            <returns>A float representing the difference in the trigger pressure from the hairline threshold start to current position.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetHairGripDelta">
            <summary>
            The GetHairTriggerDelta method returns a float representing the difference in how much the trigger is being pressed in relation to the hairline threshold start.
            </summary>
            <returns>A float representing the difference in the trigger pressure from the hairline threshold start to current position.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTouchpadSenseAxis">
            <summary>
            The GetTouchpadSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetTriggerSenseAxis">
            <summary>
            The GetTriggerSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetMiddleFingerSenseAxis">
            <summary>
            The GetMiddleFingerSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetRingFingerSenseAxis">
            <summary>
            The GetRingFingerSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetPinkyFingerSenseAxis">
            <summary>
            The GetPinkyFingerSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetGripSenseAxis">
            <summary>
            The GetGripSenseAxis method returns a float representing how much of the touch sensor is being touched.
            </summary>
            <returns>A float representing how much the touch sensor is being touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.AnyButtonPressed">
            <summary>
            The AnyButtonPressed method returns true if any of the controller buttons are being pressed and this can be useful to determine if an action can be taken whilst the user is using the controller.
            </summary>
            <returns>Returns `true` if any of the controller buttons are currently being pressed.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.GetAxisState(VRTK.VRTK_ControllerEvents.Vector2AxisAlias,VRTK.SDK_BaseController.ButtonPressTypes)">
            <summary>
            The GetAxisState method takes a given Vector2Axis and returns a boolean whether that given axis is currently being touched or pressed.
            </summary>
            <param name="axis">The axis to check on.</param>
            <param name="pressType">The button press type to check for.</param>
            <returns>Returns `true` if the axis is being interacted with via the given press type.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.IsButtonPressed(VRTK.VRTK_ControllerEvents.ButtonAlias)">
            <summary>
            The IsButtonPressed method takes a given button alias and returns a boolean whether that given button is currently being pressed or not.
            </summary>
            <param name="button">The button to check if it's being pressed.</param>
            <returns>Returns `true` if the button is being pressed.</returns>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.SubscribeToButtonAliasEvent(VRTK.VRTK_ControllerEvents.ButtonAlias,System.Boolean,VRTK.ControllerInteractionEventHandler)">
            <summary>
            The SubscribeToButtonAliasEvent method makes it easier to subscribe to a button event on either the start or end action. Upon the event firing, the given callback method is executed.
            </summary>
            <param name="givenButton">The Button Alias to register the event on.</param>
            <param name="startEvent">If this is `true` then the start event related to the button is used (e.g. `OnPress`). If this is `false` then the end event related to the button is used (e.g. `OnRelease`). </param>
            <param name="callbackMethod">The method to subscribe to the event.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.UnsubscribeToButtonAliasEvent(VRTK.VRTK_ControllerEvents.ButtonAlias,System.Boolean,VRTK.ControllerInteractionEventHandler)">
            <summary>
            The UnsubscribeToButtonAliasEvent method makes it easier to unsubscribe to from button event on either the start or end action.
            </summary>
            <param name="givenButton">The Button Alias to unregister the event on.</param>
            <param name="startEvent">If this is `true` then the start event related to the button is used (e.g. `OnPress`). If this is `false` then the end event related to the button is used (e.g. `OnRelease`). </param>
            <param name="callbackMethod">The method to unsubscribe from the event.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.SubscribeToAxisAliasEvent(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerEvents.AxisType,VRTK.ControllerInteractionEventHandler)">
            <summary>
            The SubscribeToAxisAliasEvent method makes it easier to subscribe to axis changes on a given button for a given axis type.
            </summary>
            <param name="buttonType">The button to listen for axis changes on.</param>
            <param name="axisType">The type of axis change to listen for.</param>
            <param name="callbackMethod">The method to subscribe to the event.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerEvents.UnsubscribeToAxisAliasEvent(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerEvents.AxisType,VRTK.ControllerInteractionEventHandler)">
            <summary>
            The UnsubscribeToAxisAliasEvent method makes it easier to unsubscribe from axis changes on a given button for a given axis type.
            </summary>
            <param name="buttonType">The button to unregister for axis changes on.</param>
            <param name="axisType">The type of axis change to unregister on.</param>
            <param name="callbackMethod">The method to unsubscribe from the event.</param>
        </member>
        <member name="T:VRTK.VRTK_ControllerHighlighter">
             <summary>
             Enables highlighting of controller elements.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_BaseHighlighter` - The highlighter to use when highligting the controller. If one is not already injected in the `Controller Highlighter` parameter then the component on the same GameObject will be used.
            
             **Script Usage:**
              * Place the `VRTK_ControllerHighlighter` script on either:
                * The controller script alias GameObject of the controller to affect (e.g. Right Controller Script Alias).
                * Any other scene GameObject and provide the controller script alias GameObject to the `Controller Alias` parameter of this script.
              * The Model Element Paths will be auto populated at runtime based on the SDK Setup Model Alias being used (except if a custom Model Alias for the SDK Setup is provided).
              * The Highlighter used by the Controller Highlighter will be selected in the following order:
                * The provided Base Highlighter in the `Controller Highlighter` parameter.
                * If the above is not provided, then the first active Base Highlighter found on the actual controller GameObject will be used.
                * If the above is not found, then a Material Color Swap Highlighter will be created on the actual controller GameObject at runtime.
             </remarks>
             <example>
             `VRTK/Examples/035_Controller_OpacityAndHighlighting` demonstrates the ability to change the opacity of a controller model and to highlight specific elements of a controller such as the buttons or even the entire controller model.
             </example>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.ConfigureControllerPaths">
            <summary>
            The ConfigureControllerPaths method is used to set up the model element paths.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.PopulateHighlighters">
            <summary>
            The PopulateHighlighters method sets up the highlighters on the controller model.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.HighlightController(UnityEngine.Color,System.Single)">
            <summary>
            The HighlightController method attempts to highlight all sub models of the controller.
            </summary>
            <param name="color">The Color to highlight the controller to.</param>
            <param name="fadeDuration">The duration in seconds to fade from the initial color to the target color.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.UnhighlightController">
            <summary>
            The UnhighlightController method attempts to remove the highlight from all sub models of the controller.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.HighlightElement(VRTK.SDK_BaseController.ControllerElements,UnityEngine.Color,System.Single)">
            <summary>
            The HighlightElement method attempts to highlight a specific controller element.
            </summary>
            <param name="elementType">The element type on the controller.</param>
            <param name="color">The Color to highlight the controller element to.</param>
            <param name="fadeDuration">The duration in seconds to fade from the initial color to the target color.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerHighlighter.UnhighlightElement(VRTK.SDK_BaseController.ControllerElements)">
            <summary>
            The UnhighlightElement method attempts to remove the highlight from the specific controller element.
            </summary>
            <param name="elementType">The element type on the controller.</param>
        </member>
        <member name="T:VRTK.VRTK_ControllerTrackedCollider">
             <summary>
             Provides a controller collider collection that follows the controller rigidbody via the physics system.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractTouch` - An Interact Touch script to determine which controller rigidbody to follow.
            
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied in the same object hierarchy as the Interact Touch script if one is not provided via the `Controller Events` parameter.
            
             **Script Usage:**
              * Place the `VRTK_ControllerTrackedCollider` script on any active scene GameObject except the Script Alias objects.
              * Assign the controller to track by applying an Interact Touch to the relevant Script Alias and then providing that reference to the `Interact Touch` parameter on this script.
             </remarks>
        </member>
        <member name="M:VRTK.VRTK_ControllerTrackedCollider.ToggleColliders(System.Boolean)">
            <summary>
            The ToggleColliders method toggles the collision state of the tracked colliders.
            </summary>
            <param name="state">If `true` then the tracked colliders will be able to affect other Rigidbodies.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerTrackedCollider.TrackedColliders">
            <summary>
            The TrackedColliders method returns an array of the tracked colliders.
            </summary>
            <returns>A Collider array of the tracked colliders.</returns>
        </member>
        <member name="T:VRTK.VRTK_InteractGrab">
             <summary>
             Determines if the Interact Touch can initiate a grab with the touched Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractTouch` - The touch component to determine when a valid touch has taken place to denote a grab can occur. This must be applied on the same GameObject as this script if one is not provided via the `Interact Touch` parameter.
            
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the `Controller Events` parameter.
            
             **Script Usage:**
              * Place the `VRTK_InteractGrab` script on either:
                * The GameObject with the Interact Touch and Controller Events scripts.
                * Any other scene GameObject and provide a valid `VRTK_ControllerEvents` component to the `Controller Events` parameter and a valid `VRTK_InteractTouch` component to the `Interact Touch` parameter of this script.
             </remarks>
             <example>
             `VRTK/Examples/005_Controller/BasicObjectGrabbing` demonstrates the grabbing of interactable objects that have the `VRTK_InteractableObject` script attached to them. The objects can be picked up and thrown around.
            
             `VRTK/Examples/013_Controller_UsingAndGrabbingMultipleObjects` demonstrates that each controller can grab and use objects independently and objects can also be toggled to their use state simultaneously.
            
             `VRTK/Examples/014_Controller_SnappingObjectsOnGrab` demonstrates the different mechanisms for snapping a grabbed object to the controller.
             </example>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.GrabButtonPressed">
            <summary>
            Emitted when the grab button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.GrabButtonReleased">
            <summary>
            Emitted when the grab button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.ControllerStartGrabInteractableObject">
            <summary>
            Emitted when a grab of a valid object is started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.ControllerGrabInteractableObject">
            <summary>
            Emitted when a valid object is grabbed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.ControllerStartUngrabInteractableObject">
            <summary>
            Emitted when a ungrab of a valid object is started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractGrab.ControllerUngrabInteractableObject">
            <summary>
            Emitted when a valid object is released from being grabbed.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractGrab.IsGrabButtonPressed">
            <summary>
            The IsGrabButtonPressed method determines whether the current grab alias button is being pressed down.
            </summary>
            <returns>Returns `true` if the grab alias button is being held down.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractGrab.ForceRelease(System.Boolean)">
            <summary>
            The ForceRelease method will force the Interact Grab to stop grabbing the currently grabbed Interactable Object.
            </summary>
            <param name="applyGrabbingObjectVelocity">If this is true then upon releasing the Interactable Object any velocity on the Interact Touch GameObject will be applied to the Interactable Object to essentiall throw it. Defaults to `false`.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractGrab.AttemptGrab">
            <summary>
            The AttemptGrab method will attempt to grab the currently touched Interactable Object without needing to press the grab button on the controller.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractGrab.GetGrabbedObject">
            <summary>
            The GetGrabbedObject method returns the current Interactable Object being grabbed by the this Interact Grab.
            </summary>
            <returns>The game object of what is currently being grabbed by this controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractGrab.ForceControllerAttachPoint(UnityEngine.Rigidbody)">
            <summary>
            The ForceControllerAttachPoint method updates the rigidbody being used as the controller grab attach position.
            </summary>
            <param name="forcedAttachPoint">The rigidbody to use as the controller attach point.</param>
        </member>
        <member name="T:VRTK.VRTK_InteractNearTouch">
             <summary>
             Determines if a GameObject can initiate a near touch with an Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractTouch` - The touch component to determine the actual interacting GameObject that will deal with the near touch interaction. This must be applied on the same GameObject as this script if one is not provided via the `Interact Touch` parameter.
            
             **Script Usage:**
              * Place the `VRTK_InteractNearTouch` script on either:
                * The Interact Touch GameObject.
                * Any other scene GameObject and provide a valid `VRTK_InteractTouch` component to the `Interact Touch` parameter of this script.
             </remarks>
        </member>
        <member name="E:VRTK.VRTK_InteractNearTouch.ControllerNearTouchInteractableObject">
            <summary>
            Emitted when a valid object is near touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractNearTouch.ControllerNearUntouchInteractableObject">
            <summary>
            Emitted when a valid object is no longer being near touched.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractNearTouch.GetNearTouchedObjects">
            <summary>
            The GetNearTouchedObjects method returns all of the GameObjects that are currently being near touched.
            </summary>
            <returns>A list of GameObjects that are being near touched.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractNearTouch.ForceNearTouch(UnityEngine.GameObject)">
            <summary>
            The ForceNearTouch method will attempt to force the controller to near touch the given GameObject.
            </summary>
            <param name="obj">The GameObject to attempt to force near touch.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractNearTouch.ForceStopNearTouching(UnityEngine.GameObject)">
            <summary>
            The ForceStopNearTouching method will stop the Interact Touch GameObject from near touching an Interactable Object even if the Interact Touch GameObject is physically touching the Interactable Object still.
            </summary>
            <param name="obj">An optional GameObject to only include in the force stop. If this is null then all near touched GameObjects will be force stopped.</param>
        </member>
        <member name="T:VRTK.ObjectInteractEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controllerReference">The reference to the controller doing the interaction.</param>
            <param name="target">The GameObject of the Interactable Object that is being interacted with.</param>
        </member>
        <member name="T:VRTK.ObjectInteractEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ObjectInteractEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_InteractTouch">
             <summary>
             Determines if a GameObject can initiate a touch with an Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `Rigidbody` - A Unity kinematic Rigidbody to determine when collisions happen between the Interact Touch GameObject and other valid colliders.
            
             **Script Usage:**
              * Place the `VRTK_InteractTouch` script on the controller script alias GameObject of the controller to track (e.g. Right Controller Script Alias).
             </remarks>
             <example>
             `VRTK/Examples/005_Controller/BasicObjectGrabbing` demonstrates the highlighting of objects that have the `VRTK_InteractableObject` script added to them to show the ability to highlight interactable objects when they are touched by the controllers.
             </example>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerStartTouchInteractableObject">
            <summary>
            Emitted when the touch of a valid object has started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerTouchInteractableObject">
            <summary>
            Emitted when a valid object is touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerStartUntouchInteractableObject">
            <summary>
            Emitted when the untouch of a valid object has started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerUntouchInteractableObject">
            <summary>
            Emitted when a valid object is no longer being touched.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerRigidbodyActivated">
            <summary>
            Emitted when the controller rigidbody is activated.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractTouch.ControllerRigidbodyDeactivated">
            <summary>
            Emitted when the controller rigidbody is deactivated.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.ForceTouch(UnityEngine.GameObject)">
            <summary>
            The ForceTouch method will attempt to force the Interact Touch onto the given GameObject.
            </summary>
            <param name="obj">The GameObject to attempt to force touch.</param>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.GetTouchedObject">
            <summary>
            The GetTouchedObject method returns the current GameObject being touched by the Interact Touch.
            </summary>
            <returns>The GameObject of what is currently being touched by this Interact Touch.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.IsObjectInteractable(UnityEngine.GameObject)">
            <summary>
            The IsObjectInteractable method is used to check if a given GameObject is a valid Interactable Object.
            </summary>
            <param name="obj">The GameObject to check to see if it's a valid Interactable Object.</param>
            <returns>Returns `true` if the given GameObjectis a valid Interactable Object.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.ToggleControllerRigidBody(System.Boolean,System.Boolean)">
            <summary>
            The ToggleControllerRigidBody method toggles the Interact Touch rigidbody's ability to detect collisions. If it is true then the controller rigidbody will collide with other collidable GameObjects.
            </summary>
            <param name="state">The state of whether the rigidbody is on or off. `true` toggles the rigidbody on and `false` turns it off.</param>
            <param name="forceToggle">Determines if the rigidbody has been forced into it's new state by another script. This can be used to override other non-force settings. Defaults to `false`</param>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.IsRigidBodyActive">
            <summary>
            The IsRigidBodyActive method checks to see if the rigidbody on the Interact Touch is active and can affect other rigidbodies in the scene.
            </summary>
            <returns>Returns `true` if the rigidbody on the Interact Touch is currently active and able to affect other scene rigidbodies.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.IsRigidBodyForcedActive">
            <summary>
            The IsRigidBodyForcedActive method checks to see if the rigidbody on the Interact Touch has been forced into the active state.
            </summary>
            <returns>Returns `true` if the rigidbody is active and has been forced into the active state.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.ForceStopTouching">
            <summary>
            The ForceStopTouching method will stop the Interact Touch from touching an Interactable Object even if the Interact Touch is physically touching the Interactable Object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.ControllerColliders">
            <summary>
            The ControllerColliders method retrieves all of the associated colliders on the Interact Touch.
            </summary>
            <returns>An array of colliders that are associated with the controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractTouch.GetControllerType">
            <summary>
            The GetControllerType method is a shortcut to retrieve the current controller type the Interact Touch is attached to.
            </summary>
            <returns>The type of controller that the Interact Touch is attached to.</returns>
        </member>
        <member name="T:VRTK.VRTK_InteractUse">
             <summary>
             Determines if the Interact Touch can initiate a use interaction with the touched Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractTouch` - The touch component to determine when a valid touch has taken place to denote a use interaction can occur. This must be applied on the same GameObject as this script if one is not provided via the `Interact Touch` parameter.
            
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the `Controller Events` parameter.
              * `VRTK_InteractGrab` - The grab component to determine when a valid grab has taken place. This must be applied on the same GameObject as this script if one is not provided via the `Interact Grab` parameter.
            
             **Script Usage:**
              * Place the `VRTK_InteractUse` script on either:
                * The GameObject with the Interact Touch and Controller Events scripts.
                * Any other scene GameObject and provide a valid `VRTK_ControllerEvents` component to the `Controller Events` parameter and a valid `VRTK_InteractTouch` component to the `Interact Touch` parameter of this script.
             </remarks>
             <example>
             `VRTK/Examples/006_Controller_UsingADoor` simulates using a door object to open and close it. It also has a cube on the floor that can be grabbed to show how interactable objects can be usable or grabbable.
            
             `VRTK/Examples/008_Controller_UsingAGrabbedObject` shows that objects can be grabbed with one button and used with another (e.g. firing a gun).
             </example>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.UseButtonPressed">
            <summary>
            Emitted when the use toggle alias button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.UseButtonReleased">
            <summary>
            Emitted when the use toggle alias button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.ControllerStartUseInteractableObject">
            <summary>
            Emitted when a use of a valid object is started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.ControllerUseInteractableObject">
            <summary>
            Emitted when a valid object starts being used.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.ControllerStartUnuseInteractableObject">
            <summary>
            Emitted when a unuse of a valid object is started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_InteractUse.ControllerUnuseInteractableObject">
            <summary>
            Emitted when a valid object stops being used.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractUse.IsUseButtonPressed">
            <summary>
            The IsUsebuttonPressed method determines whether the current use alias button is being pressed down.
            </summary>
            <returns>Returns `true` if the use alias button is being held down.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractUse.GetUsingObject">
            <summary>
            The GetUsingObject method returns the current GameObject being used by the Interact Use.
            </summary>
            <returns>The GameObject of what is currently being used by this Interact Use.</returns>
        </member>
        <member name="M:VRTK.VRTK_InteractUse.ForceStopUsing">
            <summary>
            The ForceStopUsing method will force the Interact Use to stop using the currently touched Interactable Object and will also stop the Interactable Object's using action.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractUse.ForceResetUsing">
            <summary>
            The ForceResetUsing will force the Interact Use to stop using the currently touched Interactable Object but the Interactable Object will continue with it's existing using action.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_InteractUse.AttemptUse">
            <summary>
            The AttemptUse method will attempt to use the currently touched Interactable Object without needing to press the use button on the controller.
            </summary>
        </member>
        <member name="T:VRTK.ObjectAutoGrabEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
        </member>
        <member name="T:VRTK.VRTK_ObjectAutoGrab">
             <summary>
             Attempt to automatically grab a specified Interactable Object.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_InteractTouch` - The touch component to determine when a valid touch has taken place to denote a use interaction can occur. This must be applied on the same GameObject as this script if one is not provided via the `Interact Touch` parameter.
              * `VRTK_InteractGrab` - The grab component to determine when a valid grab has taken place. This must be applied on the same GameObject as this script if one is not provided via the `Interact Grab` parameter.
            
             **Script Usage:**
              * Place the `VRTK_ObjectAutoGrab` script on either:
                * The GameObject that contains the Interact Touch and Interact Grab scripts.
                * Any other scene GameObject and provide a valid `VRTK_InteractTouch` component to the `Interact Touch` parameter and a valid `VRTK_InteractGrab` component to the `Interact Grab` parameter of this script.
             * Assign the Interactable Object to auto grab to the `Object To Grab` parameter on this script.
               * If this Interactable Object is a prefab then the `Object Is Prefab` parameter on this script must be checked.
             </remarks>
             <example>
             `VRTK/Examples/026_Controller_ForceHoldObject` shows how to automatically grab a sword to each controller and also prevents the swords from being dropped so they are permanently attached to the user's controllers.
             </example>
        </member>
        <member name="E:VRTK.VRTK_ObjectAutoGrab.ObjectAutoGrabCompleted">
            <summary>
            Emitted when the object auto grab has completed successfully.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ObjectAutoGrab.ClearPreviousClone">
            <summary>
            The ClearPreviousClone method resets the previous cloned Interactable Object to null to ensure when the script is re-enabled that a new cloned Interactable Object is created, rather than the original clone being grabbed again.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_ControllerHaptics">
            <summary>
            A collection of static methods for calling haptic functions on a given controller.
            </summary>
            <remarks>
            **Script Usage:**
              > There is no requirement to add this script to a GameObject as all of the public methods are static and can be called directly e.g. `VRTK_ControllerHaptics.TriggerHapticPulse(ref, 1f)`.
            </remarks>
        </member>
        <member name="M:VRTK.VRTK_ControllerHaptics.TriggerHapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The TriggerHapticPulse/2 method calls a single haptic pulse call on the controller for a single tick.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerHaptics.TriggerHapticPulse(VRTK.VRTK_ControllerReference,System.Single,System.Single,System.Single)">
            <summary>
            The TriggerHapticPulse/4 method calls a haptic pulse for a specified amount of time rather than just a single tick. Each pulse can be separated by providing a `pulseInterval` to pause between each haptic pulse.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
            <param name="duration">The length of time the rumble should continue for.</param>
            <param name="pulseInterval">The interval to wait between each haptic pulse.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerHaptics.TriggerHapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The TriggerHapticPulse/2 method calls a haptic pulse based on a given audio clip.
            </summary>
            <param name="controllerReference">The reference to the controller to activate the haptic feedback on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.VRTK_ControllerHaptics.CancelHapticPulse(VRTK.VRTK_ControllerReference)">
            <summary>
            The CancelHapticPulse method cancels the existing running haptic pulse on the given controller index.
            </summary>
            <param name="controllerReference">The reference to the controller to cancel the haptic feedback on.</param>
        </member>
        <member name="T:VRTK.VRTK_ObjectAppearance">
            <summary>
            A collection of static methods for calling controlling the appearance of GameObjects such as opacity, render state and highlighter state.
            </summary>
            <remarks>
            **Script Usage:**
              > There is no requirement to add this script to a GameObject as all of the public methods are static and can be called directly e.g. `VRTK_ObjectAppearance.SetOpacity(obj, 1f)`.
            </remarks>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.SetOpacity(UnityEngine.GameObject,System.Single,System.Single)">
            <summary>
            The SetOpacity method allows the opacity of the given GameObject to be changed. `0f` is full transparency, `1f` is full opacity.
            </summary>
            <param name="model">The GameObject to change the renderer opacity on.</param>
            <param name="alpha">The colour alpha/opacity level. `0f` to `1f`.</param>
            <param name="transitionDuration">The time to transition from the current opacity to the new opacity.</param>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.SetRendererVisible(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The SetRendererVisible method turns on renderers of a given GameObject. It can also be provided with an optional GameObject to ignore the render toggle on.
            </summary>
            <param name="model">The GameObject to show the renderers for.</param>
            <param name="ignoredModel">An optional GameObject to ignore the renderer toggle on.</param>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.SetRendererHidden(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The SetRendererHidden method turns off renderers of a given GameObject. It can also be provided with an optional GameObject to ignore the render toggle on.
            </summary>
            <param name="model">The GameObject to hide the renderers for.</param>
            <param name="ignoredModel">An optional GameObject to ignore the renderer toggle on.</param>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.ToggleRenderer(System.Boolean,UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The ToggleRenderer method turns on or off the renderers of a given GameObject. It can also be provided with an optional GameObject to ignore the render toggle of.
            </summary>
            <param name="state">If true then the renderers will be enabled, if false the renderers will be disabled.</param>
            <param name="model">The GameObject to toggle the renderer states of.</param>
            <param name="ignoredModel">An optional GameObject to ignore the renderer toggle on.</param>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.IsRendererVisible(UnityEngine.GameObject,UnityEngine.GameObject)">
            <summary>
            The IsRendererVisible method is used to check if a given GameObject is visible in the scene by any of it's child renderers being enabled.
            </summary>
            <param name="model">The GameObject to check for visibility on.</param>
            <param name="ignoredModel">A GameObject to ignore when doing the visibility check.</param>
            <returns>Returns true if any of the child renderers are enabled, returns false if all child renderers are disabled.</returns>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.HighlightObject(UnityEngine.GameObject,System.Nullable{UnityEngine.Color},System.Single)">
            <summary>
            The HighlightObject method calls the Highlight method on the highlighter attached to the given GameObject with the provided colour.
            </summary>
            <param name="model">The GameObject to attempt to call the Highlight on.</param>
            <param name="highlightColor">The Color to highlight to.</param>
            <param name="fadeDuration">The duration in time to fade from the initial colour to the target colour.</param>
        </member>
        <member name="M:VRTK.VRTK_ObjectAppearance.UnhighlightObject(UnityEngine.GameObject)">
            <summary>
            The UnhighlightObject method calls the Unhighlight method on the highlighter attached to the given GameObject.
            </summary>
            <param name="model">The GameObject to attempt to call the Unhighlight on.</param>
        </member>
        <member name="F:VRTK.VRTK_Defines.CurrentVersion">
            <summary>
            The current version of VRTK.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_Defines.PreviousVersions">
            <summary>
            The previously known versions of VRTK.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_Defines.CurrentExactVersionScriptingDefineSymbol">
            <summary>
            The scripting define symbol that is used for the current version of VRTK.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_PlayerObject.ObjectTypes">
            <summary>
            The type of object associated to the player.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Null">
            <summary>
            No defined object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.CameraRig">
            <summary>
            The object that represents the VR camera rig.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Headset">
            <summary>
            The object that represents the VR headset.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Controller">
            <summary>
            An object that represents a VR controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Pointer">
            <summary>
            An object that represents a player generated pointer.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Highlighter">
            <summary>
            An object that represents a player generated highlighter.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PlayerObject.ObjectTypes.Collider">
            <summary>
            An object that represents a player collider.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PlayerObject.SetPlayerObject(UnityEngine.GameObject,VRTK.VRTK_PlayerObject.ObjectTypes)">
            <summary>
            The SetPlayerObject method tags the given game object with a special player object class for easier identification.
            </summary>
            <param name="obj">The game object to add the player object class to.</param>
            <param name="objType">The type of player object that is to be assigned.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayerObject.IsPlayerObject(UnityEngine.GameObject,VRTK.VRTK_PlayerObject.ObjectTypes)">
            <summary>
            The IsPlayerObject method determines if the given game object is a player object and can also check if it's of a specific type.
            </summary>
            <param name="obj">The GameObjet to check if it's a player object.</param>
            <param name="ofType">An optional ObjectType to check if the given GameObject is of a specific player object.</param>
            <returns>Returns true if the object is a player object with the optional given type.</returns>
        </member>
        <member name="T:VRTK.VRTK_UIGraphicRaycaster">
            This script allows VRTK to interact cleanly with Unity Canvases.
            It is mostly a duplicate of Unity's default GraphicsRaycaster:
            https://bitbucket.org/Unity-Technologies/ui/src/0155c39e05ca5d7dcc97d9974256ef83bc122586/UnityEngine.UI/UI/Core/GraphicRaycaster.c
            However, it allows for graphics to be hit when they are not in view of a camera.
            Note: Not intended for direct use. VRTK will intelligently replace the default GraphicsRaycaster
              on canvases with this raycaster.
        </member>
        <member name="T:VRTK.VRTK_BaseObjectControlAction">
            <summary>
            Provides a base that all object control actions can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides object control action functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="T:VRTK.VRTK_BaseObjectControlAction.AxisListeners">
            <summary>
            The axis to listen to changes on.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BaseObjectControlAction.AxisListeners.XAxisChanged">
            <summary>
            Listen for changes on the horizontal X axis.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BaseObjectControlAction.AxisListeners.YAxisChanged">
            <summary>
            Listen for changes on the vertical y axis.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BaseObjectControlAction.CheckForPlayerBeforeRotation(UnityEngine.GameObject)">
            <summary>
            Since rotation scripts may rotate the game object '[CameraRig]' in order to rotate the player and the player's head does not always have the local position (0,0,0), the rotation will result in a position offset of player's head. The game object '[CameraRig]' will moved relativly to compensate that. Therefore it will save the player's head position in this method. 
            Call 'CheckForPlayerAfterRotation()' to correct the player's head position offset after rotation.
            </summary>
            <param name="controlledGameObject"></param>
        </member>
        <member name="M:VRTK.VRTK_BaseObjectControlAction.CheckForPlayerAfterRotation(UnityEngine.GameObject)">
            <summary>
            Corrects the player's head position offset after rotation. Call 'CheckForPlayerBeforeRotation' before execute rotation.
            </summary>
            <param name="controlledGameObject"></param>
        </member>
        <member name="T:VRTK.VRTK_RotateObjectControlAction">
             <summary>
             Provides the ability to rotate a GameObject through the world `y` axis in the scene by updating the Transform rotation when the corresponding Object Control axis changes.
             </summary>
             <remarks>
               > The effect is a smooth rotation to simulate turning.
            
             **Required Components:**
              * `VRTK_ObjectControl` - The Object Control script to listen for the axis changes on.
            
             **Script Usage:**
              * Place the `VRTK_RotateObjectControlAction` script on any active scene GameObject.
              * Link the required Object Control script to the `Object Control Script` parameter of this script.
              * Set the `Listen On Axis Change` parameter on this script to the axis change to affect with this movement type.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad. There is also an area that can only be traversed if the user is crouching.
            
             To enable the Rotate Object Control Action, ensure one of the `TouchpadControlOptions` children (located under the Controller script alias) has the `Rotate` control script active.
             </example>
        </member>
        <member name="T:VRTK.VRTK_SlideObjectControlAction">
             <summary>
             Provides the ability to move a GameObject around by sliding it across the `x/z` plane in the scene by updating the Transform position when the corresponding Object Control axis changes.
             </summary>
             <remarks>
               > The effect is a smooth sliding motion in forward and sideways directions to simulate walking.
            
             **Required Components:**
              * `VRTK_ObjectControl` - The Object Control script to listen for the axis changes on.
            
             **Optional Components:**
              * `VRTK_BodyPhysics` - The Body Physics script to utilise when checking for potential collisions on movement.
            
             **Script Usage:**
              * Place the `VRTK_SlideObjectControlAction` script on any active scene GameObject.
              * Link the required Object Control script to the `Object Control Script` parameter of this script.
              * Set the `Listen On Axis Change` parameter on this script to the axis change to affect with this movement type.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad. There is also an area that can only be traversed if the user is crouching.
            
             To enable the Slide Object Control Action, ensure one of the `TouchpadControlOptions` children (located under the Controller script alias) has the `Slide` control script active.
             </example>
        </member>
        <member name="T:VRTK.VRTK_SnapRotateObjectControlAction">
             <summary>
             Provides the ability to snap rotate a GameObject through the world `y` axis in the scene by updating the Transform rotation in defined steps when the corresponding Object Control axis changes.
             </summary>
             <remarks>
               > The effect is a immediate snap rotation to quickly face in a new direction.
            
             **Required Components:**
              * `VRTK_ObjectControl` - The Object Control script to listen for the axis changes on.
            
             **Script Usage:**
              * Place the `VRTK_SnapRotateObjectControlAction` script on any active scene GameObject.
              * Link the required Object Control script to the `Object Control Script` parameter of this script.
              * Set the `Listen On Axis Change` parameter on this script to the axis change to affect with this movement type.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad. There is also an area that can only be traversed if the user is crouching.
            
             To enable the Snap Rotate Object Control Action, ensure one of the `TouchpadControlOptions` children (located under the Controller script alias) has the `Snap Rotate` control script active.
             </example>
        </member>
        <member name="T:VRTK.VRTK_WarpObjectControlAction">
             <summary>
             Provides the ability to move a GameObject around by warping it across the `x/z` plane in the scene by updating the Transform position in defined steps when the corresponding Object Control axis changes.
             </summary>
             <remarks>
               > The effect is a immediate snap to a new position in the given direction.
            
             **Required Components:**
              * `VRTK_ObjectControl` - The Object Control script to listen for the axis changes on.
            
             **Optional Components:**
              * `VRTK_BodyPhysics` - The Body Physics script to utilise when checking for potential collisions on movement.
            
             **Script Usage:**
              * Place the `VRTK_WarpObjectControlAction` script on any active scene GameObject.
              * Link the required Object Control script to the `Object Control Script` parameter of this script.
              * Set the `Listen On Axis Change` parameter on this script to the axis change to affect with this movement type.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad. There is also an area that can only be traversed if the user is crouching.
            
             To enable the Warp Object Control Action, ensure one of the `TouchpadControlOptions` children (located under the Controller script alias) has the `Warp` control script active.
             </example>
        </member>
        <member name="T:VRTK.TeleportEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.DestinationMarkerEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_BasicTeleport">
             <summary>
             Updates the `x/z` position of the SDK Camera Rig with an optional screen fade.
             </summary>
             <remarks>
               > The `y` position is not altered by the Basic Teleport so it only allows for movement across a 2D plane.
            
             **Script Usage:**
              * Place the `VRTK_BasicTeleport` script on any active scene GameObject.
            
             **Script Dependencies:**
              * An optional Destination Marker (such as a Pointer) to set the destination of the teleport location.
             </remarks>
             <example>
             `VRTK/Examples/004_CameraRig_BasicTeleport` uses the `VRTK_Pointer` script on the Controllers to initiate a laser pointer by pressing the `Touchpad` on the controller and when the laser pointer is deactivated (release the `Touchpad`) then the user is teleported to the location of the laser pointer tip as this is where the pointer destination marker position is set to.
             </example>
        </member>
        <member name="E:VRTK.VRTK_BasicTeleport.Teleporting">
            <summary>
            Emitted when the teleport process has begun.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BasicTeleport.Teleported">
            <summary>
            Emitted when the teleport process has successfully completed.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.InitDestinationSetListener(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The InitDestinationSetListener method is used to register the teleport script to listen to events from the given game object that is used to generate destination markers. Any destination set event emitted by a registered game object will initiate the teleport to the given destination location.
            </summary>
            <param name="markerMaker">The game object that is used to generate destination marker events, such as a controller.</param>
            <param name="register">Determines whether to register or unregister the listeners.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.ToggleTeleportEnabled(System.Boolean)">
            <summary>
            The ToggleTeleportEnabled method is used to determine whether the teleporter will initiate a teleport on a destination set event, if the state is true then the teleporter will work as normal, if the state is false then the teleporter will not be operational.
            </summary>
            <param name="state">Toggles whether the teleporter is enabled or disabled.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.ValidLocation(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            The ValidLocation method determines if the given target is a location that can be teleported to
            </summary>
            <param name="target">The Transform that the destination marker is touching.</param>
            <param name="destinationPosition">The position in world space that is the destination.</param>
            <returns>Returns `true` if the target is a valid location.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.Teleport(VRTK.DestinationMarkerEventArgs)">
            <summary>
            The Teleport/1 method calls the teleport to update position without needing to listen for a Destination Marker event.
            </summary>
            <param name="teleportArgs">The pseudo Destination Marker event for the teleport action.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.Teleport(UnityEngine.Transform,UnityEngine.Vector3,System.Nullable{UnityEngine.Quaternion},System.Boolean)">
            <summary>
            The Teleport/4 method calls the teleport to update position without needing to listen for a Destination Marker event.
             It will build a destination marker out of the provided parameters.
            </summary>
            <param name="target">The Transform of the destination object.</param>
            <param name="destinationPosition">The world position to teleport to.</param>
            <param name="destinationRotation">The world rotation to teleport to.</param>
            <param name="forceDestinationPosition">If `true` then the given destination position should not be altered by anything consuming the payload.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.ForceTeleport(UnityEngine.Vector3,System.Nullable{UnityEngine.Quaternion})">
            <summary>
            The ForceTeleport method forces the position to update to a given destination and ignores any target checking or floor adjustment.
            </summary>
            <param name="destinationPosition">The world position to teleport to.</param>
            <param name="destinationRotation">The world rotation to teleport to.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.SetActualTeleportDestination(UnityEngine.Vector3,System.Nullable{UnityEngine.Quaternion})">
            <summary>
            The SetActualTeleportDestination method forces the destination of a teleport event to the given Vector3.
            </summary>
            <param name="actualPosition">The actual position that the teleport event should use as the final location.</param>
            <param name="actualRotation">The actual rotation that the teleport event should use as the final location.</param>
        </member>
        <member name="M:VRTK.VRTK_BasicTeleport.ResetActualTeleportDestination">
            <summary>
            The ResetActualTeleportDestination method removes any previous forced destination position that was set by the SetActualTeleportDestination method.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_ButtonControl">
             <summary>
             Provides the ability to control a GameObject's position based the press of a controller button linked to a specific axis direction.
             </summary>
             <remarks>
               > This script forms the stub of emitting the axis X and Y changes that are then digested by the corresponding Object Control Actions that are listening for the relevant event.
            
             **Required Components:**
              * `VRTK_ControllerEvents` - The Controller Events script to listen for button presses events on.
            
             **Optional Components:**
              * `VRTK_BodyPhysics` - The Body Physics script to utilise to determine if falling is occuring.
            
             **Script Usage:**
              * Place the `VRTK_ButtonControl` script on either:
                * The GameObject with the Controller Events script.
                * Any other scene GameObject and provide a valid `VRTK_ControllerEvents` component to the `Controller` parameter of this script.
              * Place a corresponding Object Control Action for the Button Control script to notify of axis changes. Without a corresponding Object Control Action, the Button Control script will do nothing.
             </remarks>
        </member>
        <member name="T:VRTK.DashTeleportEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="hits">An array of RaycastHits that the CapsuleCast has collided with.</param>
        </member>
        <member name="T:VRTK.DashTeleportEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.DashTeleportEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_DashTeleport">
             <summary>
             Updates the `x/y/z` position of the SDK Camera Rig with a lerp to the new position creating a dash effect.
             </summary>
             <remarks>
             **Script Usage:**
              * Place the `VRTK_DashTeleport` script on any active scene GameObject.
            
             **Script Dependencies:**
              * An optional Destination Marker (such as a Pointer) to set the destination of the teleport location.
             </remarks>
             <example>
             `VRTK/Examples/038_CameraRig_DashTeleport` shows how to turn off the mesh renderers of objects that are in the way during the dash.
             </example>
        </member>
        <member name="E:VRTK.VRTK_DashTeleport.WillDashThruObjects">
            <summary>
            Emitted when the CapsuleCast towards the target has found that obstacles are in the way.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DashTeleport.DashedThruObjects">
            <summary>
            Emitted when obstacles have been crossed and the dash has ended.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_DragWorld">
             <summary>
             Provides the ability to move, rotate and scale the PlayArea by dragging the world with the controllers.
             </summary>
             <remarks>
             **Script Usage:**
              * Place the `VRTK_DragWorld` script on any active scene GameObject.
            
               > If only one controller is being used to track the rotation mechanism, then the rotation will be based on the perpendicual (yaw) axis angular velocity of the tracking controller.
               > If both controllers are being used to track the rotation mechanism, then the rotation will be based on pushing one controller forward, whilst pulling the other controller backwards.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_DragWorld.ActivationRequirement">
            <summary>
            The controller on which to determine as the activation requirement for the control mechanism.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.LeftControllerOnly">
            <summary>
            Only pressing the activation button on the left controller will activate the mechanism, if the right button is held down then the mechanism will not be activated.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.RightControllerOnly">
            <summary>
            Only pressing the activation button on the right controller will activate the mechanism, if the left button is held down then the mechanism will not be activated.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.LeftController">
            <summary>
            Pressing the activation button on the left controller is all that is required to activate the mechanism.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.RightController">
            <summary>
            Pressing the activation button on the right controller is all that is required to activate the mechanism.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.EitherController">
            <summary>
            Pressing the activation button on the either controller is all that is required to activate the mechanism.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.ActivationRequirement.BothControllers">
            <summary>
            Pressing the activation button on both controllers is required to activate the mechanism.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_DragWorld.TrackingController">
            <summary>
            The controllers which to track when performing the mechanism.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.TrackingController.LeftController">
            <summary>
            Only track the left controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.TrackingController.RightController">
            <summary>
            Only track the right controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.TrackingController.EitherController">
            <summary>
            Track either the left or the right controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DragWorld.TrackingController.BothControllers">
            <summary>
            Only track both controllers at the same time.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_HeightAdjustTeleport">
             <summary>
             Updates the `x/y/z` position of the SDK Camera Rig with an optional screen fade.
             </summary>
             <remarks>
               > The Camera Rig can be automatically teleported to the nearest floor `y` position when utilising this teleporter.
            
             **Script Usage:**
              * Place the `VRTK_HeightAdjustTeleport` script on any active scene GameObject.
            
             **Script Dependencies:**
              * An optional Destination Marker (such as a Pointer) to set the destination of the teleport location.
             </remarks>
             <example>
             `VRTK/Examples/007_CameraRig_HeightAdjustTeleport` has a collection of varying height objects that the user can either walk up and down or use the laser pointer to climb on top of them.
            
             `VRTK/Examples/010_CameraRig_TerrainTeleporting` shows how the teleportation of a user can also traverse terrain colliders.
            
             `VRTK/Examples/020_CameraRig_MeshTeleporting` shows how the teleportation of a user can also traverse mesh colliders.
             </example>
        </member>
        <member name="T:VRTK.VRTK_MoveInPlace">
             <summary>
             Moves the SDK Camera Rig based on the motion of the headset and/or the controllers. Attempts to recreate the concept of physically walking on the spot to create scene movement.
             </summary>
             <remarks>
               > This locomotion method is based on Immersive Movement, originally created by Highsight. Thanks to KJack (author of Arm Swinger) for additional work.
            
             **Optional Components:**
              * `VRTK_BodyPhysics` - A Body Physics script to help determine potential collisions in the moving direction and prevent collision tunnelling.
            
             **Script Usage:**
              * Place the `VRTK_MoveInPlace` script on any active scene GameObject.
            
             **Script Dependencies:**
              * The Controller Events script on the controller Script Alias to determine when the engage button is pressed.
             </remarks>
             <example>
             `VRTK/Examples/042_CameraRig_MoveInPlace` demonstrates how the user can move and traverse colliders by either swinging the controllers in a walking fashion or by running on the spot utilisng the head bob for movement.
             </example>
        </member>
        <member name="T:VRTK.VRTK_MoveInPlace.ControlOptions">
            <summary>
            Valid control options
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.ControlOptions.HeadsetAndControllers">
            <summary>
            Track both headset and controllers for movement calculations.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.ControlOptions.ControllersOnly">
            <summary>
            Track only the controllers for movement calculations.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.ControlOptions.HeadsetOnly">
            <summary>
            Track only headset for movement caluclations.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_MoveInPlace.DirectionalMethod">
            <summary>
            Options for which method is used to determine direction while moving.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.Gaze">
            <summary>
            Will always move in the direction they are currently looking.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.ControllerRotation">
            <summary>
            Will move in the direction that the controllers are pointing (averaged).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.DumbDecoupling">
            <summary>
            Will move in the direction they were first looking when they engaged Move In Place.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.SmartDecoupling">
            <summary>
            Will move in the direction they are looking only if their headset point the same direction as their controllers.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.EngageControllerRotationOnly">
            <summary>
            Will move in the direction that the controller with the engage button pressed is pointing.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.LeftControllerRotationOnly">
            <summary>
            Will move in the direction that the left controller is pointing.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_MoveInPlace.DirectionalMethod.RightControllerRotationOnly">
            <summary>
            Will move in the direction that the right controller is pointing.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_MoveInPlace.SetControlOptions(VRTK.VRTK_MoveInPlace.ControlOptions)">
            <summary>
            Set the control options and modify the trackables to match.
            </summary>
            <param name="givenControlOptions">The control options to set the current control options to.</param>
        </member>
        <member name="M:VRTK.VRTK_MoveInPlace.GetMovementDirection">
            <summary>
            The GetMovementDirection method will return the direction the play area is currently moving in.
            </summary>
            <returns>Returns a Vector3 representing the current movement direction.</returns>
        </member>
        <member name="M:VRTK.VRTK_MoveInPlace.GetSpeed">
            <summary>
            The GetSpeed method will return the current speed the play area is moving at.
            </summary>
            <returns>Returns a float representing the current movement speed.</returns>
        </member>
        <member name="T:VRTK.ObjectControlEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controlledGameObject">The GameObject that is going to be affected.</param>
            <param name="directionDevice">The device that is used for the direction.</param>
            <param name="axisDirection">The axis that is being affected.</param>
            <param name="axis">The value of the current touchpad touch point based across the axis direction.</param>
            <param name="deadzone">The value of the deadzone based across the axis direction.</param>
            <param name="currentlyFalling">Whether the controlled GameObject is currently falling.</param>
            <param name="modifierActive">Whether the modifier button is pressed.</param>
        </member>
        <member name="T:VRTK.ObjectControlEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.ObjectControlEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_ObjectControl">
            <summary>
            Provides a base that all object control locomotions can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides object control locomotion functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="T:VRTK.VRTK_ObjectControl.DirectionDevices">
            <summary>
            Devices for providing direction.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectControl.DirectionDevices.Headset">
            <summary>
            The headset device.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectControl.DirectionDevices.LeftController">
            <summary>
            The left controller device.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectControl.DirectionDevices.RightController">
            <summary>
            The right controller device.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_ObjectControl.DirectionDevices.ControlledObject">
            <summary>
            The controlled object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ObjectControl.XAxisChanged">
            <summary>
            Emitted when the X Axis Changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_ObjectControl.YAxisChanged">
            <summary>
            Emitted when the Y Axis Changes.
            </summary>
        </member>
        <member name="T:VRTK.PlayerClimbEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controllerReference">The reference to the controller doing the interaction.</param>
            <param name="target">The GameObject of the interactable object that is being interacted with by the controller.</param>
        </member>
        <member name="T:VRTK.PlayerClimbEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.PlayerClimbEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_PlayerClimb">
             <summary>
             Provides the ability for the SDK Camera Rig to be moved around based on whether an Interact Grab is interacting with a Climbable Interactable Object to simulate climbing.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_BodyPhysics` - A Body Physics script to deal with the effects of physics and gravity on the play area.
            
             **Optional Components:**
              * `VRTK_BasicTeleport` - A Teleporter script to use when snapping the play area to the nearest floor when releasing from grab.
              * `VRTK_HeadsetCollision` - A Headset Collision script to determine when the headset is colliding with geometry to know when to reset to a valid location.
              * `VRTK_PositionRewind` - A Position Rewind script to utilise when resetting to a valid location upon ungrabbing whilst colliding with geometry.
            
             **Script Usage:**
              * Place the `VRTK_PlayerClimb` script on any active scene GameObject.
            
             **Script Dependencies:**
              * The controller Script Alias GameObject requires the Interact Touch and Interact Grab scripts to allow for touching and grabbing of Interactable Objects.
              * An Interactable Object in the scene that has the Climbable Grab Attach Mechanic.
             </remarks>
             <example>
             `VRTK/Examples/037_CameraRig_ClimbingFalling` shows how to set up a scene with player climbing. There are many different examples showing how the same system can be used in unique ways.
             </example>
        </member>
        <member name="E:VRTK.VRTK_PlayerClimb.PlayerClimbStarted">
            <summary>
            Emitted when player climbing has started.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PlayerClimb.PlayerClimbEnded">
            <summary>
            Emitted when player climbing has ended.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PlayerClimb.IsClimbing">
            <summary>
            The IsClimbing method will return if climbing is currently taking place or not.
            </summary>
            <returns>Returns `true` if climbing is currently taking place.</returns>
        </member>
        <member name="T:VRTK.VRTK_RoomExtender">
             <summary>
             Multiplies each real world step within the play area to enable further distances to be travelled in the virtual world.
             </summary>
             <remarks>
             **Script Usage:**
              * Place the `VRTK_RoomExtender` script on any active scene GameObject.
            
             **Script Dependencies:**
              * The Controller Events script on the controller Script Alias to determine when the touchpad is pressed.
             </remarks>
             <example>
             `VRTK/Examples/028_CameraRig_RoomExtender` shows how the RoomExtender script is controlled by a VRTK_RoomExtender_Controller Example script located at both controllers. Pressing the `Touchpad` on the controller activates the Room Extender. The Additional Movement Multiplier is changed based on the touch distance to the centre of the touchpad.
             </example>
        </member>
        <member name="T:VRTK.VRTK_RoomExtender.MovementFunction">
            <summary>
            Movement methods.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RoomExtender.MovementFunction.Nonlinear">
            <summary>
            Moves the head with a non-linear drift movement.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RoomExtender.MovementFunction.LinearDirect">
            <summary>
            Moves the headset in a direct linear movement.
            </summary>
        </member>
        <member name="T:VRTK.SlingshotJumpEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
        </member>
        <member name="T:VRTK.VRTK_SlingshotJump">
             <summary>
             Provides the ability for the SDK Camera Rig to be thrown around with a jumping motion by slingshotting based on the pull back of each valid controller.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_PlayerClimb` - A Player Climb script for dealing with the physical throwing of the play area as if throwing off an invisible climbed object.
              * `VRTK_BodyPhysics` - A Body Physics script to deal with the effects of physics and gravity on the play area.
            
             **Optional Components:**
              * `VRTK_BasicTeleport` - A Teleporter script to use when snapping the play area to the nearest floor when releasing from grab.
              * `VRTK_HeadsetCollision` - A Headset Collision script to determine when the headset is colliding with geometry to know when to reset to a valid location.
              * `VRTK_PositionRewind` - A Position Rewind script to utilise when resetting to a valid location upon ungrabbing whilst colliding with geometry.
            
             **Script Usage:**
              * Place the `VRTK_SlingshotJump` script on the same GameObject as the `VRTK_PlayerClimb` script.
             </remarks>
             <example>
             `VRTK/Examples/037_CameraRig_ClimbingFalling` shows how to set up a scene with slingshot jumping. This script just needs to be added to the PlayArea object and the requested forces and buttons set.
             </example>
        </member>
        <member name="E:VRTK.VRTK_SlingshotJump.SlingshotJumped">
            <summary>
            Emitted when a slingshot jump occurs
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SlingshotJump.GetActivationButton">
            <summary>
            The SetActivationButton method gets the button used to activate a slingshot jump.
            </summary>
            <returns>Returns the button used for slingshot activation.</returns>
        </member>
        <member name="M:VRTK.VRTK_SlingshotJump.SetActivationButton(VRTK.VRTK_ControllerEvents.ButtonAlias)">
            <summary>
            The SetActivationButton method sets the button used to activate a slingshot jump.
            </summary>
            <param name="button">The controller button to use to activate the jump.</param>
        </member>
        <member name="M:VRTK.VRTK_SlingshotJump.GetCancelButton">
            <summary>
            The GetCancelButton method gets the button used to cancel a slingshot jump.
            </summary>
            <returns>Returns the button used to cancel a slingshot jump.</returns>
        </member>
        <member name="M:VRTK.VRTK_SlingshotJump.SetCancelButton(VRTK.VRTK_ControllerEvents.ButtonAlias)">
            <summary>
            The SetCancelButton method sets the button used to cancel a slingshot jump.
            </summary>
            <param name="button">The controller button to use to cancel the jump.</param>
        </member>
        <member name="T:VRTK.VRTK_StepMultiplier">
             <summary>
             Multiplies each real world step within the play area to enable further distances to be travelled in the virtual world.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the `Controller Events` parameter.
            
             **Script Usage:**
              * Place the `VRTK_StepMultiplier` script on either:
                * Any GameObject in the scene if no activation button is required.
                * The GameObject with the Controller Events scripts if an activation button is required.
                * Any other scene GameObject and provide a valid `VRTK_ControllerEvents` component to the `Controller Events` parameter of this script if an activation button is required.
             </remarks>
             <example>
             `VRTK/Examples/028_CameraRig_RoomExtender` shows how the Step Multiplier can be used to move around the scene with multiplied steps.
             </example>
        </member>
        <member name="T:VRTK.VRTK_StepMultiplier.MovementFunction">
            <summary>
            Movement methods.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_StepMultiplier.MovementFunction.Nonlinear">
            <summary>
            Moves the head with a non-linear drift movement.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_StepMultiplier.MovementFunction.LinearDirect">
            <summary>
            Moves the headset in a direct linear movement.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_TeleportDisableOnControllerObscured">
             <summary>
             Prevents teleportation when the controllers are obscured from line of sight of the HMD.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_BasicTeleport` - A Teleport script to utilise for teleporting the play area.
              * `VRTK_HeadsetControllerAware` - A Headset Controller Aware script to determine when the HMD has line of sight to the controllers.
            
             **Script Usage:**
              * Place the `VRTK_TeleportDisableOnControllerObscured` script on any active scene GameObject.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_TeleportDisableOnHeadsetCollision">
             <summary>
             Prevents teleportation when the HMD is colliding with valid geometry.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_BasicTeleport` - A Teleport script to utilise for teleporting the play area.
              * `VRTK_HeadsetCollision` - A Headset Collision script for detecting when the headset has collided with valid geometry.
            
             **Script Usage:**
              * Place the `VRTK_TeleportDisableOnHeadsetCollision` script on any active scene GameObject.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_TouchpadControl">
             <summary>
             Provides the ability to control a GameObject's position based on the position of the controller touchpad axis.
             </summary>
             <remarks>
               > This script forms the stub of emitting the touchpad axis X and Y changes that are then digested by the corresponding Object Control Actions that are listening for the relevant event.
            
             **Required Components:**
              * `VRTK_ControllerEvents` - The Controller Events script to listen for the touchpad events on.
            
             **Optional Components:**
              * `VRTK_BodyPhysics` - The Body Physics script to utilise to determine if falling is occuring.
            
             **Script Usage:**
              * Place the `VRTK_TouchpadControl` script on either:
                * The GameObject with the Controller Events script.
                * Any other scene GameObject and provide a valid `VRTK_ControllerEvents` component to the `Controller` parameter of this script.
              * Place a corresponding Object Control Action for the Touchpad Control script to notify of touchpad changes. Without a corresponding Object Control Action, the Touchpad Control script will do nothing.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad. There is also an area that can only be traversed if the user is crouching.
             </example>
        </member>
        <member name="T:VRTK.VRTK_TunnelOverlay">
             <summary>
             Applys a tunnel overlay effect to the active VR camera when the play area is moving or rotating to reduce potential nausea caused by simulation sickness.
             </summary>
             <remarks>
             **Script Usage:**
              * Place the `VRTK_TunnelOverlay` script on any active scene GameObject.
            
               > This implementation is based on a project made by SixWays at https://github.com/SixWays/UnityVrTunnelling
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_BasePointerRenderer">
            <summary>
            Provides a base that all pointer renderers can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides pointer renderer functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="T:VRTK.VRTK_BasePointerRenderer.VisibilityStates">
            <summary>
            States of Pointer Visibility.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BasePointerRenderer.VisibilityStates.OnWhenActive">
            <summary>
            Only shows the object when the pointer is active.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BasePointerRenderer.VisibilityStates.AlwaysOn">
            <summary>
            Ensures the object is always.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BasePointerRenderer.VisibilityStates.AlwaysOff">
            <summary>
            Ensures the object beam is never visible.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.GetPointerObjects">
            <summary>
            The GetPointerObjects returns an array of the auto generated GameObjects associated with the pointer.
            </summary>
            <returns>An array of pointer auto generated GameObjects.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.InitalizePointer(VRTK.VRTK_Pointer,VRTK.VRTK_PolicyList,System.Single,System.Boolean)">
            <summary>
            The InitalizePointer method is used to set up the state of the pointer renderer.
            </summary>
            <param name="givenPointer">The VRTK_Pointer that is controlling the pointer renderer.</param>
            <param name="givenInvalidListPolicy">The VRTK_PolicyList for managing valid and invalid pointer locations.</param>
            <param name="givenNavMeshCheckDistance">The given distance from a nav mesh that the pointer can be to be valid.</param>
            <param name="givenHeadsetPositionCompensation">Determines whether the play area cursor will take the headset position within the play area into account when being displayed.</param>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.InitalizePointer(VRTK.VRTK_Pointer,VRTK.VRTK_PolicyList,VRTK.VRTK_NavMeshData,System.Boolean)">
            <summary>
            The InitalizePointer method is used to set up the state of the pointer renderer.
            </summary>
            <param name="givenPointer">The VRTK_Pointer that is controlling the pointer renderer.</param>
            <param name="givenInvalidListPolicy">The VRTK_PolicyList for managing valid and invalid pointer locations.</param>
            <param name="givenNavMeshData">The NavMeshData object that contains the Nav Mesh restriction options.</param>
            <param name="givenHeadsetPositionCompensation">Determines whether the play area cursor will take the headset position within the play area into account when being displayed.</param>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.ResetPointerObjects">
            <summary>
            The ResetPointerObjects method is used to destroy any existing pointer objects and recreate them at runtime.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.Toggle(System.Boolean,System.Boolean)">
            <summary>
            The Toggle Method is used to enable or disable the pointer renderer.
            </summary>
            <param name="pointerState">The activation state of the pointer.</param>
            <param name="actualState">The actual state of the activation button press.</param>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.ToggleInteraction(System.Boolean)">
            <summary>
            The ToggleInteraction method is used to enable or disable the controller extension interactions.
            </summary>
            <param name="state">If true then the object interactor will be enabled.</param>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.UpdateRenderer">
            <summary>
            The UpdateRenderer method is used to run an Update routine on the pointer.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.GetDestinationHit">
            <summary>
            The GetDestinationHit method is used to get the RaycastHit of the pointer destination.
            </summary>
            <returns>The RaycastHit containing the information where the pointer is hitting.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.ValidPlayArea">
            <summary>
            The ValidPlayArea method is used to determine if there is a valid play area and if it has had any collisions.
            </summary>
            <returns>Returns true if there is a valid play area and no collisions. Returns false if there is no valid play area or there is but with a collision detected.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.IsVisible">
            <summary>
            The IsVisible method determines if the pointer renderer is at all visible by checking the state of the tracer and the cursor.
            </summary>
            <returns>Returns true if either the tracer or cursor renderers are visible. Returns false if none are visible.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.IsTracerVisible">
            <summary>
            The IsTracerVisible method determines if the pointer tracer renderer is visible.
            </summary>
            <returns>Returns true if the tracer renderers are visible.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.IsCursorVisible">
            <summary>
            The IsCursorVisible method determines if the pointer cursor renderer is visible.
            </summary>
            <returns>Returns true if the cursor renderers are visible.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.IsValidCollision">
            <summary>
            The IsValidCollision method determines if the pointer is currently in it's valid collision state.
            </summary>
            <returns>Returns true if the pointer is in a valid collision, returns false if the pointer is in an invalid collision state.</returns>
        </member>
        <member name="M:VRTK.VRTK_BasePointerRenderer.GetObjectInteractor">
            <summary>
            The GetObjectInteractor method returns the auto generated GameObject that acts as the controller extension for interacting with objects.
            </summary>
            <returns>The auto generated object interactor GameObject.</returns>
            <returns></returns>
        </member>
        <member name="T:VRTK.VRTK_BezierPointerRenderer">
             <summary>
             A visual pointer representation of a curved beam made from multiple objects with an optional cursor at the end.
             </summary>
             <remarks>
               > The bezier curve generation code is in another script located at `VRTK/Source/Scripts/Internal/VRTK_CurveGenerator.cs` and was heavily inspired by the tutorial and code from [Catlike Coding](http://catlikecoding.com/unity/tutorials/curves-and-splines/).
            
             **Optional Components:**
              * `VRTK_PlayAreaCursor` - A Play Area Cursor that will track the position of the pointer cursor.
              * `VRTK_PointerDirectionIndicator` - A Pointer Direction Indicator that will track the position of the pointer cursor.
             
             **Script Usage:**
              * Place the `VRTK_BezierPointerRenderer` script on the same GameObject as the Pointer script it is linked to.
              * Link this Pointer Renderer script to the `Pointer Renderer` parameter on the required Pointer script.
            
             **Script Dependencies:**
              * A Pointer script to control the activation of this Pointer Renderer script.
             </remarks>
             <example>
             `VRTK/Examples/009_Controller_BezierPointer` is used in conjunction with the Height Adjust Teleporter shows how it is possible to traverse different height objects using the curved pointer without needing to see the top of the object.
            
             `VRTK/Examples/036_Controller_CustomCompoundPointer' shows how to display an object (a teleport beam) only if the teleport location is valid, and can create an animated trail along the tracer curve.
             </example>
        </member>
        <member name="M:VRTK.VRTK_BezierPointerRenderer.UpdateRenderer">
            <summary>
            The UpdateRenderer method is used to run an Update routine on the pointer.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BezierPointerRenderer.GetPointerObjects">
            <summary>
            The GetPointerObjects returns an array of the auto generated GameObjects associated with the pointer.
            </summary>
            <returns>An array of pointer auto generated GameObjects.</returns>
        </member>
        <member name="T:VRTK.VRTK_StraightPointerRenderer">
             <summary>
             A visual pointer representation of a straight beam with an optional cursor at the end.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_PlayAreaCursor` - A Play Area Cursor that will track the position of the pointer cursor.
              * `VRTK_PointerDirectionIndicator` - A Pointer Direction Indicator that will track the position of the pointer cursor.
             
             **Script Usage:**
              * Place the `VRTK_StraightPointerRenderer` script on the same GameObject as the Pointer script it is linked to.
              * Link this Pointer Renderer script to the `Pointer Renderer` parameter on the required Pointer script.
            
             **Script Dependencies:**
              * A Pointer script to control the activation of this Pointer Renderer script.
             </remarks>
             <example>
             `VRTK/Examples/003_Controller_SimplePointer` shows the simple pointer in action and code examples of how the events are utilised and listened to can be viewed in the script `VRTK/Examples/ExampleResources/Scripts/VRTK_ControllerPointerEvents_ListenerExample.cs`
             </example>
        </member>
        <member name="M:VRTK.VRTK_StraightPointerRenderer.UpdateRenderer">
            <summary>
            The UpdateRenderer method is used to run an Update routine on the pointer.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_StraightPointerRenderer.GetPointerObjects">
            <summary>
            The GetPointerObjects returns an array of the auto generated GameObjects associated with the pointer.
            </summary>
            <returns>An array of pointer auto generated GameObjects.</returns>
        </member>
        <member name="T:VRTK.DestinationMarkerEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="distance">The distance between the origin and the collided destination.</param>
            <param name="target">The Transform of the collided destination object.</param>
            <param name="raycastHit">The optional RaycastHit generated from when the ray collided.</param>
            <param name="destinationPosition">The world position of the destination marker.</param>
            <param name="destinationRotation">The world rotation of the destination marker.</param>
            <param name="forceDestinationPosition">If true then the given destination position should not be altered by anything consuming the payload.</param>
            <param name="enableTeleport">Whether the destination set event should trigger teleport.</param>
            <param name="controllerReference">The optional reference to the controller controlling the destination marker.</param>
        </member>
        <member name="T:VRTK.DestinationMarkerEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.DestinationMarkerEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_DestinationMarker">
            <summary>
            Provides a base that all destination markers can inherit from.
            </summary>
            <remarks>
            **Script Usage:**
              > This is an abstract class that is to be inherited to a concrete class that provides object control action functionality, therefore this script should not be directly used.
            </remarks>
        </member>
        <member name="E:VRTK.VRTK_DestinationMarker.DestinationMarkerEnter">
            <summary>
            Emitted when a collision with another collider has first occurred.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_DestinationMarker.DestinationMarkerExit">
            <summary>
            Emitted when the collision with the other collider ends.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "E:VRTK.VRTK_DestinationMarker.DestinationMarkerHover" -->
        <member name="E:VRTK.VRTK_DestinationMarker.DestinationMarkerSet">
            <summary>
            Emitted when the destination marker is active in the scene to determine the last destination position (useful for selecting and teleporting).
            </summary>
        </member>
        <member name="M:VRTK.VRTK_DestinationMarker.SetNavMeshCheckDistance(System.Single)">
            <summary>
            The SetNavMeshCheckDistance method sets the max distance the destination marker position can be from the edge of a nav mesh to be considered a valid destination.
            </summary>
            <param name="distance">The max distance the nav mesh can be from the sample point to be valid.</param>
        </member>
        <member name="M:VRTK.VRTK_DestinationMarker.SetNavMeshData(VRTK.VRTK_NavMeshData)">
            <summary>
            The SetNavMeshData method is used to limit the destination marker to the scene NavMesh based on the settings in the given NavMeshData object.
            </summary>
            <param name="givenData">The NavMeshData object that contains the NavMesh restriction settings.</param>
        </member>
        <member name="M:VRTK.VRTK_DestinationMarker.SetHeadsetPositionCompensation(System.Boolean)">
            <summary>
            The SetHeadsetPositionCompensation method determines whether the offset position of the headset from the centre of the play area should be taken into consideration when setting the destination marker. If `true` then it will take the offset position into consideration.
            </summary>
            <param name="state">The state of whether to take the position of the headset within the play area into account when setting the destination marker.</param>
        </member>
        <member name="M:VRTK.VRTK_DestinationMarker.SetForceHoverOnRepeatedEnter(System.Boolean)">
            <summary>
            The SetForceHoverOnRepeatedEnter method is used to set whether the Enter event will forciably call the Hover event if the existing colliding object is the same as it was the previous enter call.
            </summary>
            <param name="state">The state of whether to force the hover on or off.</param>
        </member>
        <member name="T:VRTK.PlayAreaCursorEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="collidedWith">The collider that is/was being collided with.</param>
        </member>
        <member name="T:VRTK.PlayAreaCursorEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.PlayAreaCursorEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_PlayAreaCursor">
             <summary>
             Provides a visual representation of the play area boundaries that tracks to the cursor position of a pointer.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_PointerDirectionIndicator` - A Pointer Direction Indicator to set the cursor rotation to.
             
             **Script Usage:**
              * Place the `VRTK_PlayAreaCursor` script on the same GameObject as the Pointer Renderer script it is linked to.
              * Link the required Play Area Cursor script to the `Playarea Cursor` parameter on the required Pointer Renderer script.
            
             **Script Dependencies:**
              * A Base Pointer Renderer script attached to a valid Pointer script is required so the PlayArea Cursor script can be linked to follow the valid Base Pointer Renderer cursor GameObject.
             </remarks>
             <example>
             `VRTK/Examples/012_Controller_PointerWithAreaCollision` shows how a Bezier Pointer with the Play Area Cursor and Collision Detection enabled can be used to traverse a game area but not allow teleporting into areas where the walls or other objects would fall into the play area space enabling the user to enter walls.
             </example>
        </member>
        <member name="E:VRTK.VRTK_PlayAreaCursor.PlayAreaCursorStartCollision">
            <summary>
            Emitted when the play area collides with another object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PlayAreaCursor.PlayAreaCursorEndCollision">
            <summary>
            Emitted when the play area stops colliding with another object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.HasCollided">
            <summary>
            The HasCollided method returns the state of whether the play area cursor has currently collided with another valid object.
            </summary>
            <returns>Returns `true` if the play area is colliding with a valid object and `false` if not.</returns>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.SetHeadsetPositionCompensation(System.Boolean)">
            <summary>
            The SetHeadsetPositionCompensation method determines whether the offset position of the headset from the centre of the play area should be taken into consideration when setting the destination marker. If `true` then it will take the offset position into consideration.
            </summary>
            <param name="state">The state of whether to take the position of the headset within the play area into account when setting the destination marker.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.SetPlayAreaCursorCollision(System.Boolean,UnityEngine.Collider)">
            <summary>
            The SetPlayAreaCursorCollision method determines whether play area collisions should be taken into consideration with the play area cursor.
            </summary>
            <param name="state">The state of whether to check for play area collisions.</param>
            <param name="collider">The state of whether to check for play area collisions.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.SetMaterialColor(UnityEngine.Color,System.Boolean)">
            <summary>
            The SetMaterialColor method sets the current material colour on the play area cursor.
            </summary>
            <param name="color">The colour to update the play area cursor material to.</param>
            <param name="validity">Determines if the colour being set is based from a valid location or invalid location.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.SetPlayAreaCursorTransform(UnityEngine.Vector3)">
            <summary>
            The SetPlayAreaCursorTransform method is used to update the position of the play area cursor in world space to the given location.
            </summary>
            <param name="location">The location where to draw the play area cursor.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.ToggleState(System.Boolean)">
            <summary>
            The ToggleState method enables or disables the visibility of the play area cursor.
            </summary>
            <param name="state">The state of whether to show or hide the play area cursor.</param>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.IsActive">
            <summary>
            The IsActive method returns whether the play area cursor GameObject is active or not.
            </summary>
            <returns>Returns `true` if the play area cursor GameObject is active.</returns>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.GetPlayAreaContainer">
            <summary>
            The GetPlayAreaContainer method returns the created GameObject that holds the play area cursor representation.
            </summary>
            <returns>The GameObject that is the container of the play area cursor.</returns>
        </member>
        <member name="M:VRTK.VRTK_PlayAreaCursor.ToggleVisibility(System.Boolean)">
            <summary>
            The ToggleVisibility method enables or disables the play area cursor renderers to allow the cursor to be seen or hidden.
            </summary>
            <param name="state">The state of the cursor visibility. True will show the renderers and false will hide the renderers.</param>
        </member>
        <member name="T:VRTK.VRTK_Pointer">
             <summary>
             Provides a basis of being able to emit a pointer from a specified GameObject.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_BasePointerRenderer` - The visual representation of the pointer when activated.
            
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the `Controller` parameter.
              * `VRTK_InteractUse` - The use component to utilise when the pointer is to activate the use action on an Interactable Object. This must be applied on the same GameObject as this script if one is not provided via the `Interact Use` parameter.
             
             **Script Usage:**
              * Place the `VRTK_Pointer` script on either:
                * The controller script alias GameObject of the controller to emit the pointer from (e.g. Right Controller Script Alias).
                * Any other scene GameObject and provide a valid `Transform` component to the `Custom Origin` parameter of this script. This does not have to be a controller and can be any GameObject that will emit the pointer.
              * Link the required Base Pointer Renderer script to the `Pointer Renderer` parameter of this script.
             </remarks>
        </member>
        <member name="E:VRTK.VRTK_Pointer.ActivationButtonPressed">
            <summary>
            Emitted when the pointer activation button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Pointer.ActivationButtonReleased">
            <summary>
            Emitted when the pointer activation button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Pointer.SelectionButtonPressed">
            <summary>
            Emitted when the pointer selection button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Pointer.SelectionButtonReleased">
            <summary>
            Emitted when the pointer selection button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Pointer.PointerStateValid">
            <summary>
            Emitted when the pointer is in a valid state.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_Pointer.PointerStateInvalid">
            <summary>
            Emitted when the pointer is in an invalid state.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_Pointer.IsActivationButtonPressed">
            <summary>
            The IsActivationButtonPressed method returns whether the configured activation button is being pressed.
            </summary>
            <returns>Returns `true` if the activationButton is being pressed.</returns>
        </member>
        <member name="M:VRTK.VRTK_Pointer.IsSelectionButtonPressed">
            <summary>
            The IsSelectionButtonPressed method returns whether the configured activation button is being pressed.
            </summary>
            <returns>Returns `true` if the selectionButton is being pressed.</returns>
        </member>
        <member name="M:VRTK.VRTK_Pointer.PointerEnter(UnityEngine.RaycastHit)">
            <summary>
            The PointerEnter method emits a DestinationMarkerEnter event when the pointer first enters a valid object, it emits a DestinationMarkerHover for every following frame that the pointer stays over the valid object.
            </summary>
            <param name="givenHit">The valid collision.</param>
        </member>
        <member name="M:VRTK.VRTK_Pointer.PointerExit(UnityEngine.RaycastHit)">
            <summary>
            The PointerExit method emits a DestinationMarkerExit event when the pointer leaves a previously entered object.
            </summary>
            <param name="givenHit">The previous valid collision.</param>
        </member>
        <member name="M:VRTK.VRTK_Pointer.CanActivate">
            <summary>
            The CanActivate method is used to determine if the pointer has passed the activation time limit.
            </summary>
            <returns>Returns `true` if the pointer can be activated.</returns>
        </member>
        <member name="M:VRTK.VRTK_Pointer.CanSelect">
            <summary>
            The CanSelect method is used to determine if the pointer has passed the selection time limit.
            </summary>
            <returns>Returns `true` if the pointer can execute the select action.</returns>
        </member>
        <member name="M:VRTK.VRTK_Pointer.IsPointerActive">
            <summary>
            The IsPointerActive method is used to determine if the pointer's current state is active or not.
            </summary>
            <returns>Returns `true` if the pointer is currently active.</returns>
        </member>
        <member name="M:VRTK.VRTK_Pointer.ResetActivationTimer(System.Boolean)">
            <summary>
            The ResetActivationTimer method is used to reset the pointer activation timer to the next valid activation time.
            </summary>
            <param name="forceZero">If this is `true` then the next activation time will be 0.</param>
        </member>
        <member name="M:VRTK.VRTK_Pointer.ResetSelectionTimer(System.Boolean)">
            <summary>
            The ResetSelectionTimer method is used to reset the pointer selection timer to the next valid activation time.
            </summary>
            <param name="forceZero">If this is `true` then the next activation time will be 0.</param>
        </member>
        <member name="M:VRTK.VRTK_Pointer.Toggle(System.Boolean)">
            <summary>
            The Toggle method is used to enable or disable the pointer.
            </summary>
            <param name="state">If `true` the pointer will be enabled if possible, if `false` the pointer will be disabled if possible.</param>
        </member>
        <member name="M:VRTK.VRTK_Pointer.IsStateValid">
            <summary>
            The IsStateValid method is used to determine if the pointer is currently in a valid state (i.e. on it's valid colour).
            </summary>
            <returns>Returns `true` if the pointer is in the valid state (showing the valid colour), returns `false` if the pointer is in the invalid state (showing the invalid colour).</returns>
        </member>
        <member name="T:VRTK.BodyPhysicsEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="target">The target GameObject the event is dealing with.</param>
            <param name="collider">An optional collider that the body physics is colliding with.</param>
        </member>
        <member name="T:VRTK.BodyPhysicsEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.BodyPhysicsEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_BodyPhysics">
             <summary>
             Allows the play area to be affected by physics and detect collisions with other valid geometry.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_BasicTeleport` - A Teleporter script to use when snapping the play area to the nearest floor when releasing from grab.
            
             **Script Usage:**
              * Place the `VRTK_BodyPhysics` script on any active scene GameObject.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has a collection of walls and slopes that can be traversed by the user with the touchpad but the user cannot pass through the objects as they are collidable and the rigidbody physics won't allow the intersection to occur.
             </example>
        </member>
        <member name="T:VRTK.VRTK_BodyPhysics.FallingRestrictors">
            <summary>
            Options for testing if a play space fall is valid
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.NoRestriction">
            <summary>
            Always drop to nearest floor when the headset is no longer over the current standing object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.LeftController">
            <summary>
            Don't drop to nearest floor  if the Left Controller is still over the current standing object even if the headset isn't.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.RightController">
            <summary>
            Don't drop to nearest floor  if the Right Controller is still over the current standing object even if the headset isn't.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.EitherController">
            <summary>
            Don't drop to nearest floor  if Either Controller is still over the current standing object even if the headset isn't.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.BothControllers">
            <summary>
            Don't drop to nearest floor only if Both Controllers are still over the current standing object even if the headset isn't.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_BodyPhysics.FallingRestrictors.AlwaysRestrict">
            <summary>
            Never drop to nearest floor when the headset is no longer over the current standing object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StartFalling">
            <summary>
            Emitted when a fall begins.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StopFalling">
            <summary>
            Emitted when a fall ends.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StartMoving">
            <summary>
            Emitted when movement in the play area begins.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StopMoving">
            <summary>
            Emitted when movement in the play area ends.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StartColliding">
            <summary>
            Emitted when the body collider starts colliding with another game object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StopColliding">
            <summary>
            Emitted when the body collider stops colliding with another game object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StartLeaning">
            <summary>
            Emitted when the body collider starts leaning over another game object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StopLeaning">
            <summary>
            Emitted when the body collider stops leaning over another game object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StartTouchingGround">
            <summary>
            Emitted when the body collider starts touching the ground.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_BodyPhysics.StopTouchingGround">
            <summary>
            Emitted when the body collider stops touching the ground.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ArePhysicsEnabled">
            <summary>
            The ArePhysicsEnabled method determines whether the body physics are set to interact with other scene physics objects.
            </summary>
            <returns>Returns `true` if the body physics will interact with other scene physics objects and `false` if the body physics will ignore other scene physics objects.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ApplyBodyVelocity(UnityEngine.Vector3,System.Boolean,System.Boolean)">
            <summary>
            The ApplyBodyVelocity method applies a given velocity to the rigidbody attached to the body physics.
            </summary>
            <param name="velocity">The velocity to apply.</param>
            <param name="forcePhysicsOn">If `true` will toggle the body collision physics back on if enable body collisions is true.</param>
            <param name="applyMomentum">If `true` then the existing momentum of the play area will be applied as a force to the resulting velocity.</param>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ToggleOnGround(System.Boolean)">
            <summary>
            The ToggleOnGround method sets whether the body is considered on the ground or not.
            </summary>
            <param name="state">If `true` then body physics are set to being on the ground.</param>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.TogglePreventSnapToFloor(System.Boolean)">
            <summary>
            The PreventSnapToFloor method sets whether the snap to floor mechanic should be used.
            </summary>
            <param name="state">If `true` the the snap to floor mechanic will not execute.</param>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ForceSnapToFloor">
            <summary>
            The ForceSnapToFloor method disables the prevent snap to floor and forces the snap to nearest floor action.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.IsFalling">
            <summary>
            The IsFalling method returns the falling state of the body.
            </summary>
            <returns>Returns `true` if the body is currently falling via gravity or via teleport.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.IsMoving">
            <summary>
            The IsMoving method returns the moving within play area state of the body.
            </summary>
            <returns>Returns true if the user is currently walking around their play area space.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.IsLeaning">
            <summary>
            The IsLeaning method returns the leaning state of the user.
            </summary>
            <returns>Returns `true` if the user is considered to be leaning over an object.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.OnGround">
            <summary>
            The OnGround method returns whether the user is currently standing on the ground or not.
            </summary>
            <returns>Returns `true` if the play area is on the ground and false if the play area is in the air.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.GetVelocity">
            <summary>
            The GetVelocity method returns the velocity of the body physics rigidbody.
            </summary>
            <returns>The velocity of the body physics rigidbody.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.GetAngularVelocity">
            <summary>
            The GetAngularVelocity method returns the angular velocity of the body physics rigidbody.
            </summary>
            <returns>The angular velocity of the body physics rigidbody.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ResetVelocities">
            <summary>
            The ResetVelocities method sets the rigidbody velocity and angular velocity to zero to stop the Play Area rigidbody from continuing to move if it has a velocity already.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ResetFalling">
            <summary>
            The ResetFalling method force stops any falling states and conditions that might be set on this object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.GetBodyColliderContainer">
            <summary>
            The GetBodyColliderContainer method returns the auto generated GameObject that contains the body colliders.
            </summary>
            <returns>The auto generated body collider GameObject.</returns>
            <returns></returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.GetFootColliderContainer">
            <summary>
            The GetFootColliderContainer method returns the auto generated GameObject that contains the foot colliders.
            </summary>
            <returns>The auto generated foot collider GameObject.</returns>
            <returns></returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.GetCurrentCollidingObject">
            <summary>
            The GetCurrentCollidingObject method returns the object that the body physics colliders are currently colliding with.
            </summary>
            <returns>The GameObject that is colliding with the body physics colliders.</returns>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.ResetIgnoredCollisions">
            <summary>
            The ResetIgnoredCollisions method is used to clear any stored ignored colliders in case the `Ignore Collisions On` array parameter is changed at runtime. This needs to be called manually if changes are made at runtime.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_BodyPhysics.SweepCollision(UnityEngine.Vector3,System.Single)">
            <summary>
            The SweepCollision method tests to see if a collision will occur with the body collider in a given direction and distance.
            </summary>
            <param name="direction">The direction to test for the potential collision.</param>
            <param name="maxDistance">The maximum distance to check for a potential collision.</param>
            <returns>Returns `true` if a collision will occur on the given direction over the given maxium distance. Returns `false` if there is no collision about to happen.</returns>
        </member>
        <member name="T:VRTK.HeadsetCollisionEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="collider">The Collider of the game object the headset has collided with.</param>
            <param name="currentTransform">The current Transform of the object that the Headset Collision Fade script is attached to (Camera).</param>
        </member>
        <member name="T:VRTK.HeadsetCollisionEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.HeadsetCollisionEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_HeadsetCollision">
            <summary>
            Denotes when the HMD is colliding with valid geometry.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_HeadsetCollision` script on any active scene GameObject.
            </remarks>
            <example>
            `VRTK/Examples/011_Camera_HeadSetCollisionFading` has collidable walls around the play area and if the user puts their head into any of the walls then the headset will fade to black.
            </example>
        </member>
        <member name="E:VRTK.VRTK_HeadsetCollision.HeadsetCollisionDetect">
            <summary>
            Emitted when the user's headset collides with another game object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetCollision.HeadsetCollisionEnded">
            <summary>
            Emitted when the user's headset stops colliding with a game object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_HeadsetCollision.headsetColliding">
            <summary>
            Determines if the headset is currently colliding with another object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_HeadsetCollision.collidingWith">
            <summary>
            Stores the collider of what the headset is colliding with.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_HeadsetCollision.IsColliding">
            <summary>
            The IsColliding method is used to determine if the headset is currently colliding with a valid game object and returns true if it is and false if it is not colliding with anything or an invalid game object.
            </summary>
            <returns>Returns `true` if the headset is currently colliding with a valid game object.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetCollision.GetHeadsetColliderContainer">
            <summary>
            The GetHeadsetColliderContainer method returns the auto generated GameObject that contains the headset collider.
            </summary>
            <returns>The auto generated headset collider GameObject.</returns>
        </member>
        <member name="T:VRTK.VRTK_HeadsetCollisionFade">
             <summary>
             Initiates a fade of the headset view when a headset collision event is detected.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_HeadsetCollision` - A Headset Collision script to determine when the HMD has collided with valid geometry.
              * `VRTK_HeadsetFade` - A Headset Fade script to alter the visible colour on the HMD view.
            
             **Script Usage:**
              * Place the `VRTK_HeadsetCollisionFade` script on any active scene GameObject.
             </remarks>
             <example>
             `VRTK/Examples/011_Camera_HeadSetCollisionFading` has collidable walls around the play area and if the user puts their head into any of the walls then the headset will fade to black.
             </example>
        </member>
        <member name="T:VRTK.HeadsetControllerAwareEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="raycastHit">The Raycast Hit struct of item that is obscuring the path to the controller.</param>
            <param name="controllerReference">The reference to the controller that is being or has been obscured or being or has been glanced.</param>
        </member>
        <member name="T:VRTK.HeadsetControllerAwareEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.HeadsetControllerAwareEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_HeadsetControllerAware">
            <summary>
            Determines whether the HMD is in line of sight to the controllers or if the headset is directly looking at one of the controllers.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_HeadsetControllerAware` script on any active scene GameObject.
            </remarks>
            <example>
            `VRTK/Examples/029_Controller_Tooltips` displays tooltips that have been added to the controllers and are only visible when the controller is being looked at.
            </example>
        </member>
        <member name="E:VRTK.VRTK_HeadsetControllerAware.ControllerObscured">
            <summary>
            Emitted when the controller is obscured by another object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetControllerAware.ControllerUnobscured">
            <summary>
            Emitted when the controller is no longer obscured by an object.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetControllerAware.ControllerGlanceEnter">
            <summary>
            Emitted when the controller is seen by the headset view.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetControllerAware.ControllerGlanceExit">
            <summary>
            Emitted when the controller is no longer seen by the headset view.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_HeadsetControllerAware.LeftControllerObscured">
            <summary>
            The LeftControllerObscured method returns the state of if the left controller is being obscured from the path of the headset.
            </summary>
            <returns>Returns `true` if the path between the headset and the controller is obscured.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetControllerAware.RightControllerObscured">
            <summary>
            The RightControllerObscured method returns the state of if the right controller is being obscured from the path of the headset.
            </summary>
            <returns>Returns `true` if the path between the headset and the controller is obscured.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetControllerAware.LeftControllerGlanced">
            <summary>
            the LeftControllerGlanced method returns the state of if the headset is currently looking at the left controller or not.
            </summary>
            <returns>Returns `true` if the headset can currently see the controller within the given radius threshold.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetControllerAware.RightControllerGlanced">
            <summary>
            the RightControllerGlanced method returns the state of if the headset is currently looking at the right controller or not.
            </summary>
            <returns>Returns `true` if the headset can currently see the controller within the given radius threshold.</returns>
        </member>
        <member name="T:VRTK.HeadsetFadeEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="timeTillComplete">A float that is the duration for the fade/unfade process has remaining.</param>
            <param name="currentTransform">The current Transform of the object that the Headset Fade script is attached to (Camera).</param>
        </member>
        <member name="T:VRTK.HeadsetFadeEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.HeadsetFadeEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_HeadsetFade">
            <summary>
            Provides the ability to change the colour of the headset view to a specified colour over a given duration.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_HeadsetFade` script on any active scene GameObject.
            </remarks>
            <example>
            `VRTK/Examples/011_Camera_HeadSetCollisionFading` has collidable walls around the play area and if the user puts their head into any of the walls then the headset will fade to black.
            </example>
        </member>
        <member name="E:VRTK.VRTK_HeadsetFade.HeadsetFadeStart">
            <summary>
            Emitted when the user's headset begins to fade to a given colour.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetFade.HeadsetFadeComplete">
            <summary>
            Emitted when the user's headset has completed the fade and is now fully at the given colour.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetFade.HeadsetUnfadeStart">
            <summary>
            Emitted when the user's headset begins to unfade back to a transparent colour.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_HeadsetFade.HeadsetUnfadeComplete">
            <summary>
            Emitted when the user's headset has completed unfading and is now fully transparent again.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_HeadsetFade.IsFaded">
            <summary>
            The IsFaded method returns true if the headset is currently fading or has completely faded and returns false if it is completely unfaded.
            </summary>
            <returns>Returns `true` if the headset is currently fading or faded.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetFade.IsTransitioning">
            <summary>
            The IsTransitioning method returns true if the headset is currently fading or unfading and returns false if it is completely faded or unfaded.
            </summary>
            <returns>Returns `true` if the headset is currently in the process of fading or unfading.</returns>
        </member>
        <member name="M:VRTK.VRTK_HeadsetFade.Fade(UnityEngine.Color,System.Single)">
            <summary>
            The Fade method initiates a change in the colour of the headset view to the given colour over a given duration.
            </summary>
            <param name="color">The colour to fade the headset view to.</param>
            <param name="duration">The time in seconds to take to complete the fade transition.</param>
        </member>
        <member name="M:VRTK.VRTK_HeadsetFade.Unfade(System.Single)">
            <summary>
            The Unfade method initiates the headset to change colour back to a transparent colour over a given duration.
            </summary>
            <param name="duration">The time in seconds to take to complete the unfade transition.</param>
        </member>
        <member name="T:VRTK.VRTK_HipTracking">
            <summary>
            Attempts to provide the relative position of a hip without the need for additional hardware sensors.
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_HipTracking` script on any active scene GameObject and this GameObject will then track to the estimated hip position.
            </remarks>
        </member>
        <member name="T:VRTK.PositionRewindEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="collidedPosition">The position of the play area when it collded.</param>
            <param name="resetPosition">The position of the play area when it has been rewinded to a safe position.</param>
        </member>
        <member name="T:VRTK.PositionRewindEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.PositionRewindEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_PositionRewind">
             <summary>
             Attempts to rewind the position of the play area to a last know valid position upon the headset collision event.
             </summary>
             <remarks>
             **Required Components:**
              * `VRTK_BodyPhysics` - A Body Physics script to manage the collisions of the body presence within the scene.
              * `VRTK_HeadsetCollision` - A Headset Collision script to determine when the headset is colliding with valid geometry.
            
             **Script Usage:**
              * Place the `VRTK_PositionRewind` script on any active scene GameObject.
             </remarks>
             <example>
             `VRTK/Examples/017_CameraRig_TouchpadWalking` has the position rewind script to reset the user's position if they walk into objects.
             </example>
        </member>
        <member name="T:VRTK.VRTK_PositionRewind.CollisionDetectors">
            <summary>
            Valid collision detectors.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PositionRewind.CollisionDetectors.HeadsetOnly">
            <summary>
            Listen for collisions on the headset collider only.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PositionRewind.CollisionDetectors.BodyOnly">
            <summary>
            Listen for collisions on the body physics collider only.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PositionRewind.CollisionDetectors.HeadsetAndBody">
            <summary>
            Listen for collisions on both the headset collider and body physics collider.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_PositionRewind.PositionRewindToSafe">
            <summary>
            Emitted when the draggable item is successfully dropped.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PositionRewind.SetLastGoodPosition">
            <summary>
            The SetLastGoodPosition method stores the current valid play area and headset position.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PositionRewind.RewindPosition">
            <summary>
            The RewindPosition method resets the play area position to the last known good position of the play area.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_UICanvas">
             <summary>
             Denotes a Unity World UI Canvas can be interacted with a UIPointer script.
             </summary>
             <remarks>
             **Script Usage:**
              * Place the `VRTK_UICanvas` script on the Unity World UI Canvas to allow UIPointer interactions with.
            
             **Script Dependencies:**
              * A UI Pointer attached to another GameObject (e.g. controller script alias) to interact with the UICanvas script.
             </remarks>
             <example>
             `VRTK/Examples/034_Controls_InteractingWithUnityUI` uses the `VRTK_UICanvas` script on two of the canvases to show how the UI Pointer can interact with them.
             </example>
        </member>
        <member name="T:VRTK.UIDraggableItemEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="target">The target the item is dragged onto.</param>
        </member>
        <member name="T:VRTK.UIDraggableItemEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.UIDraggableItemEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_UIDraggableItem">
             <summary>
             Denotes a Unity UI Element as being draggable on the UI Canvas.
             </summary>
             <remarks>
               > If a UI Draggable item is set to `Restrict To Drop Zone = true` then the UI Draggable item must be a child of an element that has the VRTK_UIDropZone script applied to it to ensure it starts in a valid drop zone.
            
             **Script Usage:**
              * Place the `VRTK_UIDraggableItem` script on the Unity UI element that is to be dragged.
             </remarks>
             <example>
             `VRTK/Examples/034_Controls_InteractingWithUnityUI` demonstrates a collection of UI elements that are draggable
             </example>
        </member>
        <member name="F:VRTK.VRTK_UIDraggableItem.validDropZone">
            <summary>
            The current valid drop zone the dragged element is hovering over.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIDraggableItem.DraggableItemDropped">
            <summary>
            Emitted when the draggable item is successfully dropped.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIDraggableItem.DraggableItemReset">
            <summary>
            Emitted when the draggable item is reset.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_UIDropZone">
             <summary>
             Specifies a Unity UI Element as being a valid drop zone location for a UI Draggable element.
             </summary>
             <remarks>
               > It's appropriate to use a Panel UI element as a drop zone with a layout group applied so new children dropped into the drop zone automatically align.
            
             **Script Usage:**
              * Place the `VRTK_UIDropZone` script on the Unity UI element that is to become the drop zone.
             </remarks>
             <example>
             `VRTK/Examples/034_Controls_InteractingWithUnityUI` demonstrates a collection of UI Drop Zones.
             </example>
        </member>
        <member name="T:VRTK.UIPointerEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="controllerReference">The reference to the controller that was used.</param>
            <param name="isActive">The state of whether the UI Pointer is currently active or not.</param>
            <param name="currentTarget">The current UI element that the pointer is colliding with.</param>
            <param name="previousTarget">The previous UI element that the pointer was colliding with.</param>
            <param name="raycastResult">The raw raycast result of the UI ray collision.</param>
        </member>
        <member name="T:VRTK.UIPointerEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.UIPointerEventArgs"/></param>
        </member>
        <member name="T:VRTK.VRTK_UIPointer">
             <summary>
             Provides the ability to interact with UICanvas elements and the contained Unity UI elements within.
             </summary>
             <remarks>
             **Optional Components:**
              * `VRTK_ControllerEvents` - The events component to listen for the button presses on. This must be applied on the same GameObject as this script if one is not provided via the `Controller` parameter.
            
             **Script Usage:**
              * Place the `VRTK_UIPointer` script on either:
                * The controller script alias GameObject of the controller to emit the UIPointer from (e.g. Right Controller Script Alias).
                * Any other scene GameObject and provide a valid `Transform` component to the `Pointer Origin Transform` parameter of this script. This does not have to be a controller and can be any GameObject that will emit the UIPointer.
            
             **Script Dependencies:**
              * A UI Canvas attached to a Unity World UI Canvas.
             </remarks>
             <example>
             `VRTK/Examples/034_Controls_InteractingWithUnityUI` uses the `VRTK_UIPointer` script on the right Controller to allow for the interaction with Unity UI elements using a Simple Pointer beam. The left Controller controls a Simple Pointer on the headset to demonstrate gaze interaction with Unity UI elements.
             </example>
        </member>
        <member name="T:VRTK.VRTK_UIPointer.ActivationMethods">
            <summary>
            Methods of activation.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.ActivationMethods.HoldButton">
            <summary>
            Only activates the UI Pointer when the Pointer button on the controller is pressed and held down.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.ActivationMethods.ToggleButton">
            <summary>
            Activates the UI Pointer on the first click of the Pointer button on the controller and it stays active until the Pointer button is clicked again.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.ActivationMethods.AlwaysOn">
            <summary>
            The UI Pointer is always active regardless of whether the Pointer button on the controller is pressed or not.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_UIPointer.ClickMethods">
            <summary>
            Methods of when to consider a UI Click action
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.ClickMethods.ClickOnButtonUp">
            <summary>
            Consider a UI Click action has happened when the UI Click alias button is released.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.ClickMethods.ClickOnButtonDown">
            <summary>
            Consider a UI Click action has happened when the UI Click alias button is pressed.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.autoActivatingCanvas">
            <summary>
            The GameObject of the front trigger activator of the canvas currently being activated by this pointer.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_UIPointer.collisionClick">
            <summary>
            Determines if the UI Pointer has collided with a valid canvas that has collision click turned on.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.ActivationButtonPressed">
            <summary>
            Emitted when the UI activation button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.ActivationButtonReleased">
            <summary>
            Emitted when the UI activation button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.SelectionButtonPressed">
            <summary>
            Emitted when the UI selection button is pressed.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.SelectionButtonReleased">
            <summary>
            Emitted when the UI selection button is released.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.UIPointerElementEnter">
            <summary>
            Emitted when the UI Pointer is colliding with a valid UI element.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.UIPointerElementExit">
            <summary>
            Emitted when the UI Pointer is no longer colliding with any valid UI elements.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.UIPointerElementClick">
            <summary>
            Emitted when the UI Pointer has clicked the currently collided UI element.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.UIPointerElementDragStart">
            <summary>
            Emitted when the UI Pointer begins dragging a valid UI element.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_UIPointer.UIPointerElementDragEnd">
            <summary>
            Emitted when the UI Pointer stops dragging a valid UI element.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.GetPointerLength(System.Int32)">
            <summary>
            The GetPointerLength method retrieves the maximum UI Pointer length for the given pointer ID.
            </summary>
            <param name="pointerId">The pointer ID for the UI Pointer to recieve the length for.</param>
            <returns>The maximum length the UI Pointer will cast to.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.SetEventSystem(UnityEngine.EventSystems.EventSystem)">
            <summary>
            The SetEventSystem method is used to set up the global Unity event system for the UI pointer. It also handles disabling the existing Standalone Input Module that exists on the EventSystem and adds a custom VRTK Event System VR Input component that is required for interacting with the UI with VR inputs.
            </summary>
            <param name="eventSystem">The global Unity event system to be used by the UI pointers.</param>
            <returns>A custom input module that is used to detect input from VR pointers.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.RemoveEventSystem">
            <summary>
            The RemoveEventSystem resets the Unity EventSystem back to the original state before the VRTK_VRInputModule was swapped for it.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.PointerActive">
            <summary>
            The PointerActive method determines if the ui pointer beam should be active based on whether the pointer alias is being held and whether the Hold Button To Use parameter is checked.
            </summary>
            <returns>Returns `true` if the ui pointer should be currently active.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.IsActivationButtonPressed">
            <summary>
            The IsActivationButtonPressed method is used to determine if the configured activation button is currently in the active state.
            </summary>
            <returns>Returns `true` if the activation button is active.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.IsSelectionButtonPressed">
            <summary>
            The IsSelectionButtonPressed method is used to determine if the configured selection button is currently in the active state.
            </summary>
            <returns>Returns `true` if the selection button is active.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.ValidClick(System.Boolean,System.Boolean)">
            <summary>
            The ValidClick method determines if the UI Click button is in a valid state to register a click action.
            </summary>
            <param name="checkLastClick">If this is true then the last frame's state of the UI Click button is also checked to see if a valid click has happened.</param>
            <param name="lastClickState">This determines what the last frame's state of the UI Click button should be in for it to be a valid click.</param>
            <returns>Returns `true` if the UI Click button is in a valid state to action a click, returns `false` if it is not in a valid state.</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.GetOriginPosition">
            <summary>
            The GetOriginPosition method returns the relevant transform position for the pointer based on whether the pointerOriginTransform variable is valid.
            </summary>
            <returns>A Vector3 of the pointer transform position</returns>
        </member>
        <member name="M:VRTK.VRTK_UIPointer.GetOriginForward">
            <summary>
            The GetOriginPosition method returns the relevant transform forward for the pointer based on whether the pointerOriginTransform variable is valid.
            </summary>
            <returns>A Vector3 of the pointer transform forward</returns>
        </member>
        <member name="T:VRTK.VRTK_ObjectFollow">
            <summary>
            Abstract class that allows to change one game object's properties to follow another game object.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_ObjectFollow.targetPosition">
            <summary>
            The position that results by following `gameObjectToFollow`.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_ObjectFollow.targetRotation">
            <summary>
            The rotation that results by following `gameObjectToFollow`.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_ObjectFollow.targetScale">
            <summary>
            The scale that results by following `gameObjectToFollow`.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_ObjectFollow.Follow">
            <summary>
            Follow `gameObjectToFollow` using the current settings.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_RigidbodyFollow">
            <summary>
            Changes one GameObject's rigidbody to follow another GameObject's rigidbody.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_RigidbodyFollow.MovementOption">
            <summary>
            Specifies how to position and rotate the rigidbody.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RigidbodyFollow.MovementOption.Set">
            <summary>
            Use Rigidbody.position and Rigidbody.rotation.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RigidbodyFollow.MovementOption.Move">
            <summary>
            Use Rigidbody.MovePosition and Rigidbody.MoveRotation.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RigidbodyFollow.MovementOption.Add">
            <summary>
            Use Rigidbody.AddForce(Vector3) and Rigidbody.AddTorque(Vector3).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_RigidbodyFollow.MovementOption.Track">
            <summary>
            Use velocity and angular velocity with MoveTowards.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_RigidbodyFollow.Follow">
            <summary>
            Follow `gameObjectToFollow` using the current settings.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_TransformFollow">
            <summary>
            Changes one GameObject's transform to follow another GameObject's transform.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_TransformFollow.FollowMoment">
            <summary>
            The moment at which to follow.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_TransformFollow.FollowMoment.OnFixedUpdate">
            <summary>
            Follow in the FixedUpdate method.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_TransformFollow.FollowMoment.OnUpdate">
            <summary>
            Follow in the Update method.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_TransformFollow.FollowMoment.OnLateUpdate">
            <summary>
            Follow in the LateUpdate method.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_TransformFollow.FollowMoment.OnPreRender">
            <summary>
            Follow in the OnPreRender method. (This script doesn't have to be attached to a camera).
            </summary>
        </member>
        <member name="F:VRTK.VRTK_TransformFollow.FollowMoment.OnPreCull">
            <summary>
            Follow in the OnPreCull method. (This script doesn't have to be attached to a camera).
            </summary>
        </member>
        <member name="M:VRTK.VRTK_TransformFollow.Follow">
            <summary>
            Follow `gameObjectToFollow` using the current settings.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKInfo">
            <summary>
            Holds all the info necessary to describe an SDK.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKInfo.type">
            <summary>
            The type of the SDK.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKInfo.originalTypeNameWhenFallbackIsUsed">
            <summary>
            The name of the type of which this SDK info was created from. This is only used if said type wasn't found.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKInfo.description">
            <summary>
            The description of the SDK.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKInfo.Create``3">
            <summary>
            Creates new SDK infos for a type that is known at compile time.
            </summary>
            <typeparam name="BaseType">The SDK base type. Must be a subclass of SDK_Base.</typeparam>
            <typeparam name="FallbackType">The SDK type to fall back on if problems occur. Must be a subclass of `BaseType`.</typeparam>
            <typeparam name="ActualType">The SDK type to use. Must be a subclass of `BaseType`.</typeparam>
            <returns>Multiple newly created instances.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKInfo.Create``2(System.Type)">
            <summary>
            Creates new SDK infos for a type.
            </summary>
            <typeparam name="BaseType">The SDK base type. Must be a subclass of SDK_Base.</typeparam>
            <typeparam name="FallbackType">The SDK type to fall back on if problems occur. Must be a subclass of `BaseType.</typeparam>
            <param name="actualType">The SDK type to use. Must be a subclass of `BaseType.</param>
            <returns>Multiple newly created instances.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKInfo.#ctor(VRTK.VRTK_SDKInfo)">
            <summary>
            Creates a new SDK info by copying an existing one.
            </summary>
            <param name="infoToCopy">The SDK info to copy.</param>
        </member>
        <member name="T:VRTK.VRTK_SDKManager">
            <summary>
            The SDK Manager script provides configuration of supported SDKs and manages a list of VRTK_SDKSetups to use.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKManager.ScriptingDefineSymbolPredicateInfo">
            <summary>
            A helper class that simply holds references to both the SDK_ScriptingDefineSymbolPredicateAttribute and the method info of the method the attribute is defined on.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKManager.ScriptingDefineSymbolPredicateInfo.attribute">
            <summary>
            The predicate attribute.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKManager.ScriptingDefineSymbolPredicateInfo.methodInfo">
            <summary>
            The method info of the method the attribute is defined on.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.ScriptingDefineSymbolPredicateInfo.#ctor(VRTK.SDK_ScriptingDefineSymbolPredicateAttribute,System.Reflection.MethodInfo)">
            <summary>
            Event Payload. Constructs a new instance with the specified predicate attribute and associated method info.
            </summary>
            <param name="attribute">The predicate attribute.</param>
            <param name="methodInfo">The method info of the method the attribute is defined on.</param>
        </member>
        <member name="T:VRTK.VRTK_SDKManager.LoadedSetupChangeEventArgs">
            <summary>
            Event Payload
            </summary>
            <param name="previousSetup">The previous loaded Setup. `null` if no previous Setup was loaded.</param>
            <param name="currentSetup">The current loaded Setup. `null` if no Setup is loaded anymore. See `errorMessage` to check whether this is `null` because of an error.</param>
            <param name="errorMessage">Explains why loading a list of Setups wasn't successful if `currentSetup` is `null` and an error occurred. `null` if no error occurred.</param>
        </member>
        <member name="T:VRTK.VRTK_SDKManager.LoadedSetupChangeEventHandler">
            <summary>
            Event Payload
            </summary>
            <param name="sender">this object</param>
            <param name="e"><see cref="T:VRTK.VRTK_SDKManager.LoadedSetupChangeEventArgs"/></param>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.AvailableScriptingDefineSymbolPredicateInfos">
            <summary>
            All found scripting define symbol predicate attributes with associated method info.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKManager.SDKFallbackTypesByBaseType">
            <summary>
            Specifies the fallback SDK types for every base SDK type.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.AvailableSystemSDKInfos">
            <summary>
            All available system SDK infos.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.AvailableBoundariesSDKInfos">
            <summary>
            All available boundaries SDK infos.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.AvailableHeadsetSDKInfos">
            <summary>
            All available headset SDK infos.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.AvailableControllerSDKInfos">
            <summary>
            All available controller SDK infos.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.InstalledSystemSDKInfos">
            <summary>
            All installed system SDK infos. This is a subset of `AvailableSystemSDKInfos`.
            It contains only those available SDK infos for which an SDK_ScriptingDefineSymbolPredicateAttribute exists that
            uses the same symbol and whose associated method returns true.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.InstalledBoundariesSDKInfos">
            <summary>
            All installed boundaries SDK infos. This is a subset of `AvailableBoundariesSDKInfos`.
            It contains only those available SDK infos for which an SDK_ScriptingDefineSymbolPredicateAttribute exists
            that uses the same symbol and whose associated method returns true.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.InstalledHeadsetSDKInfos">
            <summary>
            All installed headset SDK infos. This is a subset of `AvailableHeadsetSDKInfos`.
            It contains only those available SDK infos for which an SDK_ScriptingDefineSymbolPredicateAttribute exists
            that uses the same symbol and whose associated method returns true.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.InstalledControllerSDKInfos">
            <summary>
            All installed controller SDK infos. This is a subset of `AvailableControllerSDKInfos`.
            It contains only those available SDK infos for which an SDK_ScriptingDefineSymbolPredicateAttribute exists
            that uses the same symbol and whose associated method returns true.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.instance">
            <summary>
            The singleton instance to access the SDK Manager variables from.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKManager.delayedToggleBehaviours">
            <summary>
            A collection of behaviours to toggle on loaded setup change.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.ValidInstance">
            <summary>
            The ValidInstance method returns whether the SDK Manager isntance is valid (i.e. it's not null).
            </summary>
            <returns>Returns `true` if the SDK Manager instance is valid or returns `false` if it is null.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AttemptAddBehaviourToToggleOnLoadedSetupChange(UnityEngine.Behaviour)">
            <summary>
            The AttemptAddBehaviourToToggleOnLoadedSetupChange method will attempt to add the given behaviour to the loaded setup change toggle if the SDK Manager instance exists. If it doesn't exist then it adds it to the `delayedToggleBehaviours` HashSet to be manually added later with the `ProcessDelayedToggleBehaviours` method.
            </summary>
            <param name="givenBehaviour">The behaviour to add.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AttemptRemoveBehaviourToToggleOnLoadedSetupChange(UnityEngine.Behaviour)">
            <summary>
            The AttemptRemoveBehaviourToToggleOnLoadedSetupChange method will attempt to remove the given behaviour from the loaded setup change toggle if the SDK Manager instance exists.
            </summary>
            <param name="givenBehaviour">The behaviour to remove.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.ProcessDelayedToggleBehaviours">
            <summary>
            The ProcessDelayedToggleBehaviours method will attempt to addd the behaviours in the `delayedToggleBehaviours` HashSet to the loaded setup change toggle.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.SubscribeLoadedSetupChanged(VRTK.VRTK_SDKManager.LoadedSetupChangeEventHandler)">
            <summary>
            The SubscribeLoadedSetupChanged method attempts to register the given callback with the `LoadedSetupChanged` event.
            </summary>
            <param name="callback">The callback to register.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.UnsubscribeLoadedSetupChanged(VRTK.VRTK_SDKManager.LoadedSetupChangeEventHandler)">
            <summary>
            The UnsubscribeLoadedSetupChanged method attempts to unregister the given callback from the `LoadedSetupChanged` event. 
            </summary>
            <param name="callback">The callback to unregister.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.GetLoadedSDKSetup">
            <summary>
            The GetLoadedSDKSetup method returns the current loaded SDK Setup for the SDK Manager instance.
            </summary>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.GetAllSDKSetups">
            <summary>
            The GetAllSDKSetups method returns all valid SDK Setups attached to the SDK Manager instance.
            </summary>
            <returns>An SDKSetup array of all valid SDK Setups for the current SDK Manager instance. If no SDK Manager instance is found then an empty array is returned.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AttemptTryLoadSDKSetup(System.Int32,System.Boolean,VRTK.VRTK_SDKSetup[])">
            <summary>
            The AttemptTryLoadSDKSetup method attempts to load a valid VRTK_SDKSetup from a list if the SDK Manager instance is valid.
            </summary>
            <param name="startIndex">The index of the VRTK_SDKSetup to start the loading with.</param>
            <param name="tryToReinitialize">Whether or not to retry initializing and using the currently set but unusable VR Device.</param>
            <param name="sdkSetups">The list to try to load a VRTK_SDKSetup from.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AttemptTryLoadSDKSetupFromList(System.Boolean)">
            <summary>
            The AttemptUnloadSDKSetup method tries to load a valid VRTK_SDKSetup from setups if the SDK Manager instance is valid.
            </summary>
            <param name="tryUseLastLoadedSetup">Attempt to use the last loaded setup if it's available.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AttemptUnloadSDKSetup(System.Boolean)">
            <summary>
            The AttemptUnloadSDKSetup method attempts to unload the currently loaded VRTK_SDKSetup, if there is one and if the SDK Manager instance is valid.
            </summary>
            <param name="disableVR">Whether to disable VR altogether after unloading the SDK Setup.</param>
            <returns>Returns `true` if the SDK Manager instance was valid.</returns>
        </member>
        <member name="F:VRTK.VRTK_SDKManager.activeScriptingDefineSymbolsWithoutSDKClasses">
            <summary>
            The active (i.e. to be added to the PlayerSettings) scripting define symbol predicate attributes that have no associated SDK classes.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.loadedSetup">
            <summary>
            The loaded SDK Setup. `null` if no setup is currently loaded.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKManager.behavioursToToggleOnLoadedSetupChange">
            <summary>
            All behaviours that need toggling whenever `loadedSetup` changes.
            </summary>
        </member>
        <member name="E:VRTK.VRTK_SDKManager.LoadedSetupChanged">
            <summary>
            The event invoked whenever the loaded SDK Setup changes.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.ManageScriptingDefineSymbols(System.Boolean,System.Boolean)">
            <summary>
            The ManageScriptingDefineSymbols method manages (i.e. adds and removes) the scripting define symbols of the PlayerSettings for the currently set SDK infos.
            This method is only available in the editor, so usage of the method needs to be surrounded by `#if UNITY_EDITOR` and `#endif` when used
            in a type that is also compiled for a standalone build.
            </summary>
            <param name="ignoreAutoManageScriptDefines">Whether to ignore `autoManageScriptDefines` while deciding to manage.</param>
            <param name="ignoreIsActiveAndEnabled">Whether to ignore `Behaviour.isActiveAndEnabled` while deciding to manage.</param>
            <returns>Whether the PlayerSettings' scripting define symbols were changed.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.ManageVRSettings(System.Boolean)">
            <summary>
            The ManageVRSettings method manages (i.e. adds and removes) the VR SDKs of the PlayerSettings for the currently set SDK infos.
            This method is only available in the editor, so usage of the method needs to be surrounded by `#if UNITY_EDITOR` and `#endif` when used
            in a type that is also compiled for a standalone build.
            </summary>
            <param name="force">Whether to ignore `autoManageVRSettings` while deciding to manage.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AddBehaviourToToggleOnLoadedSetupChange(UnityEngine.Behaviour)">
            <summary>
            The AddBehaviourToToggleOnLoadedSetupChange method adds a behaviour to the list of behaviours to toggle when `loadedSetup` changes.
            </summary>
            <param name="behaviour">The behaviour to add.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.RemoveBehaviourToToggleOnLoadedSetupChange(UnityEngine.Behaviour)">
            <summary>
            The RemoveBehaviourToToggleOnLoadedSetupChange method removes a behaviour of the list of behaviours to toggle when `loadedSetup` changes.
            </summary>
            <param name="behaviour">The behaviour to remove.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.TryLoadSDKSetupFromList(System.Boolean)">
            <summary>
            The TryLoadSDKSetupFromList method tries to load a valid VRTK_SDKSetup from setups.
            </summary>
            <param name="tryUseLastLoadedSetup">Attempt to use the last loaded setup if it's available.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.TryLoadSDKSetup(System.Int32,System.Boolean,VRTK.VRTK_SDKSetup[])">
            <summary>
            The TryLoadSDKSetup method tries to load a valid VRTK_SDKSetup from a list.
            </summary>
            <remarks>
            The first loadable VRTK_SDKSetup in the list will be loaded. Will fall back to disable VR if none of the provided Setups is useable.
            </remarks>
            <param name="startIndex">The index of the VRTK_SDKSetup to start the loading with.</param>
            <param name="tryToReinitialize">Whether or not to retry initializing and using the currently set but unusable VR Device.</param>
            <param name="sdkSetups">The list to try to load a VRTK_SDKSetup from.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.SetLoadedSDKSetupToPopulateObjectReferences(VRTK.VRTK_SDKSetup)">
            <summary>
            The SetLoadedSDKSetupToPopulateObjectReferences method sets a given VRTK_SDKSetup as the loaded SDK Setup to be able to use it when populating object references in the SDK Setup.
            </summary>
            <remarks>
            This method should only be called when not playing as it's only for populating the object references.
            This method is only available in the editor, so usage of the method needs to be surrounded by `#if UNITY_EDITOR` and `#endif` when used
            in a type that is also compiled for a standalone build.
            </remarks>
            <param name="setup">The SDK Setup to set as the loaded SDK.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.UnloadSDKSetup(System.Boolean)">
            <summary>
            The UnloadSDKSetup method unloads the currently loaded VRTK_SDKSetup, if there is one.
            </summary>
            <param name="disableVR">Whether to disable VR altogether after unloading the SDK Setup.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.PopulateAvailableScriptingDefineSymbolPredicateInfos">
            <summary>
            Populates `AvailableScriptingDefineSymbolPredicateInfos` with all the available SDK_ScriptingDefineSymbolPredicateAttributes and associated method infos.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.PopulateAvailableAndInstalledSDKInfos">
            <summary>
            Populates the various lists of available and installed SDK infos.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.PopulateAvailableAndInstalledSDKInfos``2(System.Collections.Generic.List{VRTK.VRTK_SDKInfo},System.Collections.Generic.List{VRTK.VRTK_SDKInfo},System.Collections.Generic.ICollection{System.String})">
            <summary>
            Populates the lists of available and installed SDK infos for a specific SDK base type.
            </summary>
            <typeparam name="BaseType">The SDK base type of which to populate the lists for. Must be a subclass of `SDK_Base`.</typeparam>
            <typeparam name="FallbackType">The SDK type to fall back on if problems occur. Must be a subclass of `BaseType`.</typeparam>
            <param name="availableSDKInfos">The list of available SDK infos to populate.</param>
            <param name="installedSDKInfos">The list of installed SDK infos to populate.</param>
            <param name="symbolsOfInstalledSDKs">The list of symbols of all the installed SDKs.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.AutoManageScriptingDefineSymbolsAndManageVRSettings">
            <summary>
            Calls `ManageScriptingDefineSymbols` and `ManageVRSettings` (both without forcing) at the appropriate times when in the editor.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKManager.RemoveLegacyScriptingDefineSymbols">
            <summary>
            Removes scripting define symbols used by previous VRTK versions.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKSetup">
            <summary>
            The SDK Setup describes a list of SDKs and game objects to use.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.systemSDKInfo">
            <summary>
            The info of the SDK to use to deal with all system actions. By setting this to `null` the fallback SDK will be used.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.boundariesSDKInfo">
            <summary>
            The info of the SDK to use to utilize room scale boundaries. By setting this to `null` the fallback SDK will be used.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.headsetSDKInfo">
            <summary>
            The info of the SDK to use to utilize the VR headset. By setting this to `null` the fallback SDK will be used.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.controllerSDKInfo">
            <summary>
            The info of the SDK to use to utilize the input devices. By setting this to `null` the fallback SDK will be used.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.systemSDK">
            <summary>
            The selected system SDK.
            </summary>
            <returns>The currently selected system SDK.</returns>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.boundariesSDK">
            <summary>
            The selected boundaries SDK.
            </summary>
            <returns>The currently selected boundaries SDK.</returns>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.headsetSDK">
            <summary>
            The selected headset SDK.
            </summary>
            <returns>The currently selected headset SDK.</returns>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.controllerSDK">
            <summary>
            The selected controller SDK.
            </summary>
            <returns>The currently selected controller SDK.</returns>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.usedVRDeviceNames">
            <summary>
            The VR device names used by the currently selected SDKs.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_SDKSetup.isValid">
            <summary>
            Whether it's possible to use the Setup. See `GetSimplifiedErrorDescriptions` for more info.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.PopulateObjectReferences(System.Boolean)">
            <summary>
            The PopulateObjectReferences method populates the object references by using the currently set SDKs.
            </summary>
            <param name="force">Whether to ignore `autoPopulateObjectReferences` while deciding to populate.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.GetSimplifiedErrorDescriptions">
            <summary>
            The GetSimplifiedErrorDescriptions method checks the setup for errors and creates an array of error descriptions.
            </summary>
            <remarks>
            The returned error descriptions handle the following cases for the current SDK infos:
            <list type="bullet">
            <item> <description>Its type doesn't exist anymore.</description> </item>
            <item> <description>It's a fallback SDK.</description> </item>
            <item> <description>It doesn't have its scripting define symbols added.</description> </item>
            <item> <description>It's missing its vendor SDK.</description> </item>
            </list>
            Additionally the current SDK infos are checked whether they use multiple VR Devices.
            </remarks>
            <returns>An array of all the error descriptions. Returns an empty array if no errors are found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.OnLoaded(VRTK.VRTK_SDKManager)">
            <summary>
            The OnLoaded method determines when an SDK Setup has been loaded.
            </summary>
            <param name="sender">The SDK Manager that has loaded the SDK Setup.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.OnUnloaded(VRTK.VRTK_SDKManager)">
            <summary>
            The OnUnloaded method determines when an SDK Setup has been unloaded.
            </summary>
            <param name="sender">The SDK Manager that has unloaded the SDK Setup.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.HandleSDKGetter``1(System.String,VRTK.VRTK_SDKInfo,System.Collections.Generic.IEnumerable{VRTK.VRTK_SDKInfo})">
            <summary>
            Handles the various SDK getters by logging potential errors.
            </summary>
            <typeparam name="BaseType">The SDK base type of which to handle the getter for. Must be a subclass of SDK_Base.</typeparam>
            <param name="prettyName">The pretty name of the base SDK to use when logging errors.</param>
            <param name="info">The SDK info of which the SDK getter was called.</param>
            <param name="installedInfos">The installed SDK infos of which the SDK getter was called.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKSetup.GetSDKErrorDescription``1(System.String,VRTK.VRTK_SDKInfo,System.Collections.Generic.IEnumerable{VRTK.VRTK_SDKInfo})">
            <summary>
            Returns an error description in case any of these are true for the current SDK info:
            <list type="bullet">
            <item> <description>Its type doesn't exist anymore.</description> </item>
            <item> <description>It's a fallback SDK.</description> </item>
            <item> <description>It doesn't have its scripting define symbols added.</description> </item>
            <item> <description>It's missing its vendor SDK.</description> </item>
            </list>
            </summary>
            <typeparam name="BaseType">The SDK base type of which to return the error description for. Must be a subclass of SDK_Base.</typeparam>
            <param name="prettyName">The pretty name of the base SDK to use when returning error descriptions.</param>
            <param name="info">The SDK info of which to return the error description for.</param>
            <param name="installedInfos">The installed SDK infos.</param>
            <returns>An error description if there is one, else `null`.</returns>
        </member>
        <member name="T:VRTK.VRTK_AdaptiveQuality">
             <summary>
             Adaptive Quality dynamically changes rendering settings to maintain VR framerate while maximizing GPU utilization.
             </summary>
             <remarks>
               > **Only Compatible With Unity 5.4 and above**
            
             There are two goals:
             <list type="bullet">
             <item> <description>Reduce the chances of dropping frames and reprojecting</description> </item>
             <item> <description>Increase quality when there are idle GPU cycles</description> </item>
             </list>
             <para />
             This script currently changes the following to reach these goals:
             <list type="bullet">
             <item> <description>Rendering resolution and viewport size (aka Dynamic Resolution)</description> </item>
             </list>
             <para />
             In the future it could be changed to also change the following:
             <list type="bullet">
             <item> <description>MSAA level</description> </item>
             <item> <description>Fixed Foveated Rendering</description> </item>
             <item> <description>Radial Density Masking</description> </item>
             <item> <description>(Non-fixed) Foveated Rendering (once HMDs support eye tracking)</description> </item>
             </list>
             <para />
             Some shaders, especially Image Effects, need to be modified to work with the changed render scale. To fix them
             pass `1.0f / VRSettings.renderViewportScale` into the shader and scale all incoming UV values with it in the vertex
             program. Do this by using `Material.SetFloat` to set the value in the script that configures the shader.
             <para />
             In more detail:
             <list type="bullet">
             <item> <description>In the `.shader` file: Add a new runtime-set property value `float _InverseOfRenderViewportScale`
             and add `vertexInput.texcoord *= _InverseOfRenderViewportScale` to the start of the vertex program</description> </item>
             <item> <description>In the `.cs` file: Before using the material (eg. `Graphics.Blit`) add
             `material.SetFloat("_InverseOfRenderViewportScale", 1.0f / VRSettings.renderViewportScale)`</description> </item>
             </list>
             </remarks>
             <example>
             `VRTK/Examples/039_CameraRig_AdaptiveQuality` displays the frames per second in the centre of the headset view.
             The debug visualization of this script is displayed near the top edge of the headset view.
             Pressing the trigger generates a new sphere and pressing the touchpad generates ten new spheres.
             Eventually when lots of spheres are present the FPS will drop and demonstrate the script.
             </example>
        </member>
        <member name="F:VRTK.VRTK_AdaptiveQuality.renderScales">
            <summary>
            All the calculated render scales.
            </summary>
            <remarks>
            The elements of this collection are to be interpreted as modifiers to the recommended render target
            resolution provided by the current `VRDevice`.
            </remarks>
        </member>
        <member name="P:VRTK.VRTK_AdaptiveQuality.CurrentRenderScale">
            <summary>
            The current render scale.
            </summary>
            <remarks>
            A render scale of `1.0` represents the recommended render target resolution provided by the current `VRDevice`.
            </remarks>
        </member>
        <member name="P:VRTK.VRTK_AdaptiveQuality.defaultRenderTargetResolution">
            <summary>
            The recommended render target resolution provided by the current `VRDevice`.
            </summary>
        </member>
        <member name="P:VRTK.VRTK_AdaptiveQuality.currentRenderTargetResolution">
            <summary>
            The current render target resolution.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_AdaptiveQuality.DefaultFrameDurationInMilliseconds">
            <summary>
            The frame duration in milliseconds to fallback to if the current `VRDevice` specifies no refresh rate.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_AdaptiveQuality.RenderTargetResolutionForRenderScale(System.Single)">
            <summary>
            Calculates and returns the render target resolution for a given render scale.
            </summary>
            <param name="renderScale">
            The render scale to calculate the render target resolution with.
            </param>
            <returns>
            The render target resolution for `renderScale`.
            </returns>
        </member>
        <member name="M:VRTK.VRTK_AdaptiveQuality.BiggestAllowedMaximumRenderScale">
            <summary>
            Calculates and returns the biggest allowed maximum render scale to be used for `maximumRenderScale`
            given the current `maximumRenderTargetDimension`.
            </summary>
            <returns>
            The biggest allowed maximum render scale.
            </returns>
        </member>
        <member name="M:VRTK.VRTK_AdaptiveQuality.ToString">
            <summary>
            A summary of this script by listing all the calculated render scales with their
            corresponding render target resolution.
            </summary>
            <returns>
            The summary.
            </returns>
        </member>
        <member name="T:VRTK.VRTK_CustomRaycast">
             <summary>
             A Custom Raycast allows to specify custom options for a Physics.Raycast.
             </summary>
             <remarks>
             A number of other scripts can utilise a Custom Raycast to further customise the raycasts that the scripts use internally.
            
             For example, the VRTK_BodyPhysics script can be set to ignore trigger colliders when casting to see if it should teleport up or down to the nearest floor.
             </remarks>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.Raycast(VRTK.VRTK_CustomRaycast,UnityEngine.Ray,UnityEngine.RaycastHit@,UnityEngine.LayerMask,System.Single,UnityEngine.QueryTriggerInteraction)">
            <summary>
            The Raycast method is used to generate a raycast either from the given CustomRaycast object or a default Physics.Raycast.
            </summary>
            <param name="customCast">The optional object with customised cast parameters.</param>
            <param name="ray">The Ray to cast with.</param>
            <param name="hitData">The raycast hit data.</param>
            <param name="ignoreLayers">A layermask of layers to ignore from the raycast.</param>
            <param name="length">The maximum length of the raycast.</param>
            <param name="affectTriggers">Determines the trigger interaction level of the cast.</param>
            <returns>Returns true if the raycast successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.Linecast(VRTK.VRTK_CustomRaycast,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,UnityEngine.LayerMask,UnityEngine.QueryTriggerInteraction)">
            <summary>
            The Linecast method is used to generate a linecast either from the given CustomRaycast object or a default Physics.Linecast.
            </summary>
            <param name="customCast">The optional object with customised cast parameters.</param>
            <param name="startPosition">The world position to start the linecast from.</param>
            <param name="endPosition">The world position to end the linecast at.</param>
            <param name="hitData">The linecast hit data.</param>
            <param name="ignoreLayers">A layermask of layers to ignore from the linecast.</param>
            <param name="affectTriggers">Determines the trigger interaction level of the cast.</param>
            <returns>Returns true if the linecast successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.CapsuleCast(VRTK.VRTK_CustomRaycast,UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,UnityEngine.RaycastHit@,UnityEngine.LayerMask,UnityEngine.QueryTriggerInteraction)">
            <summary>
            The CapsuleCast method is used to generate a capsulecast either from the given CustomRaycast object or a default Physics.CapsuleCast.
            </summary>
            <param name="customCast">The optional object with customised cast parameters.</param>
            <param name="point1">The center of the sphere at the start of the capsule.</param>
            <param name="point2">The center of the sphere at the end of the capsule.</param>
            <param name="radius">The radius of the capsule.</param>
            <param name="direction">The direction into which to sweep the capsule.</param>
            <param name="maxDistance">The max length of the sweep.</param>
            <param name="hitData">The capsulecast hit data.</param>
            <param name="ignoreLayers">A layermask of layers to ignore from the capsulecast.</param>
            <param name="affectTriggers">Determines the trigger interaction level of the cast.</param>
            <returns>Returns true if the capsulecast successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.BoxCast(VRTK.VRTK_CustomRaycast,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,UnityEngine.RaycastHit@,UnityEngine.LayerMask,UnityEngine.QueryTriggerInteraction)">
            <summary>
            The BoxCast method is used to generate a boxcast either from the given CustomRaycast object or a default Physics.BoxCast.
            </summary>
            <param name="customCast">The optional object with customised cast parameters.</param>
            <param name="center">The center of the box.</param>
            <param name="halfExtents">Half the size of the box in each dimension.</param>
            <param name="direction">The direction in which to cast the box.</param>
            <param name="orientation">The rotation of the box.</param>
            <param name="maxDistance">The max length of the cast.</param>
            <param name="hitData">The boxcast hit data.</param>
            <param name="ignoreLayers">A layermask of layers to ignore from the boxcast.</param>
            <param name="affectTriggers">Determines the trigger interaction level of the cast.</param>
            <returns>Returns true if the boxcast successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.CustomRaycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single)">
            <summary>
            The CustomRaycast method is used to generate a raycast based on the options defined in the CustomRaycast object.
            </summary>
            <param name="ray">The Ray to cast with.</param>
            <param name="hitData">The raycast hit data.</param>
            <param name="length">The maximum length of the raycast.</param>
            <returns>Returns true if the raycast successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.CustomLinecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
            <summary>
            The CustomLinecast method is used to generate a linecast based on the options defined in the CustomRaycast object.
            </summary>
            <param name="startPosition">The world position to start the linecast from.</param>
            <param name="endPosition">The world position to end the linecast at.</param>
            <param name="hitData">The linecast hit data.</param>
            <returns>Returns true if the line successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.CustomCapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,UnityEngine.RaycastHit@)">
            <summary>
            The CustomCapsuleCast method is used to generate a capsulecast based on the options defined in the CustomRaycast object.
            </summary>
            <param name="point1">The center of the sphere at the start of the capsule.</param>
            <param name="point2">The center of the sphere at the end of the capsule.</param>
            <param name="radius">The radius of the capsule.</param>
            <param name="direction">The direction into which to sweep the capsule.</param>
            <param name="maxDistance">The max length of the sweep.</param>
            <param name="hitData">The capsulecast hit data.</param>
            <returns>Returns true if the capsule successfully collides with a valid object.</returns>
        </member>
        <member name="M:VRTK.VRTK_CustomRaycast.CustomBoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,UnityEngine.RaycastHit@)">
            <summary>
            The CustomBoxCast method is used to generate a boxcast based on the options defined in the CustomRaycast object.
            </summary>
            <param name="center">The center of the box.</param>
            <param name="halfExtents">Half the size of the box in each dimension.</param>
            <param name="direction">The direction in which to cast the box.</param>
            <param name="orientation">The rotation of the box.</param>
            <param name="maxDistance">The max length of the cast.</param>
            <param name="hitData">The boxcast hit data.</param>
            <returns>Returns true if the box successfully collides with a valid object.</returns>
        </member>
        <member name="T:VRTK.VRTK_DeviceFinder">
            <summary>
            The Device Finder offers a collection of static methods that can be called to find common game devices such as the headset or controllers, or used to determine key information about the connected devices.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_DeviceFinder.Devices">
            <summary>
            Possible devices.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Devices.Headset">
            <summary>
            The headset.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Devices.LeftController">
            <summary>
            The left hand controller.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Devices.RightController">
            <summary>
            The right hand controller.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_DeviceFinder.Headsets">
            <summary>
            Possible headsets
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.Unknown">
            <summary>
            An unknown headset.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.OculusRift">
            <summary>
            A summary of all Oculus Rift headset versions.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.OculusRiftCV1">
            <summary>
            A specific version of the Oculus Rift headset, the Consumer Version 1.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.Vive">
            <summary>
            A summary of all HTC Vive headset versions.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.ViveMV">
            <summary>
            A specific version of the HTC Vive headset, the first consumer version.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.ViveDVT">
            <summary>
            A specific version of the HTC Vive headset, the first consumer version.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.Headsets.OculusRiftES07">
            <summary>
            A specific version of the Oculus Rift headset, the rare ES07.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_DeviceFinder.cachedHeadsetType">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method is used to find the index of a given controller object.
            </summary>
            <param name="controller">The controller object to get the index of a controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method is used to find a controller based on it's unique index.
            </summary>
            <param name="index">The index of the actual controller to find.</param>
            <param name="getActual">An optional parameter that if true will return the game object that the SDK controller is attached to.</param>
            <returns>The actual controller GameObject that matches the given index.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method is used to find the controller's origin.
            </summary>
            <param name="controllerReference">The reference to the controller to get the origin for.</param>
            <returns>The transform of the controller origin or if an origin is not set then the transform parent.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.DeviceTransform(VRTK.VRTK_DeviceFinder.Devices)">
            <summary>
            The DeviceTransform method returns the transform for a given Devices enum.
            </summary>
            <param name="device">The Devices enum to get the transform for.</param>
            <returns>The transform for the given Devices enum.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerHandType(System.String)">
            <summary>
            The GetControllerHandType method is used for getting the enum representation of ControllerHand from a given string.
            </summary>
            <param name="hand">The string representation of the hand to retrieve the type of. `left` or `right`.</param>
            <returns>A ControllerHand representing either the Left or Right hand.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerHand(UnityEngine.GameObject)">
            <summary>
            The GetControllerHand method is used for getting the enum representation of ControllerHand for the given controller game object.
            </summary>
            <param name="controller">The controller game object to check the hand of.</param>
            <returns>A ControllerHand representing either the Left or Right hand.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method retrieves the game object for the left hand controller.
            </summary>
            <param name="getActual">An optional parameter that if true will return the game object that the SDK controller is attached to.</param>
            <returns>The left hand controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method retrieves the game object for the right hand controller.
            </summary>
            <param name="getActual">An optional parameter that if true will return the game object that the SDK controller is attached to.</param>
            <returns>The right hand controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerReferenceLeftHand">
            <summary>
            The GetControllerReferenceLeftHand returns a Controller Reference for the left hand controller.
            </summary>
            <returns>The Controller Reference for the left hand controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerReferenceRightHand">
            <summary>
            The GetControllerReferenceRightHand returns a Controller Reference for the right hand controller.
            </summary>
            <returns>The Controller Reference for the right hand controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerReferenceForHand(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerReferenceForHand returns a Controller Reference for the given hand controller.
            </summary>
            <returns>The Controller Reference for the given hand controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.IsControllerOfHand(UnityEngine.GameObject,VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The IsControllerOfHand method is used to check if a given controller game object is of the hand type provided.
            </summary>
            <param name="checkController">The actual controller object that is being checked.</param>
            <param name="hand">The representation of a hand to check if the given controller matches.</param>
            <returns>Is true if the given controller matches the given hand.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand method is used to check if a given controller game object is the left handed controller.
            </summary>
            <param name="checkController">The controller object that is being checked.</param>
            <returns>Is true if the given controller is the left controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand method is used to check if a given controller game object is the right handed controller.
            </summary>
            <param name="checkController">The controller object that is being checked.</param>
            <returns>Is true if the given controller is the right controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetOppositeHand(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetOppositeHand method returns the other hand type from the current hand given.
            </summary>
            <param name="currentHand">The current hand.</param>
            <returns>The opposite hand.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetActualController(UnityEngine.GameObject)">
            <summary>
            The GetActualController method will attempt to get the actual SDK controller object.
            </summary>
            <param name="givenController">The GameObject of the controller.</param>
            <returns>The GameObject that is the actual controller.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetScriptAliasController(UnityEngine.GameObject)">
            <summary>
            The GetScriptAliasController method will attempt to get the object that contains the scripts for the controller.
            </summary>
            <param name="givenController">The GameObject of the controller.</param>
            <returns>The GameObject that is the alias controller containing the scripts.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetModelAliasController(UnityEngine.GameObject)">
            <summary>
            The GetModelAliasController method will attempt to get the object that contains the model for the controller.
            </summary>
            <param name="givenController">The GameObject of the controller.</param>
            <returns>The GameObject that is the alias controller containing the controller model.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetModelAliasControllerHand(UnityEngine.GameObject)">
            <summary>
            The GetModelAliasControllerHand method will return the hand that the given model alias GameObject is for.
            </summary>
            <param name="givenObject">The GameObject that may represent a model alias.</param>
            <returns>The enum of the ControllerHand that the given GameObject may represent.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerVelocity method is used for getting the current velocity of the physical game controller. This can be useful to determine the speed at which the controller is being swung or the direction it is being moved in.
            </summary>
            <param name="controllerReference">The reference to the controller.</param>
            <returns>A 3 dimensional vector containing the current real world physical controller velocity.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetControllerAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerAngularVelocity method is used for getting the current rotational velocity of the physical game controller. This can be useful for determining which way the controller is being rotated and at what speed the rotation is occurring.
            </summary>
            <param name="controllerReference">The reference to the controller.</param>
            <returns>A 3 dimensional vector containing the current real world physical controller angular (rotational) velocity.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.HeadsetTransform">
            <summary>
            The HeadsetTransform method is used to retrieve the transform for the VR Headset in the scene. It can be useful to determine the position of the user's head in the game world.
            </summary>
            <returns>The transform of the VR Headset component.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.HeadsetCamera">
            <summary>
            The HeadsetCamera method is used to retrieve the transform for the VR Camera in the scene.
            </summary>
            <returns>The transform of the VR Camera component.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.ResetHeadsetTypeCache">
            <summary>
            The ResetHeadsetTypeCache resets the cache holding the current headset type value.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetHeadsetType(System.Boolean)">
            <summary>
            The GetHeadsetType method returns the type of headset connected to the computer.
            </summary>
            <param name="summary">If this is `true`, then the generic name for the headset is returned not including the version type (e.g. OculusRift will be returned for DK2 and CV1).</param>
            <returns>The Headset type that is connected.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetHeadsetTypeAsString">
            <summary>
            The GetHeadsetTypeAsString method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns the type of headset currently connected.
            </summary>
            <returns>The Headset type that is connected.</returns>
        </member>
        <member name="M:VRTK.VRTK_DeviceFinder.PlayAreaTransform">
            <summary>
            The PlayAreaTransform method is used to retrieve the transform for the play area in the scene.
            </summary>
            <returns>The transform of the VR Play Area component.</returns>
        </member>
        <member name="T:VRTK.VRTK_NavMeshData">
            <summary>
            The Nav Mesh Data script allows custom nav mesh information to be provided to the teleporter script.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_PolicyList">
             <summary>
             The Policy List allows to create a list of either tag names, script names or layer names that can be checked against to see if another operation is permitted.
             </summary>
             <remarks>
             A number of other scripts can use a Policy List to determine if an operation is permitted based on whether a game object has a tag applied, a script component on it or whether it's on a given layer.
            
             For example, the Teleporter scripts can ignore game object targets as a teleport location if the game object contains a tag that is in the identifiers list and the policy is set to ignore.
            
             Or the teleporter can only allow teleport to targets that contain a tag that is in the identifiers list and the policy is set to include.
            
             Add the Policy List script to a game object (preferably the same component utilising the list) and then configure the list accordingly.
            
             Then in the component that has a Policy List paramter (e.g. BasicTeleporter has `Target List Policy`) simply select the list that has been created and defined.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_PolicyList.OperationTypes">
            <summary>
            The operation to apply on the list of identifiers.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PolicyList.OperationTypes.Ignore">
            <summary>
            Will ignore any game objects that contain either a tag or script component that is included in the identifiers list.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PolicyList.OperationTypes.Include">
            <summary>
            Will only include game objects that contain either a tag or script component that is included in the identifiers list.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_PolicyList.CheckTypes">
            <summary>
            The types of element that can be checked against.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PolicyList.CheckTypes.Tag">
            <summary>
            The tag applied to the game object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PolicyList.CheckTypes.Script">
            <summary>
            A script component added to the game object.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_PolicyList.CheckTypes.Layer">
            <summary>
            A layer applied to the game object.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_PolicyList.Find(UnityEngine.GameObject)">
            <summary>
            The Find method performs the set operation to determine if the given game object contains one of the identifiers on the set check type.
            </summary>
            <remarks>
            For instance, if the Operation is `Ignore` and the Check Type is `Tag` then the Find method will attempt to see if the given game object has a tag that matches one of the identifiers.
            </remarks>
            <param name="obj">The game object to check if it has a tag or script that is listed in the identifiers list.</param>
            <returns>If the operation is `Ignore` and the game object is matched by an identifier from the list then it returns true. If the operation is `Include` and the game object is not matched by an identifier from the list then it returns true.</returns>
        </member>
        <member name="M:VRTK.VRTK_PolicyList.Check(UnityEngine.GameObject,VRTK.VRTK_PolicyList)">
            <summary>
            The Check method is used to check if a game object should be ignored based on a given string or policy list.
            </summary>
            <param name="obj">The game object to check.</param>
            <param name="list">The policy list to use for checking.</param>
            <returns>Returns true of the given game object matches the policy list or given string logic.</returns>
        </member>
        <member name="T:VRTK.VRTK_SDKInputOverride">
            <summary>
            Provides the ability to switch button mappings based on the current SDK or controller type
            </summary>
            <remarks>
            **Script Usage:**
             * Place the `VRTK_SDKInputOverride` script on any active scene GameObject.
             * Customise the input button for each script type for each SDK controller type.
            </remarks>
        </member>
        <member name="M:VRTK.VRTK_SDKInputOverride.ForceManage">
            <summary>
            The ForceManage method forces the inputs to be updated even without an SDK change event occuring.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKObjectAlias">
            <summary>
            The GameObject that the SDK Object Alias script is applied to will become a child of the selected SDK Object.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKObjectAlias.SDKObject">
            <summary>
            Valid SDK Objects
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKObjectAlias.SDKObject.Boundary">
            <summary>
            The main camera rig/play area object that defines the player boundary.
            </summary>
        </member>
        <member name="F:VRTK.VRTK_SDKObjectAlias.SDKObject.Headset">
            <summary>
            The main headset camera defines the player head.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SDKObjectState">
            <summary>
            The SDK Object State script can be used to set the enable/active state of a GameObject or Component based on SDK information.
            </summary>
            <remarks>
            The state can be determined by:
             * The current loaded SDK setup.
             * The current attached Headset type.
             * The current attached Controller type.
            </remarks>
        </member>
        <member name="M:VRTK.VRTK_SDKObjectState.SetStateByControllerReference(VRTK.VRTK_ControllerReference)">
            <summary>
            The SetStateByControllerReference method sets the object state based on the controller type of the given controller reference.
            </summary>
            <param name="controllerReference">A controller reference to check for the controller type of.</param>
        </member>
        <member name="T:VRTK.VRTK_SDKTransformModify">
            <summary>
            The SDK Transform Modify can be used to change a transform orientation at runtime based on the currently used SDK or SDK controller.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SDKTransformModify.UpdateTransform(VRTK.VRTK_ControllerReference)">
            <summary>
            The UpdateTransform method updates the Transform data on the current GameObject for the specified settings.
            </summary>
            <param name="controllerReference">An optional reference to the controller to update the transform with.</param>
        </member>
        <member name="M:VRTK.VRTK_SDKTransformModify.SetOrigins">
            <summary>
            The SetOrigins method sets the original position, rotation, scale of the target Transform.
            </summary>
        </member>
        <member name="T:VRTK.VRTK_SharedMethods">
            <summary>
            The Shared Methods script is a collection of reusable static methods that are used across a range of different scripts.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetBounds(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            The GetBounds methods returns the bounds of the transform including all children in world space.
            </summary>
            <param name="transform"></param>
            <param name="excludeRotation">Resets the rotation of the transform temporarily to 0 to eliminate skewed bounds.</param>
            <param name="excludeTransform">Does not consider the stated object when calculating the bounds.</param>
            <returns>The bounds of the transform.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.IsLowest(System.Single,System.Single[])">
            <summary>
            The IsLowest method checks to see if the given value is the lowest number in the given array of values.
            </summary>
            <param name="value">The value to check to see if it is lowest.</param>
            <param name="others">The array of values to check against.</param>
            <returns>Returns true if the value is lower than all numbers in the given array, returns false if it is not the lowest.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.AddCameraFade">
            <summary>
            The AddCameraFade method finds the headset camera and adds a headset fade script to it.
            </summary>
            <returns>The transform of the headset camera.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.CreateColliders(UnityEngine.GameObject)">
            <summary>
            The CreateColliders method attempts to add box colliders to all child objects in the given object that have a renderer but no collider.
            </summary>
            <param name="obj">The game object to attempt to add the colliders to.</param>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.ColliderExclude(UnityEngine.Collider[],UnityEngine.Collider[])">
            <summary>
            The ColliderExclude method reduces the colliders in the setA array by those matched in the setB array.
            </summary>
            <param name="setA">The array that contains all of the relevant colliders.</param>
            <param name="setB">The array that contains the colliders to remove from setA.</param>
            <returns>A Collider array that is a subset of setA that doesn't contain the colliders from setB.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetCollidersInGameObjects(UnityEngine.GameObject[],System.Boolean,System.Boolean)">
            <summary>
            The GetCollidersInGameObjects method iterates through a GameObject array and returns all of the unique found colliders for all GameObejcts.
            </summary>
            <param name="gameObjects">An array of GameObjects to get the colliders for.</param>
            <param name="searchChildren">If this is `true` then the given GameObjects will also have their child GameObjects searched for colliders.</param>
            <param name="includeInactive">If this is `true` then the inactive GameObjects in the array will also be checked for Colliders. Only relevant if `searchChildren` is `true`.</param>
            <returns>An array of Colliders that are found in the given GameObject array.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.CloneComponent(UnityEngine.Component,UnityEngine.GameObject,System.Boolean)">
            <summary>
            The CloneComponent method takes a source component and copies it to the given destination game object.
            </summary>
            <param name="source">The component to copy.</param>
            <param name="destination">The game object to copy the component to.</param>
            <param name="copyProperties">Determines whether the properties of the component as well as the fields should be copied.</param>
            <returns>The component that has been cloned onto the given game object.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.ColorDarken(UnityEngine.Color,System.Single)">
            <summary>
            The ColorDarken method takes a given colour and darkens it by the given percentage.
            </summary>
            <param name="color">The source colour to apply the darken to.</param>
            <param name="percent">The percent to darken the colour by.</param>
            <returns>The new colour with the darken applied.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.RoundFloat(System.Single,System.Int32,System.Boolean)">
            <summary>
            The RoundFloat method is used to round a given float to the given decimal places.
            </summary>
            <param name="givenFloat">The float to round.</param>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <param name="rawFidelity">If this is true then the decimal places must be given in the decimal multiplier, e.g. 10 for 1dp, 100 for 2dp, etc.</param>
            <returns>The rounded float.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.IsEditTime">
            <summary>
            The IsEditTime method determines if the state of Unity is in the Unity Editor and the scene is not in play mode.
            </summary>
            <returns>Returns true if Unity is in the Unity Editor and not in play mode.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.Mod(System.Single,System.Single)">
            <summary>
            The Mod method is used to find the remainder of the sum a/b.
            </summary>
            <param name="a">The dividend value.</param>
            <param name="b">The divisor value.</param>
            <returns>The remainder value.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.FindEvenInactiveGameObject``1(System.String,System.Boolean)">
            <summary>
            Finds the first GameObject with a given name and an ancestor that has a specific component.
            </summary>
            <remarks>
            This method returns active as well as inactive GameObjects in all scenes. It doesn't return assets.
            For performance reasons it is recommended to not use this function every frame. Cache the result in a member variable at startup instead.
            </remarks>
            <typeparam name="T">The component type that needs to be on an ancestor of the wanted GameObject. Must be a subclass of `Component`.</typeparam>
            <param name="gameObjectName">The name of the wanted GameObject. If it contains a '/' character, this method traverses the hierarchy like a path name, beginning on the game object that has a component of type `T`.</param>
            <param name="searchAllScenes">If this is true, all loaded scenes will be searched. If this is false, only the active scene will be searched.</param>
            <returns>The GameObject with name `gameObjectName` and an ancestor that has a `T`. If no such GameObject is found then `null` is returned.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.FindEvenInactiveComponents``1(System.Boolean)">
            <summary>
            Finds all components of a given type.
            </summary>
            <remarks>
            This method returns components from active as well as inactive GameObjects in all scenes. It doesn't return assets.
            For performance reasons it is recommended to not use this function every frame. Cache the result in a member variable at startup instead.
            </remarks>
            <typeparam name="T">The component type to search for. Must be a subclass of `Component`.</typeparam>
            <param name="searchAllScenes">If this is true, all loaded scenes will be searched. If this is false, only the active scene will be searched.</param>
            <returns>All the found components. If no component is found an empty array is returned.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.FindEvenInactiveComponent``1(System.Boolean)">
            <summary>
            Finds the first component of a given type.
            </summary>
            <remarks>
            This method returns components from active as well as inactive GameObjects in all scenes. It doesn't return assets.
            For performance reasons it is recommended to not use this function every frame. Cache the result in a member variable at startup instead.
            </remarks>
            <typeparam name="T">The component type to search for. Must be a subclass of `Component`.</typeparam>
            <param name="searchAllScenes">If this is true, all loaded scenes will be searched. If this is false, only the active scene will be searched.</param>
            <returns>The found component. If no component is found `null` is returned.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GenerateVRTKObjectName(System.Boolean,System.Object[])">
            <summary>
            The GenerateVRTKObjectName method is used to create a standard name string for any VRTK generated object.
            </summary>
            <param name="autoGen">An additiona [AUTOGEN] prefix will be added if this is true.</param>
            <param name="replacements">A collection of parameters to add to the generated name.</param>
            <returns>The generated name string.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetGPUTimeLastFrame">
            <summary>
            The GetGPUTimeLastFrame retrieves the time spent by the GPU last frame, in seconds, as reported by the VR SDK.
            </summary>
            <returns>The total GPU time utilized last frame as measured by the VR subsystem.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.Vector2ShallowCompare(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The Vector2ShallowCompare method compares two given Vector2 objects based on the given fidelity, which is the equivalent of comparing rounded Vector2 elements to determine if the Vector2 elements are equal.
            </summary>
            <param name="vectorA">The Vector2 to compare against.</param>
            <param name="vectorB">The Vector2 to compare with</param>
            <param name="compareFidelity">The number of decimal places to use when doing the comparison on the float elements within the Vector2.</param>
            <returns>Returns `true` if the given Vector2 objects match based on the given fidelity.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.Vector3ShallowCompare(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            The Vector3ShallowCompare method compares two given Vector3 objects based on the given threshold, which is the equavelent of checking the distance between two Vector3 objects are above the threshold distance.
            </summary>
            <param name="vectorA">The Vector3 to compare against.</param>
            <param name="vectorB">The Vector3 to compare with</param>
            <param name="threshold">The distance in which the two Vector3 objects can be within to be considered true</param>
            <returns>Returns `true` if the given Vector3 objects are within the given threshold distance.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.NumberPercent(System.Single,System.Single)">
            <summary>
            The NumberPercent method is used to determine the percentage of a given value.
            </summary>
            <param name="value">The value to determine the percentage from</param>
            <param name="percent">The percentage to find within the given value.</param>
            <returns>A float containing the percentage value based on the given input.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.SetGlobalScale(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            The SetGlobalScale method is used to set a transform scale based on a global scale instead of a local scale.
            </summary>
            <param name="transform">The reference to the transform to scale.</param>
            <param name="globalScale">A Vector3 of a global scale to apply to the given transform.</param>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.VectorHeading(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            The VectorHeading method calculates the current heading of the target position in relation to the origin position.
            </summary>
            <param name="originPosition">The point to use as the originating position for the heading calculation.</param>
            <param name="targetPosition">The point to use as the target position for the heading calculation.</param>
            <returns>A Vector3 containing the heading changes of the target position in relation to the origin position.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.VectorDirection(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            The VectorDirection method calculates the direction the target position is in relation to the origin position.
            </summary>
            <param name="originPosition">The point to use as the originating position for the direction calculation.</param>
            <param name="targetPosition">The point to use as the target position for the direction calculation.</param>
            <returns>A Vector3 containing the direction of the target position in relation to the origin position.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.DividerToMultiplier(System.Single)">
            <summary>
            The DividerToMultiplier method takes a number to be used in a division and converts it to be used for multiplication. (e.g. 2 / 2 becomes 2 * 0.5)
            </summary>
            <param name="value">The number to convert into the multplier value.</param>
            <returns>The calculated number that can replace the divider number in a multiplication sum.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.NormalizeValue(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            The NormalizeValue method takes a given value between a specified range and returns the normalized value between 0f and 1f.
            </summary>
            <param name="value">The actual value to normalize.</param>
            <param name="minValue">The minimum value the actual value can be.</param>
            <param name="maxValue">The maximum value the actual value can be.</param>
            <param name="threshold">The threshold to force to the minimum or maximum value if the normalized value is within the threhold limits.</param>
            <returns></returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.AxisDirection(System.Int32,UnityEngine.Transform)">
            <summary>
            The AxisDirection method returns the relevant direction Vector3 based on the axis index in relation to x,y,z.
            </summary>
            <param name="axisIndex">The axis index of the axis. `0 = x` `1 = y` `2 = z`</param>
            <param name="givenTransform">An optional Transform to get the Axis Direction for. If this is `null` then the World directions will be used.</param>
            <returns>The direction Vector3 based on the given axis index.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.AddListValue``1(System.Collections.Generic.List{``0},``0,System.Boolean)">
            <summary>
            The AddListValue method adds the given value to the given list. If `preventDuplicates` is `true` then the given value will only be added if it doesn't already exist in the given list.
            </summary>
            <typeparam name="TValue">The datatype for the list value.</typeparam>
            <param name="list">The list to retrieve the value from.</param>
            <param name="value">The value to attempt to add to the list.</param>
            <param name="preventDuplicates">If this is `false` then the value provided will always be appended to the list. If this is `true` the value provided will only be added to the list if it doesn't already exist.</param>
            <returns>Returns `true` if the given value was successfully added to the list. Returns `false` if the given value already existed in the list and `preventDuplicates` is `true`.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetDictionaryValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1,System.Boolean)">
            <summary>
            The GetDictionaryValue method attempts to retrieve a value from a given dictionary for the given key. It removes the need for a double dictionary lookup to ensure the key is valid and has the option of also setting the missing key value to ensure the dictionary entry is valid.
            </summary>
            <typeparam name="TKey">The datatype for the dictionary key.</typeparam>
            <typeparam name="TValue">The datatype for the dictionary value.</typeparam>
            <param name="dictionary">The dictionary to retrieve the value from.</param>
            <param name="key">The key to retrieve the value for.</param>
            <param name="defaultValue">The value to utilise when either setting the missing key (if `setMissingKey` is `true`) or the default value to return when no key is found (if `setMissingKey` is `false`).</param>
            <param name="setMissingKey">If this is `true` and the given key is not present, then the dictionary value for the given key will be set to the `defaultValue` parameter. If this is `false` and the given key is not present then the `defaultValue` parameter will be returned as the value.</param>
            <returns>The found value for the given key in the given dictionary, or the default value if no key is found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetDictionaryValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Boolean@,``1,System.Boolean)">
            <summary>
            The GetDictionaryValue method attempts to retrieve a value from a given dictionary for the given key. It removes the need for a double dictionary lookup to ensure the key is valid and has the option of also setting the missing key value to ensure the dictionary entry is valid.
            </summary>
            <typeparam name="TKey">The datatype for the dictionary key.</typeparam>
            <typeparam name="TValue">The datatype for the dictionary value.</typeparam>
            <param name="dictionary">The dictionary to retrieve the value from.</param>
            <param name="key">The key to retrieve the value for.</param>
            <param name="keyExists">Sets the given parameter to `true` if the key exists in the given dictionary or sets to `false` if the key didn't existing in the given dictionary.</param>
            <param name="defaultValue">The value to utilise when either setting the missing key (if `setMissingKey` is `true`) or the default value to return when no key is found (if `setMissingKey` is `false`).</param>
            <param name="setMissingKey">If this is `true` and the given key is not present, then the dictionary value for the given key will be set to the `defaultValue` parameter. If this is `false` and the given key is not present then the `defaultValue` parameter will be returned as the value.</param>
            <returns>The found value for the given key in the given dictionary, or the default value if no key is found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.AddDictionaryValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1,System.Boolean)">
            <summary>
            The AddDictionaryValue method attempts to add a value for the given key in the given dictionary if the key does not already exist. If `overwriteExisting` is `true` then it always set the value even if they key exists.
            </summary>
            <typeparam name="TKey">The datatype for the dictionary key.</typeparam>
            <typeparam name="TValue">The datatype for the dictionary value.</typeparam>
            <param name="dictionary">The dictionary to set the value for.</param>
            <param name="key">The key to set the value for.</param>
            <param name="value">The value to set at the given key in the given dictionary.</param>
            <param name="overwriteExisting">If this is `true` then the value for the given key will always be set to the provided value. If this is `false` then the value for the given key will only be set if the given key is not found in the given dictionary.</param>
            <returns>Returns `true` if the given value was successfully added to the dictionary at the given key. Returns `false` if the given key already existed in the dictionary and `overwriteExisting` is `false`.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetTypeUnknownAssembly(System.String)">
            <summary>
            The GetTypeUnknownAssembly method is used to find a Type without knowing the exact assembly it is in.
            </summary>
            <param name="typeName">The name of the type to get.</param>
            <returns>The Type, or null if none is found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetEyeTextureResolutionScale">
            <summary>
            The GetEyeTextureResolutionScale method returns the render scale for the resolution.
            </summary>
            <returns>Returns a float with the render scale for the resolution.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.SetEyeTextureResolutionScale(System.Single)">
            <summary>
            The SetEyeTextureResolutionScale method sets the render scale for the resolution.
            </summary>
            <param name="value">The value to set the render scale to.</param>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.IsTypeSubclassOf(System.Type,System.Type)">
            <summary>
            The IsTypeSubclassOf checks if a given Type is a subclass of another given Type.
            </summary>
            <param name="givenType">The Type to check.</param>
            <param name="givenBaseType">The base Type to check.</param>
            <returns>Returns `true` if the given type is a subclass of the given base type.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetTypeCustomAttributes(System.Type,System.Type,System.Boolean)">
            <summary>
            The GetTypeCustomAttributes method gets the custom attributes of a given type.
            </summary>
            <param name="givenType">The type to get the custom attributes for.</param>
            <param name="attributeType">The attribute type.</param>
            <param name="inherit">Whether to inherit attributes.</param>
            <returns>Returns an object array of custom attributes.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetBaseType(System.Type)">
            <summary>
            The GetBaseType method returns the base Type for the given Type.
            </summary>
            <param name="givenType">The type to return the base Type for.</param>
            <returns>Returns the base Type.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.IsTypeAssignableFrom(System.Type,System.Type)">
            <summary>
            The IsTypeAssignableFrom method determines if the given Type is assignable from the source Type.
            </summary>
            <param name="givenType">The Type to check on.</param>
            <param name="sourceType">The Type to check if the given Type is assignable from.</param>
            <returns>Returns `true` if the given Type is assignable from the source Type.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetNestedType(System.Type,System.String)">
            <summary>
            The GetNestedType method returns the nested Type of the given Type.
            </summary>
            <param name="givenType">The Type to check on.</param>
            <param name="name">The name of the nested Type.</param>
            <returns>Returns the nested Type.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetPropertyFirstName``1">
            <summary>
            The GetPropertyFirstName method returns the string name of the first property on a given Type.
            </summary>
            <typeparam name="T">The type to check the first property on.</typeparam>
            <returns>Returns a string representation of the first property name for the given Type.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetCommandLineArguements">
            <summary>
            The GetCommandLineArguements method returns the command line arguements for the environment.
            </summary>
            <returns>Returns an array of command line arguements as strings.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetTypesOfType(System.Type)">
            <summary>
            The GetTypesOfType method returns an array of Types for the given Type.
            </summary>
            <param name="givenType">The Type to check on.</param>
            <returns>An array of Types found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.GetExportedTypesOfType(System.Type)">
            <summary>
            The GetExportedTypesOfType method returns an array of Exported Types for the given Type.
            </summary>
            <param name="givenType">The Type to check on.</param>
            <returns>An array of Exported Types found.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.IsTypeAbstract(System.Type)">
            <summary>
            The IsTypeAbstract method determines if a given Type is abstract.
            </summary>
            <param name="givenType">The Type to check on.</param>
            <returns>Returns `true` if the given type is abstract.</returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.FindEvenInactiveComponentsInValidScenes``1(System.Boolean,System.Boolean)">
            <summary>
            The FindEvenInactiveComponentsInLoadedScenes method searches active and inactive game objects in all
            loaded scenes for components matching the type supplied. 
            </summary>
            <param name="searchAllScenes">If true, will search all loaded scenes, otherwise just the active scene.</param>
            <param name="stopOnMatch">If true, will stop searching objects as soon as a match is found.</param>
            <returns></returns>
        </member>
        <member name="M:VRTK.VRTK_SharedMethods.FindEventInactiveComponentsInScene``1(UnityEngine.SceneManagement.Scene,System.Boolean)">
            <summary>
            The FIndEvenInactiveComponentsInScene method searches the specified scene for components matching the type supplied.
            </summary>
            <param name="scene">The scene to search. This scene must be valid, either loaded or loading.</param>
            <param name="stopOnMatch">If true, will stop searching objects as soon as a match is found.</param>
            <returns></returns>
        </member>
        <member name="T:VRTK.VRTK_Simulator">
             <summary>
             To test a scene it is often necessary to use the headset to move to a location. This increases turn-around times and can become cumbersome.
             </summary>
             <remarks>
             The simulator allows navigating through the scene using the keyboard instead, without the need to put on the headset. One can then move around (also through walls) while looking at the monitor and still use the controllers to interact.
            
             Supported movements are: forward, backward, strafe left, strafe right, turn left, turn right, up, down.
             </remarks>
        </member>
        <member name="T:VRTK.VRTK_VelocityEstimator">
             <summary>
             The Velocity Estimator is used to calculate an estimated velocity on a moving object that is moving outside of Unity physics.
             </summary>
             <remarks>
             Objects that have rigidbodies and use Unity physics to move around will automatically provide accurate velocity and angular velocity information.
            
             Any object that is moved around using absolute positions or moving the transform position will not be able to provide accurate velocity or angular velocity information.
             When the Velocity Estimator script is applied to any GameObject it will provide a best case estimation of what the object's velocity and angular velocity is based on a given number of position and rotation samples.
             The more samples used, the higher the precision but the script will be more demanding on processing time.
             </remarks>
        </member>
        <member name="M:VRTK.VRTK_VelocityEstimator.StartEstimation">
            <summary>
            The StartEstimation method begins logging samples of position and rotation for the GameObject.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_VelocityEstimator.EndEstimation">
            <summary>
            The EndEstimation method stops logging samples of position and rotation for the GameObject.
            </summary>
        </member>
        <member name="M:VRTK.VRTK_VelocityEstimator.GetVelocityEstimate">
            <summary>
            The GetVelocityEstimate method returns the current velocity estimate.
            </summary>
            <returns>The velocity estimate vector of the GameObject</returns>
        </member>
        <member name="M:VRTK.VRTK_VelocityEstimator.GetAngularVelocityEstimate">
            <summary>
            The GetAngularVelocityEstimate method returns the current angular velocity estimate.
            </summary>
            <returns>The angular velocity estimate vector of the GameObject</returns>
        </member>
        <member name="M:VRTK.VRTK_VelocityEstimator.GetAccelerationEstimate">
            <summary>
            The GetAccelerationEstimate method returns the current acceleration estimate.
            </summary>
            <returns>The acceleration estimate vector of the GameObject</returns>
        </member>
        <member name="T:VRTK.SDK_Base">
            <summary>
            Abstract superclass that defines that a particular class is an SDK.
            </summary>
            <remarks>
            This is an abstract class to mark all different SDK endpoints with. This is used to allow for type safety when talking about 'an SDK' instead of one of the different endpoints (System, Boundaries, Headset, Controller).
            </remarks>
        </member>
        <member name="M:VRTK.SDK_Base.OnBeforeSetupLoad(VRTK.VRTK_SDKSetup)">
            <summary>
            This method is called just before loading the VRTK_SDKSetup that's using this SDK.
            </summary>
            <param name="setup">The SDK Setup which is using this SDK.</param>
        </member>
        <member name="M:VRTK.SDK_Base.OnAfterSetupLoad(VRTK.VRTK_SDKSetup)">
            <summary>
            This method is called just after loading the VRTK_SDKSetup that's using this SDK.
            </summary>
            <param name="setup">The SDK Setup which is using this SDK.</param>
        </member>
        <member name="M:VRTK.SDK_Base.OnBeforeSetupUnload(VRTK.VRTK_SDKSetup)">
            <summary>
            This method is called just before unloading the VRTK_SDKSetup that's using this SDK.
            </summary>
            <param name="setup">The SDK Setup which is using this SDK.</param>
        </member>
        <member name="M:VRTK.SDK_Base.OnAfterSetupUnload(VRTK.VRTK_SDKSetup)">
            <summary>
            This method is called just after unloading the VRTK_SDKSetup that's using this SDK.
            </summary>
            <param name="setup">The SDK Setup which is using this SDK.</param>
        </member>
        <member name="T:VRTK.SDK_BaseBoundaries">
            <summary>
            The Base Boundaries SDK script provides a bridge to SDK methods that deal with the play area of SDKs that support room scale play spaces.
            </summary>
            <remarks>
            This is an abstract class to implement the interface required by all implemented SDKs.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.InitBoundaries">
            <summary>
            The InitBoundaries method is run on start of scene and can be used to initialse anything on game start.
            </summary>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.GetPlayArea">
            <summary>
            The GetPlayArea method returns the Transform of the object that is used to represent the play area in the scene.
            </summary>
            <returns>A transform of the object representing the play area in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.GetPlayAreaVertices">
            <summary>
            The GetPlayAreaVertices method returns the points of the play area boundaries.
            </summary>
            <returns>A Vector3 array of the points in the scene that represent the play area boundaries.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.GetPlayAreaBorderThickness">
            <summary>
            The GetPlayAreaBorderThickness returns the thickness of the drawn border for the given play area.
            </summary>
            <returns>The thickness of the drawn border.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.IsPlayAreaSizeCalibrated">
            <summary>
            The IsPlayAreaSizeCalibrated method returns whether the given play area size has been auto calibrated by external sensors.
            </summary>
            <returns>Returns true if the play area size has been auto calibrated and set by external sensors.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.GetDrawAtRuntime">
            <summary>
            The GetDrawAtRuntime method returns whether the given play area drawn border is being displayed.
            </summary>
            <returns>Returns true if the drawn border is being displayed.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseBoundaries.SetDrawAtRuntime(System.Boolean)">
            <summary>
            The SetDrawAtRuntime method sets whether the given play area drawn border should be displayed at runtime.
            </summary>
            <param name="value">The state of whether the drawn border should be displayed or not.</param>
        </member>
        <member name="T:VRTK.SDK_BaseController">
            <summary>
            The Base Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
            <remarks>
            This is an abstract class to implement the interface required by all implemented SDKs.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_BaseController.ButtonTypes">
            <summary>
            Types of buttons on a controller
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.ButtonOne">
            <summary>
            Button One on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.ButtonTwo">
            <summary>
            Button Two on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.Grip">
            <summary>
            Grip on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.GripHairline">
            <summary>
            Grip Hairline on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.StartMenu">
            <summary>
            Start Menu on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.Trigger">
            <summary>
            Trigger on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.TriggerHairline">
            <summary>
            Trigger Hairline on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.Touchpad">
            <summary>
            Touchpad on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.TouchpadTwo">
            <summary>
            Touchpad Two on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.MiddleFinger">
            <summary>
            Middle Finger on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.RingFinger">
            <summary>
            Ring Finger on the controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonTypes.PinkyFinger">
            <summary>
            Pinky Finger on the controller.
            </summary>
        </member>
        <member name="T:VRTK.SDK_BaseController.ButtonPressTypes">
            <summary>
            Concepts of controller button press
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.Press">
            <summary>
            The button is currently being pressed.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.PressDown">
            <summary>
            The button has just been pressed down.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.PressUp">
            <summary>
            The button has just been released.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.Touch">
            <summary>
            The button is currently being touched.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.TouchDown">
            <summary>
            The button has just been touched.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ButtonPressTypes.TouchUp">
            <summary>
            The button is no longer being touched.
            </summary>
        </member>
        <member name="T:VRTK.SDK_BaseController.ControllerElements">
            <summary>
            The elements of a generic controller
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.AttachPoint">
            <summary>
            The default point on the controller to attach grabbed objects to.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.Trigger">
            <summary>
            The trigger button.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.GripLeft">
            <summary>
            The left part of the grip button collection.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.GripRight">
            <summary>
            The right part of the grip button collection.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.Touchpad">
            <summary>
            The touch pad/stick.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.ButtonOne">
            <summary>
            The first generic button.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.ButtonTwo">
            <summary>
            The second generic button.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.SystemMenu">
            <summary>
            The system menu button.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.Body">
            <summary>
            The encompassing mesh of the controller body.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.StartMenu">
            <summary>
            The start menu button.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerElements.TouchpadTwo">
            <summary>
            The touch pad/stick two.
            </summary>
        </member>
        <member name="T:VRTK.SDK_BaseController.ControllerHand">
            <summary>
            Controller hand reference.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerHand.None">
            <summary>
            No hand is assigned.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerHand.Left">
            <summary>
            The left hand is assigned.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerHand.Right">
            <summary>
            The right hand is assigned.
            </summary>
        </member>
        <member name="T:VRTK.SDK_BaseController.ControllerType">
            <summary>
            SDK Controller types.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Undefined">
            <summary>
            No controller type.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Custom">
            <summary>
            A custom controller type.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Simulator_Hand">
            <summary>
            The Simulator default hand controller.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.SteamVR_ViveWand">
            <summary>
            The HTC Vive wand controller for SteamVR.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.SteamVR_OculusTouch">
            <summary>
            The Oculus Touch controller for SteamVR.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Oculus_OculusTouch">
            <summary>
            The Oculus Touch controller for Oculus Utilities.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Daydream_Controller">
            <summary>
            The Daydream controller for Google Daydream SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Ximmerse_Flip">
            <summary>
            The Flip controller for Ximmerse SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.SteamVR_ValveKnuckles">
            <summary>
            The Valve Knuckles controller for SteamVR.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Oculus_OculusGamepad">
            <summary>
            The Oculus Gamepad for Oculus Utilities.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Oculus_OculusRemote">
            <summary>
            The Oculus Remote for Oculus Utilities.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Oculus_GearVRHMD">
            <summary>
            The Oculus GearVR HMD controls for Oculus Utilities.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.Oculus_GearVRController">
            <summary>
            The Oculus GearVR controller for Oculus Utilities.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.WindowsMR_MotionController">
            <summary>
            The Windows Mixed Reality Motion Controller for Windows Mixed Reality.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseController.ControllerType.SteamVR_WindowsMRController">
            <summary>
            The Windows Mixed Reality Motion Controller for SteamVR.
            </summary>
        </member>
        <member name="M:VRTK.SDK_BaseController.ProcessUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_BaseController.ProcessFixedUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerDefaultColliderPath(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerDefaultColliderPath returns the path to the prefab that contains the collider objects for the default controller of this SDK.
            </summary>
            <param name="hand">The controller hand to check for</param>
            <returns>A path to the resource that contains the collider GameObject.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerElementPath(VRTK.SDK_BaseController.ControllerElements,VRTK.SDK_BaseController.ControllerHand,System.Boolean)">
            <summary>
            The GetControllerElementPath returns the path to the game object that the given controller element for the given hand resides in.
            </summary>
            <param name="element">The controller element to look up.</param>
            <param name="hand">The controller hand to look up.</param>
            <param name="fullPath">Whether to get the initial path or the full path to the element.</param>
            <returns>A string containing the path to the game object that the controller element resides in.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method returns the index of the given controller.
            </summary>
            <param name="controller">The GameObject containing the controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method returns the GameObject of a controller with a specific index.
            </summary>
            <param name="index">The index of the controller to find.</param>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject of the controller</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method returns the origin of the given controller.
            </summary>
            <param name="controllerReference">The reference to the controller to retrieve the origin from.</param>
            <returns>A Transform containing the origin of the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GenerateControllerPointerOrigin(UnityEngine.GameObject)">
            <summary>
            The GenerateControllerPointerOrigin method can create a custom pointer origin Transform to represent the pointer position and forward.
            </summary>
            <param name="parent">The GameObject that the origin will become parent of. If it is a controller then it will also be used to determine the hand if required.</param>
            <returns>A generated Transform that contains the custom pointer origin.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method returns the GameObject containing the representation of the left hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method returns the GameObject containing the representation of the right hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand/1 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand/1 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.IsControllerLeftHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerLeftHand/2 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.IsControllerRightHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerRightHand/2 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.WaitForControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The WaitForControllerModel method determines whether the controller model for the given hand requires waiting to load in on scene start.
            </summary>
            <param name="hand">The hand to determine if the controller model will be ready for.</param>
            <returns>Returns true if the controller model requires loading in at runtime and therefore needs waiting for. Returns false if the controller model will be available at start.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerModel(UnityEngine.GameObject)">
            <summary>
            The GetControllerModel method returns the model alias for the given GameObject.
            </summary>
            <param name="controller">The GameObject to get the model alias for.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerModel method returns the model alias for the given controller hand.
            </summary>
            <param name="hand">The hand enum of which controller model to retrieve.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerModelHand(UnityEngine.GameObject)">
            <summary>
            The GetControllerModelHand method returns the hand for the given controller model GameObject.
            </summary>
            <param name="controllerModel">The controller model GameObject to get the hand for.</param>
            <returns>The hand enum for which the given controller model is for.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerRenderModel(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerRenderModel method gets the game object that contains the given controller's render model.
            </summary>
            <param name="controllerReference">The reference to the controller to check.</param>
            <returns>A GameObject containing the object that has a render model for the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.SetControllerRenderModelWheel(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetControllerRenderModelWheel method sets the state of the scroll wheel on the controller render model.
            </summary>
            <param name="renderModel">The GameObject containing the controller render model.</param>
            <param name="state">If true and the render model has a scroll wheen then it will be displayed, if false then the scroll wheel will be hidden.</param>
        </member>
        <member name="M:VRTK.SDK_BaseController.HapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The HapticPulse/2 method is used to initiate a simple haptic pulse on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.SDK_BaseController.HapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The HapticPulse/2 method is used to initiate a haptic pulse based on an audio clip on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetHapticModifiers">
            <summary>
            The GetHapticModifiers method is used to return modifiers for the duration and interval if the SDK handles it slightly differently.
            </summary>
            <returns>An SDK_ControllerHapticModifiers object with a given `durationModifier` and an `intervalModifier`.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetVelocity method is used to determine the current velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetAngularVelocity method is used to determine the current angular velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current angular velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.IsTouchpadStatic(System.Boolean,UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The IsTouchpadStatic method is used to determine if the touchpad is currently not being moved.
            </summary>
            <param name="currentAxisValues"></param>
            <param name="previousAxisValues"></param>
            <param name="compareFidelity"></param>
            <returns>Returns true if the touchpad is not currently being touched or moved.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetButtonAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonAxis method retrieves the current X/Y axis values for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the axis on.</param>
            <param name="controllerReference">The reference to the controller to check the button axis on.</param>
            <returns>A Vector2 of the X/Y values of the button axis. If no axis values exist for the given button, then a Vector2.Zero is returned.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetButtonSenseAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonSenseAxis method retrieves the current sense axis value for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the sense axis on.</param>
            <param name="controllerReference">The reference to the controller to check the sense axis on.</param>
            <returns>The current sense axis value.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetButtonHairlineDelta(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonHairlineDelta method is used to get the difference between the current button press and the previous frame button press.
            </summary>
            <param name="buttonType">The type of button to get the hairline delta for.</param>
            <param name="controllerReference">The reference to the controller to get the hairline delta for.</param>
            <returns>The delta between the button presses.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseController.GetControllerButtonState(VRTK.SDK_BaseController.ButtonTypes,VRTK.SDK_BaseController.ButtonPressTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerButtonState method is used to determine if the given controller button for the given press type on the given controller reference is currently taking place.
            </summary>
            <param name="buttonType">The type of button to check for the state of.</param>
            <param name="pressType">The button state to check for.</param>
            <param name="controllerReference">The reference to the controller to check the button state on.</param>
            <returns>Returns true if the given button is in the state of the given press type on the given controller reference.</returns>
        </member>
        <member name="T:VRTK.SDK_BaseHeadset">
            <summary>
            The Base Headset SDK script provides a bridge to SDK methods that deal with the VR Headset.
            </summary>
            <remarks>
            This is an abstract class to implement the interface required by all implemented SDKs.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_BaseHeadset.HeadsetType">
            <summary>
            The connected headset type
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.Undefined">
            <summary>
            The headset connected is unknown.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.Simulator">
            <summary>
            The headset associated with the simulator.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.HTCVive">
            <summary>
            The HTC Vive headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.OculusRiftDK1">
            <summary>
            The Oculus Rift DK1 headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.OculusRiftDK2">
            <summary>
            The Oculus Rift DK2 headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.OculusRift">
            <summary>
            The Oculus Rift headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.OculusGearVR">
            <summary>
            The Oculus GearVR headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.GoogleDaydream">
            <summary>
            The Google Daydream headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.GoogleCardboard">
            <summary>
            The Google Cardboard headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.HyperealVR">
            <summary>
            The HyperealVR headset.
            </summary>
        </member>
        <member name="F:VRTK.SDK_BaseHeadset.HeadsetType.WindowsMixedReality">
            <summary>
            The Windows Mixed Reality headset.
            </summary>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.ProcessUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.ProcessFixedUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.GetHeadset">
            <summary>
            The GetHeadset method returns the Transform of the object that is used to represent the headset in the scene.
            </summary>
            <returns>A transform of the object representing the headset in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.GetHeadsetCamera">
            <summary>
            The GetHeadsetCamera method returns the Transform of the object that is used to hold the headset camera in the scene.
            </summary>
            <returns>A transform of the object holding the headset camera in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.HeadsetFade(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            The HeadsetFade method is used to apply a fade to the headset camera to progressively change the colour.
            </summary>
            <param name="color">The colour to fade to.</param>
            <param name="duration">The amount of time the fade should take to reach the given colour.</param>
            <param name="fadeOverlay">Determines whether to use an overlay on the fade.</param>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.HasHeadsetFade(UnityEngine.Transform)">
            <summary>
            The HasHeadsetFade method checks to see if the given game object (usually the camera) has the ability to fade the viewpoint.
            </summary>
            <param name="obj">The Transform to check to see if a camera fade is available on.</param>
            <returns>Returns true if the headset has fade functionality on it.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseHeadset.AddHeadsetFade(UnityEngine.Transform)">
            <summary>
            The AddHeadsetFade method attempts to add the fade functionality to the game object with the camera on it.
            </summary>
            <param name="camera">The Transform to with the camera on to add the fade functionality to.</param>
        </member>
        <member name="T:VRTK.SDK_BaseSystem">
            <summary>
            The Base System SDK script provides a bridge to core system SDK methods.
            </summary>
            <remarks>
            This is an abstract class to implement the interface required by all implemented SDKs.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_BaseSystem.IsDisplayOnDesktop">
            <summary>
            The IsDisplayOnDesktop method returns true if the display is extending the desktop.
            </summary>
            <returns>Returns true if the display is extending the desktop</returns>
        </member>
        <member name="M:VRTK.SDK_BaseSystem.ShouldAppRenderWithLowResources">
            <summary>
            The ShouldAppRenderWithLowResources method is used to determine if the Unity app should use low resource mode. Typically true when the dashboard is showing.
            </summary>
            <returns>Returns true if the Unity app should render with low resources.</returns>
        </member>
        <member name="M:VRTK.SDK_BaseSystem.ForceInterleavedReprojectionOn(System.Boolean)">
            <summary>
            The ForceInterleavedReprojectionOn method determines whether Interleaved Reprojection should be forced on or off.
            </summary>
            <param name="force">If true then Interleaved Reprojection will be forced on, if false it will not be forced on.</param>
        </member>
        <member name="T:VRTK.SDK_DescriptionAttribute">
            <summary>
            Describes a class that represents an SDK. Only allowed on classes that inherit from SDK_Base.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DescriptionAttribute.prettyName">
            <summary>
            The pretty name of the SDK. Uniquely identifies the SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DescriptionAttribute.symbol">
            <summary>
            The scripting define symbol needed for the SDK. Needs to be the same as `SDK_ScriptingDefineSymbolPredicateAttribute.symbol` to add and remove the scripting define symbol automatically using VRTK_SDKManager.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DescriptionAttribute.vrDeviceName">
            <summary>
            The name of the VR Device to load.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DescriptionAttribute.index">
            <summary>
            The index of this attribute, in case there are multiple on the same target.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DescriptionAttribute.buildTargetGroup">
            <summary>
            The build target group this SDK is for.
            </summary>
        </member>
        <member name="P:VRTK.SDK_DescriptionAttribute.describesFallbackSDK">
            <summary>
            Whether this description describes a fallback SDK.
            </summary>
        </member>
        <member name="M:VRTK.SDK_DescriptionAttribute.#ctor(System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            Creates a new attribute.
            </summary>
            <param name="prettyName">The pretty name of the SDK. Uniquely identifies the SDK. `null` and `string.Empty` aren't allowed.</param>
            <param name="symbol">The scripting define symbol needed for the SDK. Needs to be the same as `SDK_ScriptingDefineSymbolPredicateAttribute.symbol` to add and remove the scripting define symbol automatically using VRTK_SDKManager. `null` and `string.Empty` are allowed.</param>
            <param name="vrDeviceName">The name of the VR Device to load. Set to `null` or `string.Empty` if no VR Device is needed.</param>
            <param name="buildTargetGroupName">The name of a constant of `BuildTargetGroup`. `BuildTargetGroup.Unknown`, `null` and `string.Empty` are not allowed.</param>
            <param name="index">The index of this attribute, in case there are multiple on the same target.</param>
        </member>
        <member name="M:VRTK.SDK_DescriptionAttribute.#ctor(System.Type,System.Int32)">
            <summary>
            Creates a new attribute by copying from another attribute on a given type.
            </summary>
            <param name="typeToCopyExistingDescriptionFrom">The type to copy the existing SDK_DescriptionAttribute from. `null` is not allowed.</param>
            <param name="index">The index of the description to copy from the the existing SDK_DescriptionAttribute.</param>
        </member>
        <member name="T:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute">
            <summary>
            Specifies a method to be used as a predicate to allow VRTK_SDKManager to automatically add and remove scripting define symbols. Only allowed on static methods that take no arguments and return a `bool`.
            </summary>
        </member>
        <member name="F:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute.RemovableSymbolPrefix">
            <summary>
            The prefix of scripting define symbols that must be used to be able to automatically remove the symbols.
            </summary>
        </member>
        <member name="F:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute.symbol">
            <summary>
            The scripting define symbol to conditionally add or remove.
            </summary>
        </member>
        <member name="F:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute.buildTargetGroup">
            <summary>
            The build target group to use when conditionally adding or removing symbol.
            </summary>
        </member>
        <member name="M:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates a new attribute.
            </summary>
            <param name="symbol">The scripting define symbol to conditionally add or remove. Needs to start with `RemovableSymbolPrefix` to be able to automatically remove the symbol. `null` and `string.Empty` are not allowed.</param>
            <param name="buildTargetGroupName">The name of a constant of `BuildTargetGroup`. `BuildTargetGroup.Unknown`, `null` and `string.Empty` are not allowed.</param>
        </member>
        <member name="M:VRTK.SDK_ScriptingDefineSymbolPredicateAttribute.#ctor(VRTK.SDK_ScriptingDefineSymbolPredicateAttribute)">
            <summary>
            Creates a new attribute by copying an existing one.
            </summary>
            <param name="attributeToCopy">The attribute to copy.</param>
        </member>
        <member name="T:VRTK.SDK_DaydreamBoundaries">
            <summary>
            The Daydream Boundaries SDK script provides dummy functions for the play area boundaries.
            </summary>
        </member>
        <member name="T:VRTK.SDK_DaydreamController">
            <summary>
            The Daydream Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="T:VRTK.SDK_DaydreamDefines">
            <summary>
            Handles all the scripting define symbols for the Daydream SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_DaydreamDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Daydream SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_DaydreamHeadset">
            <summary>
            The Daydream Headset SDK script provides dummy functions for the headset.
            </summary>
        </member>
        <member name="T:VRTK.SDK_DaydreamSystem">
            <summary>
            The Daydream System SDK script provides dummy functions for system functions.
            </summary>
        </member>
        <member name="T:VRTK.SDK_FallbackBoundaries">
            <summary>
            The Fallback Boundaries SDK script provides a fallback collection of methods that return null or default headset values.
            </summary>
            <remarks>
            This is the fallback class that will just return default values.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.InitBoundaries">
            <summary>
            The InitBoundaries method is run on start of scene and can be used to initialse anything on game start.
            </summary>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.GetPlayArea">
            <summary>
            The GetPlayArea method returns the Transform of the object that is used to represent the play area in the scene.
            </summary>
            <returns>A transform of the object representing the play area in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.GetPlayAreaVertices">
            <summary>
            The GetPlayAreaVertices method returns the points of the play area boundaries.
            </summary>
            <returns>A Vector3 array of the points in the scene that represent the play area boundaries.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.GetPlayAreaBorderThickness">
            <summary>
            The GetPlayAreaBorderThickness returns the thickness of the drawn border for the given play area.
            </summary>
            <returns>The thickness of the drawn border.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.IsPlayAreaSizeCalibrated">
            <summary>
            The IsPlayAreaSizeCalibrated method returns whether the given play area size has been auto calibrated by external sensors.
            </summary>
            <returns>Returns true if the play area size has been auto calibrated and set by external sensors.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.GetDrawAtRuntime">
            <summary>
            The GetDrawAtRuntime method returns whether the given play area drawn border is being displayed.
            </summary>
            <returns>Returns true if the drawn border is being displayed.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackBoundaries.SetDrawAtRuntime(System.Boolean)">
            <summary>
            The SetDrawAtRuntime method sets whether the given play area drawn border should be displayed at runtime.
            </summary>
            <param name="value">The state of whether the drawn border should be displayed or not.</param>
        </member>
        <member name="T:VRTK.SDK_FallbackController">
            <summary>
            The Fallback Controller SDK script provides a fallback collection of methods that return null or default headset values.
            </summary>
            <remarks>
            This is the fallback class that will just return default values.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_FallbackController.ProcessUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackController.ProcessFixedUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerDefaultColliderPath(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerDefaultColliderPath returns the path to the prefab that contains the collider objects for the default controller of this SDK.
            </summary>
            <param name="hand">The controller hand to check for</param>
            <returns>A path to the resource that contains the collider GameObject.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerElementPath(VRTK.SDK_BaseController.ControllerElements,VRTK.SDK_BaseController.ControllerHand,System.Boolean)">
            <summary>
            The GetControllerElementPath returns the path to the game object that the given controller element for the given hand resides in.
            </summary>
            <param name="element">The controller element to look up.</param>
            <param name="hand">The controller hand to look up.</param>
            <param name="fullPath">Whether to get the initial path or the full path to the element.</param>
            <returns>A string containing the path to the game object that the controller element resides in.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method returns the index of the given controller.
            </summary>
            <param name="controller">The GameObject containing the controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method returns the GameObject of a controller with a specific index.
            </summary>
            <param name="index">The index of the controller to find.</param>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject of the controller</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method returns the origin of the given controller.
            </summary>
            <param name="controllerReference">The reference to the controller to retrieve the origin from.</param>
            <returns>A Transform containing the origin of the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GenerateControllerPointerOrigin(UnityEngine.GameObject)">
            <summary>
            The GenerateControllerPointerOrigin method can create a custom pointer origin Transform to represent the pointer position and forward.
            </summary>
            <param name="parent">The GameObject that the origin will become parent of. If it is a controller then it will also be used to determine the hand if required.</param>
            <returns>A generated Transform that contains the custom pointer origin.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method returns the GameObject containing the representation of the left hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method returns the GameObject containing the representation of the right hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand/1 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand/1 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.IsControllerLeftHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerLeftHand/2 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.IsControllerRightHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerRightHand/2 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.WaitForControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The WaitForControllerModel method determines whether the controller model for the given hand requires waiting to load in on scene start.
            </summary>
            <param name="hand">The hand to determine if the controller model will be ready for.</param>
            <returns>Returns true if the controller model requires loading in at runtime and therefore needs waiting for. Returns false if the controller model will be available at start.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerModel(UnityEngine.GameObject)">
            <summary>
            The GetControllerModel method returns the model alias for the given GameObject.
            </summary>
            <param name="controller">The GameObject to get the model alias for.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerModel method returns the model alias for the given controller hand.
            </summary>
            <param name="hand">The hand enum of which controller model to retrieve.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerRenderModel(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerRenderModel method gets the game object that contains the given controller's render model.
            </summary>
            <param name="controllerReference">The reference to the controller to check.</param>
            <returns>A GameObject containing the object that has a render model for the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.SetControllerRenderModelWheel(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetControllerRenderModelWheel method sets the state of the scroll wheel on the controller render model.
            </summary>
            <param name="renderModel">The GameObject containing the controller render model.</param>
            <param name="state">If true and the render model has a scroll wheen then it will be displayed, if false then the scroll wheel will be hidden.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackController.HapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The HapticPulse/2 method is used to initiate a simple haptic pulse on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackController.HapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The HapticPulse/2 method is used to initiate a haptic pulse based on an audio clip on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetHapticModifiers">
            <summary>
            The GetHapticModifiers method is used to return modifiers for the duration and interval if the SDK handles it slightly differently.
            </summary>
            <returns>An SDK_ControllerHapticModifiers object with a given `durationModifier` and an `intervalModifier`.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetVelocity method is used to determine the current velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetAngularVelocity method is used to determine the current angular velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current angular velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.IsTouchpadStatic(System.Boolean,UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The IsTouchpadStatic method is used to determine if the touchpad is currently not being moved.
            </summary>
            <param name="currentAxisValues"></param>
            <param name="previousAxisValues"></param>
            <param name="compareFidelity"></param>
            <returns>Returns true if the touchpad is not currently being touched or moved.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetButtonAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonAxis method retrieves the current X/Y axis values for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the axis on.</param>
            <param name="controllerReference">The reference to the controller to check the button axis on.</param>
            <returns>A Vector2 of the X/Y values of the button axis. If no axis values exist for the given button, then a Vector2.Zero is returned.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetButtonSenseAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonSenseAxis method retrieves the current sense axis value for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the sense axis on.</param>
            <param name="controllerReference">The reference to the controller to check the sense axis on.</param>
            <returns>The current sense axis value.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetButtonHairlineDelta(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonHairlineDelta method is used to get the difference between the current button press and the previous frame button press.
            </summary>
            <param name="buttonType">The type of button to get the hairline delta for.</param>
            <param name="controllerReference">The reference to the controller to get the hairline delta for.</param>
            <returns>The delta between the button presses.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackController.GetControllerButtonState(VRTK.SDK_BaseController.ButtonTypes,VRTK.SDK_BaseController.ButtonPressTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerButtonState method is used to determine if the given controller button for the given press type on the given controller reference is currently taking place.
            </summary>
            <param name="buttonType">The type of button to check for the state of.</param>
            <param name="pressType">The button state to check for.</param>
            <param name="controllerReference">The reference to the controller to check the button state on.</param>
            <returns>Returns true if the given button is in the state of the given press type on the given controller reference.</returns>
        </member>
        <member name="T:VRTK.SDK_FallbackHeadset">
            <summary>
            The Fallback Headset SDK script provides a fallback collection of methods that return null or default headset values.
            </summary>
            <remarks>
            This is the fallback class that will just return default values.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.ProcessUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.ProcessFixedUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.GetHeadset">
            <summary>
            The GetHeadset method returns the Transform of the object that is used to represent the headset in the scene.
            </summary>
            <returns>A transform of the object representing the headset in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.GetHeadsetCamera">
            <summary>
            The GetHeadsetCamera method returns the Transform of the object that is used to hold the headset camera in the scene.
            </summary>
            <returns>A transform of the object holding the headset camera in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.HeadsetFade(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            The HeadsetFade method is used to apply a fade to the headset camera to progressively change the colour.
            </summary>
            <param name="color">The colour to fade to.</param>
            <param name="duration">The amount of time the fade should take to reach the given colour.</param>
            <param name="fadeOverlay">Determines whether to use an overlay on the fade.</param>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.HasHeadsetFade(UnityEngine.Transform)">
            <summary>
            The HasHeadsetFade method checks to see if the given game object (usually the camera) has the ability to fade the viewpoint.
            </summary>
            <param name="obj">The Transform to check to see if a camera fade is available on.</param>
            <returns>Returns true if the headset has fade functionality on it.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackHeadset.AddHeadsetFade(UnityEngine.Transform)">
            <summary>
            The AddHeadsetFade method attempts to add the fade functionality to the game object with the camera on it.
            </summary>
            <param name="camera">The Transform to with the camera on to add the fade functionality to.</param>
        </member>
        <member name="T:VRTK.SDK_FallbackSystem">
            <summary>
            The Fallback System SDK script provides a fallback collection of methods that return null or default system values.
            </summary>
            <remarks>
            This is the fallback class that will just return default values.
            </remarks>
        </member>
        <member name="M:VRTK.SDK_FallbackSystem.IsDisplayOnDesktop">
            <summary>
            The IsDisplayOnDesktop method returns true if the display is extending the desktop.
            </summary>
            <returns>Returns true if the display is extending the desktop</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackSystem.ShouldAppRenderWithLowResources">
            <summary>
            The ShouldAppRenderWithLowResources method is used to determine if the Unity app should use low resource mode. Typically true when the dashboard is showing.
            </summary>
            <returns>Returns true if the Unity app should render with low resources.</returns>
        </member>
        <member name="M:VRTK.SDK_FallbackSystem.ForceInterleavedReprojectionOn(System.Boolean)">
            <summary>
            The ForceInterleavedReprojectionOn method determines whether Interleaved Reprojection should be forced on or off.
            </summary>
            <param name="force">If true then Interleaved Reprojection will be forced on, if false it will not be forced on.</param>
        </member>
        <member name="T:VRTK.SDK_HyperealVRBoundaries">
            <summary>
            The HyperealVR Boundaries SDK script provides a bridge to the HyperealVR SDK play area.
            </summary>
        </member>
        <member name="T:VRTK.SDK_HyperealVRController">
            <summary>
            The HyperealVR Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="T:VRTK.SDK_HyperealVRDefines">
            <summary>
            Handles all the scripting define symbols for the Hypereal SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_HyperealVRDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Hypereal SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_HyperealVRHeadset">
            <summary>
            The HyperealVR Headset SDK script provides a bridge to the HyperealVR SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_HyperealVRSystem">
            <summary>
            The HyperealVR System SDK script provides a bridge to the HyperealVR SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_OculusBoundaries">
            <summary>
            The Oculus Boundaries SDK script provides a bridge to the Oculus SDK play area.
            </summary>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.InitBoundaries">
            <summary>
            The InitBoundaries method is run on start of scene and can be used to initialse anything on game start.
            </summary>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.GetPlayArea">
            <summary>
            The GetPlayArea method returns the Transform of the object that is used to represent the play area in the scene.
            </summary>
            <returns>A transform of the object representing the play area in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.GetPlayAreaVertices">
            <summary>
            The GetPlayAreaVertices method returns the points of the play area boundaries.
            </summary>
            <returns>A Vector3 array of the points in the scene that represent the play area boundaries.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.GetPlayAreaBorderThickness">
            <summary>
            The GetPlayAreaBorderThickness returns the thickness of the drawn border for the given play area.
            </summary>
            <returns>The thickness of the drawn border.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.IsPlayAreaSizeCalibrated">
            <summary>
            The IsPlayAreaSizeCalibrated method returns whether the given play area size has been auto calibrated by external sensors.
            </summary>
            <returns>Returns true if the play area size has been auto calibrated and set by external sensors.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.GetDrawAtRuntime">
            <summary>
            The GetDrawAtRuntime method returns whether the given play area drawn border is being displayed.
            </summary>
            <returns>Returns true if the drawn border is being displayed.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusBoundaries.SetDrawAtRuntime(System.Boolean)">
            <summary>
            The SetDrawAtRuntime method sets whether the given play area drawn border should be displayed at runtime.
            </summary>
            <param name="value">The state of whether the drawn border should be displayed or not.</param>
        </member>
        <member name="T:VRTK.SDK_OculusController">
            <summary>
            The Oculus Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="M:VRTK.SDK_OculusController.OnAfterSetupLoad(VRTK.VRTK_SDKSetup)">
            <summary>
            This method is called just after loading the VRTK_SDKSetup that's using this SDK.
            </summary>
            <param name="setup">The SDK Setup which is using this SDK.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.ProcessUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.ProcessFixedUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerDefaultColliderPath(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerDefaultColliderPath returns the path to the prefab that contains the collider objects for the default controller of this SDK.
            </summary>
            <param name="hand">The controller hand to check for</param>
            <returns>A path to the resource that contains the collider GameObject.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerElementPath(VRTK.SDK_BaseController.ControllerElements,VRTK.SDK_BaseController.ControllerHand,System.Boolean)">
            <summary>
            The GetControllerElementPath returns the path to the game object that the given controller element for the given hand resides in.
            </summary>
            <param name="element">The controller element to look up.</param>
            <param name="hand">The controller hand to look up.</param>
            <param name="fullPath">Whether to get the initial path or the full path to the element.</param>
            <returns>A string containing the path to the game object that the controller element resides in.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method returns the index of the given controller.
            </summary>
            <param name="controller">The GameObject containing the controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method returns the GameObject of a controller with a specific index.
            </summary>
            <param name="index">The index of the controller to find.</param>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject of the controller</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method returns the origin of the given controller.
            </summary>
            <param name="controllerReference">The reference to the controller to retrieve the origin from.</param>
            <returns>A Transform containing the origin of the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GenerateControllerPointerOrigin(UnityEngine.GameObject)">
            <summary>
            The GenerateControllerPointerOrigin method can create a custom pointer origin Transform to represent the pointer position and forward.
            </summary>
            <param name="parent">The GameObject that the origin will become parent of. If it is a controller then it will also be used to determine the hand if required.</param>
            <returns>A generated Transform that contains the custom pointer origin.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method returns the GameObject containing the representation of the left hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method returns the GameObject containing the representation of the right hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand/1 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand/1 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.IsControllerLeftHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerLeftHand/2 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.IsControllerRightHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerRightHand/2 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.WaitForControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The WaitForControllerModel method determines whether the controller model for the given hand requires waiting to load in on scene start.
            </summary>
            <param name="hand">The hand to determine if the controller model will be ready for.</param>
            <returns>Returns true if the controller model requires loading in at runtime and therefore needs waiting for. Returns false if the controller model will be available at start.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerModel(UnityEngine.GameObject)">
            <summary>
            The GetControllerModel method returns the model alias for the given GameObject.
            </summary>
            <param name="controller">The GameObject to get the model alias for.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerModel method returns the model alias for the given controller hand.
            </summary>
            <param name="hand">The hand enum of which controller model to retrieve.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerRenderModel(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerRenderModel method gets the game object that contains the given controller's render model.
            </summary>
            <param name="controllerReference">The reference to the controller to check.</param>
            <returns>A GameObject containing the object that has a render model for the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.SetControllerRenderModelWheel(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetControllerRenderModelWheel method sets the state of the scroll wheel on the controller render model.
            </summary>
            <param name="renderModel">The GameObject containing the controller render model.</param>
            <param name="state">If true and the render model has a scroll wheen then it will be displayed, if false then the scroll wheel will be hidden.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.HapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The HapticPulse/2 method is used to initiate a simple haptic pulse on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.HapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The HapticPulse/2 method is used to initiate a haptic pulse based on an audio clip on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetHapticModifiers">
            <summary>
            The GetHapticModifiers method is used to return modifiers for the duration and interval if the SDK handles it slightly differently.
            </summary>
            <returns>An SDK_ControllerHapticModifiers object with a given `durationModifier` and an `intervalModifier`.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetVelocity method is used to determine the current velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetAngularVelocity method is used to determine the current angular velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current angular velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.IsTouchpadStatic(System.Boolean,UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The IsTouchpadStatic method is used to determine if the touchpad is currently not being moved.
            </summary>
            <param name="currentAxisValues"></param>
            <param name="previousAxisValues"></param>
            <param name="compareFidelity"></param>
            <returns>Returns true if the touchpad is not currently being touched or moved.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetButtonAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonAxis method retrieves the current X/Y axis values for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the axis on.</param>
            <param name="controllerReference">The reference to the controller to check the button axis on.</param>
            <returns>A Vector2 of the X/Y values of the button axis. If no axis values exist for the given button, then a Vector2.Zero is returned.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetButtonSenseAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonSenseAxis method retrieves the current sense axis value for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the sense axis on.</param>
            <param name="controllerReference">The reference to the controller to check the sense axis on.</param>
            <returns>The current sense axis value.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetButtonHairlineDelta(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonHairlineDelta method is used to get the difference between the current button press and the previous frame button press.
            </summary>
            <param name="buttonType">The type of button to get the hairline delta for.</param>
            <param name="controllerReference">The reference to the controller to get the hairline delta for.</param>
            <returns>The delta between the button presses.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusController.GetControllerButtonState(VRTK.SDK_BaseController.ButtonTypes,VRTK.SDK_BaseController.ButtonPressTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerButtonState method is used to determine if the given controller button for the given press type on the given controller reference is currently taking place.
            </summary>
            <param name="buttonType">The type of button to check for the state of.</param>
            <param name="pressType">The button state to check for.</param>
            <param name="controllerReference">The reference to the controller to check the button state on.</param>
            <returns>Returns true if the given button is in the state of the given press type on the given controller reference.</returns>
        </member>
        <member name="T:VRTK.SDK_OculusDefines">
            <summary>
            Handles all the scripting define symbols for the Oculus and Avatar SDKs.
            </summary>
        </member>
        <member name="F:VRTK.SDK_OculusDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Oculus SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_OculusDefines.AvatarScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Oculus Avatar SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_OculusHeadset">
            <summary>
            The Oculus Headset SDK script provides a bridge to the Oculus SDK.
            </summary>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.ProcessUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.ProcessFixedUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.GetHeadset">
            <summary>
            The GetHeadset method returns the Transform of the object that is used to represent the headset in the scene.
            </summary>
            <returns>A transform of the object representing the headset in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.GetHeadsetCamera">
            <summary>
            The GetHeadsetCamera method returns the Transform of the object that is used to hold the headset camera in the scene.
            </summary>
            <returns>A transform of the object holding the headset camera in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.HeadsetFade(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            The HeadsetFade method is used to apply a fade to the headset camera to progressively change the colour.
            </summary>
            <param name="color">The colour to fade to.</param>
            <param name="duration">The amount of time the fade should take to reach the given colour.</param>
            <param name="fadeOverlay">Determines whether to use an overlay on the fade.</param>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.HasHeadsetFade(UnityEngine.Transform)">
            <summary>
            The HasHeadsetFade method checks to see if the given game object (usually the camera) has the ability to fade the viewpoint.
            </summary>
            <param name="obj">The Transform to check to see if a camera fade is available on.</param>
            <returns>Returns true if the headset has fade functionality on it.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusHeadset.AddHeadsetFade(UnityEngine.Transform)">
            <summary>
            The AddHeadsetFade method attempts to add the fade functionality to the game object with the camera on it.
            </summary>
            <param name="camera">The Transform to with the camera on to add the fade functionality to.</param>
        </member>
        <member name="T:VRTK.SDK_OculusSystem">
            <summary>
            The Oculus System SDK script provides a bridge to the Oculus SDK.
            </summary>
        </member>
        <member name="M:VRTK.SDK_OculusSystem.IsDisplayOnDesktop">
            <summary>
            The IsDisplayOnDesktop method returns true if the display is extending the desktop.
            </summary>
            <returns>Returns true if the display is extending the desktop</returns>
        </member>
        <member name="M:VRTK.SDK_OculusSystem.ShouldAppRenderWithLowResources">
            <summary>
            The ShouldAppRenderWithLowResources method is used to determine if the Unity app should use low resource mode. Typically true when the dashboard is showing.
            </summary>
            <returns>Returns true if the Unity app should render with low resources.</returns>
        </member>
        <member name="M:VRTK.SDK_OculusSystem.ForceInterleavedReprojectionOn(System.Boolean)">
            <summary>
            The ForceInterleavedReprojectionOn method determines whether Interleaved Reprojection should be forced on or off.
            </summary>
            <param name="force">If true then Interleaved Reprojection will be forced on, if false it will not be forced on.</param>
        </member>
        <member name="T:VRTK.SDK_InputSimulator">
            <summary>
            The `[VRSimulator_CameraRig]` prefab is a mock Camera Rig set up that can be used to develop with VRTK without the need for VR Hardware.
            </summary>
            <remarks>
            Use the mouse and keyboard to move around both play area and hands and interacting with objects without the need of a hmd or VR controls.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_InputSimulator.MouseInputMode">
            <summary>
            Mouse input mode types
            </summary>
        </member>
        <member name="F:VRTK.SDK_InputSimulator.MouseInputMode.Always">
            <summary>
            Mouse movement is always treated as mouse input.
            </summary>
        </member>
        <member name="F:VRTK.SDK_InputSimulator.MouseInputMode.RequiresButtonPress">
            <summary>
            Mouse movement is only treated as movement when a button is pressed.
            </summary>
        </member>
        <member name="M:VRTK.SDK_InputSimulator.FindInScene">
            <summary>
            The FindInScene method is used to find the `[VRSimulator_CameraRig]` GameObject within the current scene.
            </summary>
            <returns>Returns the found `[VRSimulator_CameraRig]` GameObject if it is found. If it is not found then it prints a debug log error.</returns>
        </member>
        <member name="T:VRTK.SDK_SimBoundaries">
            <summary>
            The Sim Boundaries SDK script provides dummy functions for the play area boundaries.
            </summary>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.InitBoundaries">
            <summary>
            The InitBoundaries method is run on start of scene and can be used to initialse anything on game start.
            </summary>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.GetPlayArea">
            <summary>
            The GetPlayArea method returns the Transform of the object that is used to represent the play area in the scene.
            </summary>
            <returns>A transform of the object representing the play area in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.GetPlayAreaVertices">
            <summary>
            The GetPlayAreaVertices method returns the points of the play area boundaries.
            </summary>
            <returns>A Vector3 array of the points in the scene that represent the play area boundaries.</returns>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.GetPlayAreaBorderThickness">
            <summary>
            The GetPlayAreaBorderThickness returns the thickness of the drawn border for the given play area.
            </summary>
            <returns>The thickness of the drawn border.</returns>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.IsPlayAreaSizeCalibrated">
            <summary>
            The IsPlayAreaSizeCalibrated method returns whether the given play area size has been auto calibrated by external sensors.
            </summary>
            <returns>Returns true if the play area size has been auto calibrated and set by external sensors.</returns>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.GetDrawAtRuntime">
            <summary>
            The GetDrawAtRuntime method returns whether the given play area drawn border is being displayed.
            </summary>
            <returns>Returns true if the drawn border is being displayed.</returns>
        </member>
        <member name="M:VRTK.SDK_SimBoundaries.SetDrawAtRuntime(System.Boolean)">
            <summary>
            The SetDrawAtRuntime method sets whether the given play area drawn border should be displayed at runtime.
            </summary>
            <param name="value">The state of whether the drawn border should be displayed or not.</param>
        </member>
        <member name="T:VRTK.SDK_SimController">
            <summary>
            The Sim Controller SDK script provides functions to help simulate VR controllers.
            </summary>
        </member>
        <member name="M:VRTK.SDK_SimController.ProcessUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_SimController.ProcessFixedUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_SimController.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerDefaultColliderPath(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerDefaultColliderPath returns the path to the prefab that contains the collider objects for the default controller of this SDK.
            </summary>
            <param name="hand">The controller hand to check for</param>
            <returns>A path to the resource that contains the collider GameObject.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerElementPath(VRTK.SDK_BaseController.ControllerElements,VRTK.SDK_BaseController.ControllerHand,System.Boolean)">
            <summary>
            The GetControllerElementPath returns the path to the game object that the given controller element for the given hand resides in.
            </summary>
            <param name="element">The controller element to look up.</param>
            <param name="hand">The controller hand to look up.</param>
            <param name="fullPath">Whether to get the initial path or the full path to the element.</param>
            <returns>A string containing the path to the game object that the controller element resides in.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method returns the index of the given controller.
            </summary>
            <param name="controller">The GameObject containing the controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method returns the GameObject of a controller with a specific index.
            </summary>
            <param name="index">The index of the controller to find.</param>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject of the controller</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method returns the origin of the given controller.
            </summary>
            <param name="controllerReference">The reference to the controller to retrieve the origin from.</param>
            <returns>A Transform containing the origin of the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GenerateControllerPointerOrigin(UnityEngine.GameObject)">
            <summary>
            The GenerateControllerPointerOrigin method can create a custom pointer origin Transform to represent the pointer position and forward.
            </summary>
            <param name="parent">The GameObject that the origin will become parent of. If it is a controller then it will also be used to determine the hand if required.</param>
            <returns>A generated Transform that contains the custom pointer origin.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method returns the GameObject containing the representation of the left hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method returns the GameObject containing the representation of the right hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand/1 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand/1 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsControllerLeftHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerLeftHand/2 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsControllerRightHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerRightHand/2 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.WaitForControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The WaitForControllerModel method determines whether the controller model for the given hand requires waiting to load in on scene start.
            </summary>
            <param name="hand">The hand to determine if the controller model will be ready for.</param>
            <returns>Returns true if the controller model requires loading in at runtime and therefore needs waiting for. Returns false if the controller model will be available at start.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerModel(UnityEngine.GameObject)">
            <summary>
            The GetControllerModel method returns the model alias for the given GameObject.
            </summary>
            <param name="controller">The GameObject to get the model alias for.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerModel method returns the model alias for the given controller hand.
            </summary>
            <param name="hand">The hand enum of which controller model to retrieve.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerRenderModel(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerRenderModel method gets the game object that contains the given controller's render model.
            </summary>
            <param name="controllerReference">The reference to the controller to check.</param>
            <returns>A GameObject containing the object that has a render model for the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.SetControllerRenderModelWheel(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetControllerRenderModelWheel method sets the state of the scroll wheel on the controller render model.
            </summary>
            <param name="renderModel">The GameObject containing the controller render model.</param>
            <param name="state">If true and the render model has a scroll wheen then it will be displayed, if false then the scroll wheel will be hidden.</param>
        </member>
        <member name="M:VRTK.SDK_SimController.HapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The HapticPulse/2 method is used to initiate a simple haptic pulse on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.SDK_SimController.HapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The HapticPulse/2 method is used to initiate a haptic pulse based on an audio clip on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.SDK_SimController.GetHapticModifiers">
            <summary>
            The GetHapticModifiers method is used to return modifiers for the duration and interval if the SDK handles it slightly differently.
            </summary>
            <returns>An SDK_ControllerHapticModifiers object with a given `durationModifier` and an `intervalModifier`.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetVelocity method is used to determine the current velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetAngularVelocity method is used to determine the current angular velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current angular velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsTouchpadStatic(System.Boolean,UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The IsTouchpadStatic method is used to determine if the touchpad is currently not being moved.
            </summary>
            <param name="currentAxisValues"></param>
            <param name="previousAxisValues"></param>
            <param name="compareFidelity"></param>
            <returns>Returns true if the touchpad is not currently being touched or moved.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetButtonAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonAxis method retrieves the current X/Y axis values for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the axis on.</param>
            <param name="controllerReference">The reference to the controller to check the button axis on.</param>
            <returns>A Vector2 of the X/Y values of the button axis. If no axis values exist for the given button, then a Vector2.Zero is returned.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetButtonSenseAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonSenseAxis method retrieves the current sense axis value for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the sense axis on.</param>
            <param name="controllerReference">The reference to the controller to check the sense axis on.</param>
            <returns>The current sense axis value.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetButtonHairlineDelta(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonHairlineDelta method is used to get the difference between the current button press and the previous frame button press.
            </summary>
            <param name="buttonType">The type of button to get the hairline delta for.</param>
            <param name="controllerReference">The reference to the controller to get the hairline delta for.</param>
            <returns>The delta between the button presses.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerButtonState(VRTK.SDK_BaseController.ButtonTypes,VRTK.SDK_BaseController.ButtonPressTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerButtonState method is used to determine if the given controller button for the given press type on the given controller reference is currently taking place.
            </summary>
            <param name="buttonType">The type of button to check for the state of.</param>
            <param name="pressType">The button state to check for.</param>
            <param name="controllerReference">The reference to the controller to check the button state on.</param>
            <returns>Returns true if the given button is in the state of the given press type on the given controller reference.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsTouchModifierPressed">
            <summary>
            whether or not the touch modifier is currently pressed
            if so, pressing a key on the keyboard will only emit touch events,
            but not a real press (or hair touch events).
            </summary>
            <returns>whether or not the TouchModifier is active</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsHairTouchModifierPressed">
            <summary>
            whether or not the hair touch modifier is currently pressed
            if so, pressing a key on the keyboard will only emit touch and hair touch events,
            but not a real press.
            </summary>
            <returns>whether or not the HairTouchModifier is active</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsButtonPressIgnored">
            <summary>
            whether or not a button press shall be ignored, e.g. because of the
            use of the touch or hair touch modifier
            </summary>
            <returns>Returns true if the button press is ignored.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsButtonHairTouchIgnored">
            <summary>
            whether or not a button press shall be ignored, e.g. because of the
            use of the touch or hair touch modifier
            </summary>
            <returns>Returns true if the hair trigger touch should be ignored.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetControllerButtonState(System.UInt32,System.String,VRTK.SDK_BaseController.ButtonPressTypes)">
            <summary>
            Gets the state of the given button key mapping for the press type on the controller index.
            </summary>
            <param name="index">The index of the controller.</param>
            <param name="keyMapping">The key mapping key to check.</param>
            <param name="pressType">The type of button press to check.</param>
            <returns>Returns true if the button state matches the given data.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.IsButtonPressed(System.UInt32,VRTK.SDK_BaseController.ButtonPressTypes,UnityEngine.KeyCode)">
            <summary>
            checks if the given button (KeyCode) is currently in a specific pressed state (ButtonPressTypes) on the keyboard
            also asserts that button presses are only handled for the currently active controller by comparing the controller indices
            </summary>
            <param name="index">unique index of the controller for which the button press is to be checked</param>
            <param name="type">the type of press (up, down, hold)</param>
            <param name="button">the button on the keyboard</param>
            <returns>Returns true if the button is being pressed.</returns>
        </member>
        <member name="M:VRTK.SDK_SimController.GetActualController(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            finds the actual controller for the specified hand (identified by name) and returns it
            </summary>
            <param name="hand">the for which to find the respective controller gameobject</param>
            <returns>the gameobject of the actual controller corresponding to the specified hand</returns>
        </member>
        <member name="T:VRTK.SDK_SimHeadset">
            <summary>
            The Sim Headset SDK script  provides dummy functions for the headset.
            </summary>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.ProcessUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.ProcessFixedUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.GetHeadset">
            <summary>
            The GetHeadset method returns the Transform of the object that is used to represent the headset in the scene.
            </summary>
            <returns>A transform of the object representing the headset in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.GetHeadsetCamera">
            <summary>
            The GetHeadsetCamera/0 method returns the Transform of the object that is used to hold the headset camera in the scene.
            </summary>
            <returns>A transform of the object holding the headset camera in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.HeadsetFade(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            The HeadsetFade method is used to apply a fade to the headset camera to progressively change the colour.
            </summary>
            <param name="color">The colour to fade to.</param>
            <param name="duration">The amount of time the fade should take to reach the given colour.</param>
            <param name="fadeOverlay">Determines whether to use an overlay on the fade.</param>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.HasHeadsetFade(UnityEngine.Transform)">
            <summary>
            The HasHeadsetFade method checks to see if the given game object (usually the camera) has the ability to fade the viewpoint.
            </summary>
            <param name="obj">The Transform to check to see if a camera fade is available on.</param>
            <returns>Returns true if the headset has fade functionality on it.</returns>
        </member>
        <member name="M:VRTK.SDK_SimHeadset.AddHeadsetFade(UnityEngine.Transform)">
            <summary>
            The AddHeadsetFade method attempts to add the fade functionality to the game object with the camera on it.
            </summary>
            <param name="camera">The Transform to with the camera on to add the fade functionality to.</param>
        </member>
        <member name="T:VRTK.SDK_SimSystem">
            <summary>
            The Sim System SDK script provides dummy functions for system functions.
            </summary>
        </member>
        <member name="M:VRTK.SDK_SimSystem.IsDisplayOnDesktop">
            <summary>
            The IsDisplayOnDesktop method returns true if the display is extending the desktop.
            </summary>
            <returns>Returns true if the display is extending the desktop</returns>
        </member>
        <member name="M:VRTK.SDK_SimSystem.ShouldAppRenderWithLowResources">
            <summary>
            The ShouldAppRenderWithLowResources method is used to determine if the Unity app should use low resource mode. Typically true when the dashboard is showing.
            </summary>
            <returns>Returns true if the Unity app should render with low resources.</returns>
        </member>
        <member name="M:VRTK.SDK_SimSystem.ForceInterleavedReprojectionOn(System.Boolean)">
            <summary>
            The ForceInterleavedReprojectionOn method determines whether Interleaved Reprojection should be forced on or off.
            </summary>
            <param name="force">If true then Interleaved Reprojection will be forced on, if false it will not be forced on.</param>
        </member>
        <member name="T:VRTK.SDK_SteamVRBoundaries">
            <summary>
            The SteamVR Boundaries SDK script provides a bridge to the SteamVR SDK play area.
            </summary>
        </member>
        <member name="T:VRTK.SDK_SteamVRController">
            <summary>
            The SteamVR Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="T:VRTK.SDK_SteamVRDefines">
            <summary>
            Handles all the scripting define symbols for the SteamVR SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_SteamVRDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the SteamVR SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_SteamVRHeadset">
            <summary>
            The SteamVR Headset SDK script provides a bridge to the SteamVR SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_SteamVRSystem">
            <summary>
            The SteamVR System SDK script provides a bridge to the SteamVR SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_UnityBoundaries">
            <summary>
            The Unity Boundaries SDK script provides a bridge to a default Unity play area.
            </summary>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.InitBoundaries">
            <summary>
            The InitBoundaries method is run on start of scene and can be used to initialse anything on game start.
            </summary>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.GetPlayArea">
            <summary>
            The GetPlayArea method returns the Transform of the object that is used to represent the play area in the scene.
            </summary>
            <returns>A transform of the object representing the play area in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.GetPlayAreaVertices">
            <summary>
            The GetPlayAreaVertices method returns the points of the play area boundaries.
            </summary>
            <returns>A Vector3 array of the points in the scene that represent the play area boundaries.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.GetPlayAreaBorderThickness">
            <summary>
            The GetPlayAreaBorderThickness returns the thickness of the drawn border for the given play area.
            </summary>
            <returns>The thickness of the drawn border.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.IsPlayAreaSizeCalibrated">
            <summary>
            The IsPlayAreaSizeCalibrated method returns whether the given play area size has been auto calibrated by external sensors.
            </summary>
            <returns>Returns true if the play area size has been auto calibrated and set by external sensors.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.GetDrawAtRuntime">
            <summary>
            The GetDrawAtRuntime method returns whether the given play area drawn border is being displayed.
            </summary>
            <returns>Returns true if the drawn border is being displayed.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityBoundaries.SetDrawAtRuntime(System.Boolean)">
            <summary>
            The SetDrawAtRuntime method sets whether the given play area drawn border should be displayed at runtime.
            </summary>
            <param name="value">The state of whether the drawn border should be displayed or not.</param>
        </member>
        <member name="T:VRTK.SDK_UnityCameraRig">
            <summary>
            The `[UnityBase_CameraRig]` prefab is a default camera rig set up for use with the Unity SDK support.
            </summary>
            <remarks>
            The Unity CameraRig also utilises the Unity Controller Tracker and Headset Tracker to enable GameObject tracking of it's position/rotation to the available connected VR device via the `UnityEngine.VR` library.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_UnityController">
            <summary>
            The Unity Controller SDK script provides a bridge  to the base Unity input device support.
            </summary>
        </member>
        <member name="M:VRTK.SDK_UnityController.ProcessUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_UnityController.ProcessFixedUpdate(VRTK.VRTK_ControllerReference,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="controllerReference">The reference for the controller.</param>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetCurrentControllerType(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetCurrentControllerType method returns the current used ControllerType based on the SDK and headset being used.
            </summary>
            <param name="controllerReference">The reference to the controller to get type of.</param>
            <returns>The ControllerType based on the SDK and headset being used.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerDefaultColliderPath(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerDefaultColliderPath returns the path to the prefab that contains the collider objects for the default controller of this SDK.
            </summary>
            <param name="hand">The controller hand to check for</param>
            <returns>A path to the resource that contains the collider GameObject.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerElementPath(VRTK.SDK_BaseController.ControllerElements,VRTK.SDK_BaseController.ControllerHand,System.Boolean)">
            <summary>
            The GetControllerElementPath returns the path to the game object that the given controller element for the given hand resides in.
            </summary>
            <param name="element">The controller element to look up.</param>
            <param name="hand">The controller hand to look up.</param>
            <param name="fullPath">Whether to get the initial path or the full path to the element.</param>
            <returns>A string containing the path to the game object that the controller element resides in.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerIndex(UnityEngine.GameObject)">
            <summary>
            The GetControllerIndex method returns the index of the given controller.
            </summary>
            <param name="controller">The GameObject containing the controller.</param>
            <returns>The index of the given controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerByIndex(System.UInt32,System.Boolean)">
            <summary>
            The GetControllerByIndex method returns the GameObject of a controller with a specific index.
            </summary>
            <param name="index">The index of the controller to find.</param>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject of the controller</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerOrigin(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerOrigin method returns the origin of the given controller.
            </summary>
            <param name="controllerReference">The reference to the controller to retrieve the origin from.</param>
            <returns>A Transform containing the origin of the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GenerateControllerPointerOrigin(UnityEngine.GameObject)">
            <summary>
            The GenerateControllerPointerOrigin method can create a custom pointer origin Transform to represent the pointer position and forward.
            </summary>
            <param name="parent">The GameObject that the origin will become parent of. If it is a controller then it will also be used to determine the hand if required.</param>
            <returns>A generated Transform that contains the custom pointer origin.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerLeftHand(System.Boolean)">
            <summary>
            The GetControllerLeftHand method returns the GameObject containing the representation of the left hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerRightHand(System.Boolean)">
            <summary>
            The GetControllerRightHand method returns the GameObject containing the representation of the right hand controller.
            </summary>
            <param name="actual">If true it will return the actual controller, if false it will return the script alias controller GameObject.</param>
            <returns>The GameObject containing the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.IsControllerLeftHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerLeftHand/1 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.IsControllerRightHand(UnityEngine.GameObject)">
            <summary>
            The IsControllerRightHand/1 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.IsControllerLeftHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerLeftHand/2 method is used to check if the given controller is the the left hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the left hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.IsControllerRightHand(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The IsControllerRightHand/2 method is used to check if the given controller is the the right hand controller.
            </summary>
            <param name="controller">The GameObject to check.</param>
            <param name="actual">If true it will check the actual controller, if false it will check the script alias controller.</param>
            <returns>Returns true if the given controller is the right hand controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.WaitForControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The WaitForControllerModel method determines whether the controller model for the given hand requires waiting to load in on scene start.
            </summary>
            <param name="hand">The hand to determine if the controller model will be ready for.</param>
            <returns>Returns true if the controller model requires loading in at runtime and therefore needs waiting for. Returns false if the controller model will be available at start.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerModel(UnityEngine.GameObject)">
            <summary>
            The GetControllerModel method returns the model alias for the given GameObject.
            </summary>
            <param name="controller">The GameObject to get the model alias for.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerModel(VRTK.SDK_BaseController.ControllerHand)">
            <summary>
            The GetControllerModel method returns the model alias for the given controller hand.
            </summary>
            <param name="hand">The hand enum of which controller model to retrieve.</param>
            <returns>The GameObject that has the model alias within it.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerRenderModel(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerRenderModel method gets the game object that contains the given controller's render model.
            </summary>
            <param name="controllerReference">The reference to the controller to check.</param>
            <returns>A GameObject containing the object that has a render model for the controller.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.SetControllerRenderModelWheel(UnityEngine.GameObject,System.Boolean)">
            <summary>
            The SetControllerRenderModelWheel method sets the state of the scroll wheel on the controller render model.
            </summary>
            <param name="renderModel">The GameObject containing the controller render model.</param>
            <param name="state">If true and the render model has a scroll wheen then it will be displayed, if false then the scroll wheel will be hidden.</param>
        </member>
        <member name="M:VRTK.SDK_UnityController.HapticPulse(VRTK.VRTK_ControllerReference,System.Single)">
            <summary>
            The HapticPulse/2 method is used to initiate a simple haptic pulse on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="strength">The intensity of the rumble of the controller motor. `0` to `1`.</param>
        </member>
        <member name="M:VRTK.SDK_UnityController.HapticPulse(VRTK.VRTK_ControllerReference,UnityEngine.AudioClip)">
            <summary>
            The HapticPulse/2 method is used to initiate a haptic pulse based on an audio clip on the tracked object of the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to initiate the haptic pulse on.</param>
            <param name="clip">The audio clip to use for the haptic pattern.</param>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetHapticModifiers">
            <summary>
            The GetHapticModifiers method is used to return modifiers for the duration and interval if the SDK handles it slightly differently.
            </summary>
            <returns>An SDK_ControllerHapticModifiers object with a given `durationModifier` and an `intervalModifier`.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetVelocity method is used to determine the current velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetAngularVelocity(VRTK.VRTK_ControllerReference)">
            <summary>
            The GetAngularVelocity method is used to determine the current angular velocity of the tracked object on the given controller reference.
            </summary>
            <param name="controllerReference">The reference to the tracked object to check for.</param>
            <returns>A Vector3 containing the current angular velocity of the tracked object.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.IsTouchpadStatic(System.Boolean,UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
            <summary>
            The IsTouchpadStatic method is used to determine if the touchpad is currently not being moved.
            </summary>
            <param name="currentAxisValues"></param>
            <param name="previousAxisValues"></param>
            <param name="compareFidelity"></param>
            <returns>Returns true if the touchpad is not currently being touched or moved.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetButtonAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonAxis method retrieves the current X/Y axis values for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the axis on.</param>
            <param name="controllerReference">The reference to the controller to check the button axis on.</param>
            <returns>A Vector2 of the X/Y values of the button axis. If no axis values exist for the given button, then a Vector2.Zero is returned.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetButtonSenseAxis(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonSenseAxis method retrieves the current sense axis value for the given button type on the given controller reference.
            </summary>
            <param name="buttonType">The type of button to check for the sense axis on.</param>
            <param name="controllerReference">The reference to the controller to check the sense axis on.</param>
            <returns>The current sense axis value.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetButtonHairlineDelta(VRTK.SDK_BaseController.ButtonTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetButtonHairlineDelta method is used to get the difference between the current button press and the previous frame button press.
            </summary>
            <param name="buttonType">The type of button to get the hairline delta for.</param>
            <param name="controllerReference">The reference to the controller to get the hairline delta for.</param>
            <returns>The delta between the button presses.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityController.GetControllerButtonState(VRTK.SDK_BaseController.ButtonTypes,VRTK.SDK_BaseController.ButtonPressTypes,VRTK.VRTK_ControllerReference)">
            <summary>
            The GetControllerButtonState method is used to determine if the given controller button for the given press type on the given controller reference is currently taking place.
            </summary>
            <param name="buttonType">The type of button to check for the state of.</param>
            <param name="pressType">The button state to check for.</param>
            <param name="controllerReference">The reference to the controller to check the button state on.</param>
            <returns>Returns true if the given button is in the state of the given press type on the given controller reference.</returns>
        </member>
        <member name="T:VRTK.SDK_UnityControllerTracker">
            <summary>
            The Controller Tracker enables the GameObject to track it's position/rotation to the available connected VR Controller via the `UnityEngine.VR` library.
            </summary>
            <remarks>
            The Unity Controller Tracker is attached to the `[UnityBase_CameraRig]` prefab on the child `LeftHandAnchor` and `RightHandAnchor` to enable controller tracking.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_UnityHeadset">
            <summary>
            The Unity Headset SDK script provides a bridge to the base Unity headset support.
            </summary>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.ProcessUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessUpdate method enables an SDK to run logic for every Unity Update
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the update.</param>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.ProcessFixedUpdate(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            The ProcessFixedUpdate method enables an SDK to run logic for every Unity FixedUpdate
            </summary>
            <param name="options">A dictionary of generic options that can be used to within the fixed update.</param>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.GetHeadset">
            <summary>
            The GetHeadset method returns the Transform of the object that is used to represent the headset in the scene.
            </summary>
            <returns>A transform of the object representing the headset in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.GetHeadsetCamera">
            <summary>
            The GetHeadsetCamera method returns the Transform of the object that is used to hold the headset camera in the scene.
            </summary>
            <returns>A transform of the object holding the headset camera in the scene.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.GetHeadsetType">
            <summary>
            The GetHeadsetType method returns a string representing the type of headset connected.
            </summary>
            <returns>The string of the headset connected.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.GetHeadsetVelocity">
            <summary>
            The GetHeadsetVelocity method is used to determine the current velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.GetHeadsetAngularVelocity">
            <summary>
            The GetHeadsetAngularVelocity method is used to determine the current angular velocity of the headset.
            </summary>
            <returns>A Vector3 containing the current angular velocity of the headset.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.HeadsetFade(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            The HeadsetFade method is used to apply a fade to the headset camera to progressively change the colour.
            </summary>
            <param name="color">The colour to fade to.</param>
            <param name="duration">The amount of time the fade should take to reach the given colour.</param>
            <param name="fadeOverlay">Determines whether to use an overlay on the fade.</param>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.HasHeadsetFade(UnityEngine.Transform)">
            <summary>
            The HasHeadsetFade method checks to see if the given game object (usually the camera) has the ability to fade the viewpoint.
            </summary>
            <param name="obj">The Transform to check to see if a camera fade is available on.</param>
            <returns>Returns true if the headset has fade functionality on it.</returns>
        </member>
        <member name="M:VRTK.SDK_UnityHeadset.AddHeadsetFade(UnityEngine.Transform)">
            <summary>
            The AddHeadsetFade method attempts to add the fade functionality to the game object with the camera on it.
            </summary>
            <param name="camera">The Transform to with the camera on to add the fade functionality to.</param>
        </member>
        <member name="T:VRTK.SDK_UnityHeadsetTracker">
            <summary>
            The Headset Tracker enables the GameObject to track it's position/rotation to the available connected VR HMD via the `UnityEngine.VR` library.
            </summary>
            <remarks>
            The Unity Headset Tracker is attached to the `[UnityBase_CameraRig]` prefab on the child `Head` HMD tracking.
            </remarks>
        </member>
        <member name="T:VRTK.SDK_UnitySystem">
            <summary>
            The Unity System SDK script provides a bridge to the Unity SDK.
            </summary>
        </member>
        <member name="M:VRTK.SDK_UnitySystem.IsDisplayOnDesktop">
            <summary>
            The IsDisplayOnDesktop method returns true if the display is extending the desktop.
            </summary>
            <returns>Returns true if the display is extending the desktop</returns>
        </member>
        <member name="M:VRTK.SDK_UnitySystem.ShouldAppRenderWithLowResources">
            <summary>
            The ShouldAppRenderWithLowResources method is used to determine if the Unity app should use low resource mode. Typically true when the dashboard is showing.
            </summary>
            <returns>Returns true if the Unity app should render with low resources.</returns>
        </member>
        <member name="M:VRTK.SDK_UnitySystem.ForceInterleavedReprojectionOn(System.Boolean)">
            <summary>
            The ForceInterleavedReprojectionOn method determines whether Interleaved Reprojection should be forced on or off.
            </summary>
            <param name="force">If true then Interleaved Reprojection will be forced on, if false it will not be forced on.</param>
        </member>
        <member name="T:VRTK.WindowsMixedReality.Utilities.InteractionSourceExtensions">
            <summary>
            Extensions for the InteractionSource class to add haptics and expose the renderable model.
            </summary>
        </member>
        <member name="T:VRTK.WindowsMixedReality.Utilities.WindowsApiChecker">
            <summary>
            Helper class for determining if a Windows API contract is available.
            <remarks> See https://docs.microsoft.com/en-us/uwp/extension-sdks/windows-universal-sdk
            for a full list of contracts.</remarks>
            </summary>
        </member>
        <member name="P:VRTK.WindowsMixedReality.Utilities.WindowsApiChecker.UniversalApiContractV5_IsAvailable">
            <summary>
            Is the Universal API Contract v5.0 Available?
            </summary>
        </member>
        <member name="P:VRTK.WindowsMixedReality.Utilities.WindowsApiChecker.UniversalApiContractV4_IsAvailable">
            <summary>
            Is the Universal API Contract v4.0 Available?
            </summary>
        </member>
        <member name="P:VRTK.WindowsMixedReality.Utilities.WindowsApiChecker.UniversalApiContractV3_IsAvailable">
            <summary>
            Is the Universal API Contract v3.0 Available?
            </summary>
        </member>
        <member name="T:VRTK.WindowsMR_Camera">
            <summary>
            Camera script for the main camera for Immersive Mixed Reality. 
            </summary>
        </member>
        <member name="F:VRTK.WindowsMR_Camera.DEVICE_NAME">
            <summary>
            Name of the Windows Mixed Reality Device as listed in XRSettings.
            </summary>
        </member>
        <member name="M:VRTK.WindowsMR_Camera.CheckForMixedRealitySupport">
            <summary>
            Check if the Mixed (Virtual) Reality Settings are properly set.
            </summary>
            <returns>Are the settings set.</returns>
        </member>
        <member name="M:VRTK.WindowsMR_Camera.SetupMRCamera">
            <summary>
            Setup the MR camera properly.
            </summary>
        </member>
        <member name="T:VRTK.SDK_WindowsMRBoundaries">
            <summary>
            The WindowsMR Boundaries SDK script provides a bridge to the Windows Mixed Reality SDK play area.
            </summary>
        </member>
        <member name="T:VRTK.SDK_WindowsMRController">
            <summary>
            The WindowsMR Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="T:VRTK.SDK_WindowsMRDefines">
            <summary>
            Handles all the scripting define symbols for the Windows Immersive Mixed Reality SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_WindowsMRDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Immersive Mixed Reality SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_WindowsMRHeadset">
            <summary>
            The WindowsMR Headset SDK script provides a bridge to the WindowsMR XR.
            </summary>
        </member>
        <member name="T:VRTK.SDK_WindowsMR">
            <summary>
            The Windows Mixed Reality System SDK script provides a bridge to the Windows Mixed Reality Unity SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_XimmerseBoundaries">
            <summary>
            The Ximmerse Boundaries SDK script provides a bridge to the Ximmerse SDK play area.
            </summary>
        </member>
        <member name="T:VRTK.SDK_XimmerseController">
            <summary>
            The Ximmerse Controller SDK script provides a bridge to SDK methods that deal with the input devices.
            </summary>
        </member>
        <member name="T:VRTK.SDK_XimmerseDefines">
            <summary>
            Handles all the scripting define symbols for the Ximmerse SDK.
            </summary>
        </member>
        <member name="F:VRTK.SDK_XimmerseDefines.ScriptingDefineSymbol">
            <summary>
            The scripting define symbol for the Ximmerse SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_XimmerseHeadset">
            <summary>
            The Ximmerse Headset SDK script provides a bridge to the Ximmerse SDK.
            </summary>
        </member>
        <member name="T:VRTK.SDK_XimmerseSystem">
            <summary>
            The Ximmerse System SDK script provides a bridge to the Ximmerse SDK.
            </summary>
        </member>
    </members>
</doc>
